{
  "language": "Solidity",
  "sources": {
    "@aragon/osx/core/dao/IDAO.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.8;\n\n/// @title IDAO\n/// @author Aragon Association - 2022-2023\n/// @notice The interface required for DAOs within the Aragon App DAO framework.\ninterface IDAO {\n    /// @notice The action struct to be consumed by the DAO's `execute` function resulting in an external call.\n    /// @param to The address to call.\n    /// @param value The native token value to be sent with the call.\n    /// @param data The bytes-encoded function selector and calldata for the call.\n    struct Action {\n        address to;\n        uint256 value;\n        bytes data;\n    }\n\n    /// @notice Checks if an address has permission on a contract via a permission identifier and considers if `ANY_ADDRESS` was used in the granting process.\n    /// @param _where The address of the contract.\n    /// @param _who The address of a EOA or contract to give the permissions.\n    /// @param _permissionId The permission identifier.\n    /// @param _data The optional data passed to the `PermissionCondition` registered.\n    /// @return Returns true if the address has permission, false if not.\n    function hasPermission(\n        address _where,\n        address _who,\n        bytes32 _permissionId,\n        bytes memory _data\n    ) external view returns (bool);\n\n    /// @notice Updates the DAO metadata (e.g., an IPFS hash).\n    /// @param _metadata The IPFS hash of the new metadata object.\n    function setMetadata(bytes calldata _metadata) external;\n\n    /// @notice Emitted when the DAO metadata is updated.\n    /// @param metadata The IPFS hash of the new metadata object.\n    event MetadataSet(bytes metadata);\n\n    /// @notice Executes a list of actions. If a zero allow-failure map is provided, a failing action reverts the entire execution. If a non-zero allow-failure map is provided, allowed actions can fail without the entire call being reverted.\n    /// @param _callId The ID of the call. The definition of the value of `callId` is up to the calling contract and can be used, e.g., as a nonce.\n    /// @param _actions The array of actions.\n    /// @param _allowFailureMap A bitmap allowing execution to succeed, even if individual actions might revert. If the bit at index `i` is 1, the execution succeeds even if the `i`th action reverts. A failure map value of 0 requires every action to not revert.\n    /// @return The array of results obtained from the executed actions in `bytes`.\n    /// @return The resulting failure map containing the actions have actually failed.\n    function execute(\n        bytes32 _callId,\n        Action[] memory _actions,\n        uint256 _allowFailureMap\n    ) external returns (bytes[] memory, uint256);\n\n    /// @notice Emitted when a proposal is executed.\n    /// @param actor The address of the caller.\n    /// @param callId The ID of the call.\n    /// @param actions The array of actions executed.\n    /// @param allowFailureMap The allow failure map encoding which actions are allowed to fail.\n    /// @param failureMap The failure map encoding which actions have failed.\n    /// @param execResults The array with the results of the executed actions.\n    /// @dev The value of `callId` is defined by the component/contract calling the execute function. A `Plugin` implementation can use it, for example, as a nonce.\n    event Executed(\n        address indexed actor,\n        bytes32 callId,\n        Action[] actions,\n        uint256 allowFailureMap,\n        uint256 failureMap,\n        bytes[] execResults\n    );\n\n    /// @notice Emitted when a standard callback is registered.\n    /// @param interfaceId The ID of the interface.\n    /// @param callbackSelector The selector of the callback function.\n    /// @param magicNumber The magic number to be registered for the callback function selector.\n    event StandardCallbackRegistered(\n        bytes4 interfaceId,\n        bytes4 callbackSelector,\n        bytes4 magicNumber\n    );\n\n    /// @notice Deposits (native) tokens to the DAO contract with a reference string.\n    /// @param _token The address of the token or address(0) in case of the native token.\n    /// @param _amount The amount of tokens to deposit.\n    /// @param _reference The reference describing the deposit reason.\n    function deposit(address _token, uint256 _amount, string calldata _reference) external payable;\n\n    /// @notice Emitted when a token deposit has been made to the DAO.\n    /// @param sender The address of the sender.\n    /// @param token The address of the deposited token.\n    /// @param amount The amount of tokens deposited.\n    /// @param _reference The reference describing the deposit reason.\n    event Deposited(\n        address indexed sender,\n        address indexed token,\n        uint256 amount,\n        string _reference\n    );\n\n    /// @notice Emitted when a native token deposit has been made to the DAO.\n    /// @dev This event is intended to be emitted in the `receive` function and is therefore bound by the gas limitations for `send`/`transfer` calls introduced by [ERC-2929](https://eips.ethereum.org/EIPS/eip-2929).\n    /// @param sender The address of the sender.\n    /// @param amount The amount of native tokens deposited.\n    event NativeTokenDeposited(address sender, uint256 amount);\n\n    /// @notice Setter for the trusted forwarder verifying the meta transaction.\n    /// @param _trustedForwarder The trusted forwarder address.\n    function setTrustedForwarder(address _trustedForwarder) external;\n\n    /// @notice Getter for the trusted forwarder verifying the meta transaction.\n    /// @return The trusted forwarder address.\n    function getTrustedForwarder() external view returns (address);\n\n    /// @notice Emitted when a new TrustedForwarder is set on the DAO.\n    /// @param forwarder the new forwarder address.\n    event TrustedForwarderSet(address forwarder);\n\n    /// @notice Setter for the [ERC-1271](https://eips.ethereum.org/EIPS/eip-1271) signature validator contract.\n    /// @param _signatureValidator The address of the signature validator.\n    function setSignatureValidator(address _signatureValidator) external;\n\n    /// @notice Emitted when the signature validator address is updated.\n    /// @param signatureValidator The address of the signature validator.\n    event SignatureValidatorSet(address signatureValidator);\n\n    /// @notice Checks whether a signature is valid for the provided hash by forwarding the call to the set [ERC-1271](https://eips.ethereum.org/EIPS/eip-1271) signature validator contract.\n    /// @param _hash The hash of the data to be signed.\n    /// @param _signature The signature byte array associated with `_hash`.\n    /// @return Returns the `bytes4` magic value `0x1626ba7e` if the signature is valid.\n    function isValidSignature(bytes32 _hash, bytes memory _signature) external returns (bytes4);\n\n    /// @notice Registers an ERC standard having a callback by registering its [ERC-165](https://eips.ethereum.org/EIPS/eip-165) interface ID and callback function signature.\n    /// @param _interfaceId The ID of the interface.\n    /// @param _callbackSelector The selector of the callback function.\n    /// @param _magicNumber The magic number to be registered for the function signature.\n    function registerStandardCallback(\n        bytes4 _interfaceId,\n        bytes4 _callbackSelector,\n        bytes4 _magicNumber\n    ) external;\n}\n"
    },
    "@aragon/osx/core/permission/IPermissionCondition.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.8;\n\n/// @title IPermissionCondition\n/// @author Aragon Association - 2021-2023\n/// @notice This interface can be implemented to support more customary permissions depending on on- or off-chain state, e.g., by querying token ownershop or a secondary condition, respectively.\ninterface IPermissionCondition {\n    /// @notice This method is used to check if a call is permitted.\n    /// @param _where The address of the target contract.\n    /// @param _who The address (EOA or contract) for which the permissions are checked.\n    /// @param _permissionId The permission identifier.\n    /// @param _data Optional data passed to the `PermissionCondition` implementation.\n    /// @return allowed Returns true if the call is permitted.\n    function isGranted(\n        address _where,\n        address _who,\n        bytes32 _permissionId,\n        bytes calldata _data\n    ) external view returns (bool allowed);\n}\n"
    },
    "@aragon/osx/core/permission/PermissionCondition.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.8;\n\nimport {ERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\nimport {IPermissionCondition} from \"./IPermissionCondition.sol\";\n\n/// @title PermissionCondition\n/// @author Aragon Association - 2023\n/// @notice An abstract contract for non-upgradeable contracts instantiated via the `new` keyword  to inherit from to support customary permissions depending on arbitrary on-chain state.\nabstract contract PermissionCondition is ERC165, IPermissionCondition {\n    /// @notice Checks if an interface is supported by this or its parent contract.\n    /// @param _interfaceId The ID of the interface.\n    /// @return Returns `true` if the interface is supported.\n    function supportsInterface(bytes4 _interfaceId) public view override returns (bool) {\n        return\n            _interfaceId == type(IPermissionCondition).interfaceId ||\n            super.supportsInterface(_interfaceId);\n    }\n}\n"
    },
    "@aragon/osx/core/permission/PermissionLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.8;\n\n/// @title PermissionLib\n/// @author Aragon Association - 2021-2023\n/// @notice A library containing objects for permission processing.\nlibrary PermissionLib {\n    /// @notice A constant expressing that no condition is applied to a permission.\n    address public constant NO_CONDITION = address(0);\n\n    /// @notice The types of permission operations available in the `PermissionManager`.\n    /// @param Grant The grant operation setting a permission without a condition.\n    /// @param Revoke The revoke operation removing a permission (that was granted with or without a condition).\n    /// @param GrantWithCondition The grant operation setting a permission with a condition.\n    enum Operation {\n        Grant,\n        Revoke,\n        GrantWithCondition\n    }\n\n    /// @notice A struct containing the information for a permission to be applied on a single target contract without a condition.\n    /// @param operation The permission operation type.\n    /// @param who The address (EOA or contract) receiving the permission.\n    /// @param permissionId The permission identifier.\n    struct SingleTargetPermission {\n        Operation operation;\n        address who;\n        bytes32 permissionId;\n    }\n\n    /// @notice A struct containing the information for a permission to be applied on multiple target contracts, optionally, with a condition.\n    /// @param operation The permission operation type.\n    /// @param where The address of the target contract for which `who` receives permission.\n    /// @param who The address (EOA or contract) receiving the permission.\n    /// @param condition The `PermissionCondition` that will be asked for authorization on calls connected to the specified permission identifier.\n    /// @param permissionId The permission identifier.\n    struct MultiTargetPermission {\n        Operation operation;\n        address where;\n        address who;\n        address condition;\n        bytes32 permissionId;\n    }\n}\n"
    },
    "@aragon/osx/core/permission/PermissionManager.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.8;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\n\nimport {IPermissionCondition} from \"./IPermissionCondition.sol\";\nimport {PermissionCondition} from \"./PermissionCondition.sol\";\nimport \"./PermissionLib.sol\";\n\n/// @title PermissionManager\n/// @author Aragon Association - 2021-2023\n/// @notice The abstract permission manager used in a DAO, its associated plugins, and other framework-related components.\nabstract contract PermissionManager is Initializable {\n    using AddressUpgradeable for address;\n\n    /// @notice The ID of the permission required to call the `grant`, `grantWithCondition`, `revoke`, and `bulk` function.\n    bytes32 public constant ROOT_PERMISSION_ID = keccak256(\"ROOT_PERMISSION\");\n\n    /// @notice A special address encoding permissions that are valid for any address `who` or `where`.\n    address internal constant ANY_ADDR = address(type(uint160).max);\n\n    /// @notice A special address encoding if a permissions is not set and therefore not allowed.\n    address internal constant UNSET_FLAG = address(0);\n\n    /// @notice A special address encoding if a permission is allowed.\n    address internal constant ALLOW_FLAG = address(2);\n\n    /// @notice A mapping storing permissions as hashes (i.e., `permissionHash(where, who, permissionId)`) and their status encoded by an address (unset, allowed, or redirecting to a `PermissionCondition`).\n    mapping(bytes32 => address) internal permissionsHashed;\n\n    /// @notice Thrown if a call is unauthorized.\n    /// @param where The context in which the authorization reverted.\n    /// @param who The address (EOA or contract) missing the permission.\n    /// @param permissionId The permission identifier.\n    error Unauthorized(address where, address who, bytes32 permissionId);\n\n    /// @notice Thrown if a permission has been already granted with a different condition.\n    /// @dev This makes sure that condition on the same permission can not be overwriten by a different condition.\n    /// @param where The address of the target contract to grant `_who` permission to.\n    /// @param who The address (EOA or contract) to which the permission has already been granted.\n    /// @param permissionId The permission identifier.\n    /// @param currentCondition The current condition set for permissionId.\n    /// @param newCondition The new condition it tries to set for permissionId.\n    error PermissionAlreadyGrantedForDifferentCondition(\n        address where,\n        address who,\n        bytes32 permissionId,\n        address currentCondition,\n        address newCondition\n    );\n\n    /// @notice Thrown if a condition address is not a contract.\n    /// @param condition The address that is not a contract.\n    error ConditionNotAContract(IPermissionCondition condition);\n\n    /// @notice Thrown if a condition contract does not support the `IPermissionCondition` interface.\n    /// @param condition The address that is not a contract.\n    error ConditionInterfacNotSupported(IPermissionCondition condition);\n\n    /// @notice Thrown for `ROOT_PERMISSION_ID` or `EXECUTE_PERMISSION_ID` permission grants where `who` or `where` is `ANY_ADDR`.\n\n    error PermissionsForAnyAddressDisallowed();\n\n    /// @notice Thrown for permission grants where `who` and `where` are both `ANY_ADDR`.\n    error AnyAddressDisallowedForWhoAndWhere();\n\n    /// @notice Thrown if `Operation.GrantWithCondition` is requested as an operation but the method does not support it.\n    error GrantWithConditionNotSupported();\n\n    /// @notice Emitted when a permission `permission` is granted in the context `here` to the address `_who` for the contract `_where`.\n    /// @param permissionId The permission identifier.\n    /// @param here The address of the context in which the permission is granted.\n    /// @param where The address of the target contract for which `_who` receives permission.\n    /// @param who The address (EOA or contract) receiving the permission.\n    /// @param condition The address `ALLOW_FLAG` for regular permissions or, alternatively, the `IPermissionCondition` contract implementation to be used.\n    event Granted(\n        bytes32 indexed permissionId,\n        address indexed here,\n        address where,\n        address indexed who,\n        address condition\n    );\n\n    /// @notice Emitted when a permission `permission` is revoked in the context `here` from the address `_who` for the contract `_where`.\n    /// @param permissionId The permission identifier.\n    /// @param here The address of the context in which the permission is revoked.\n    /// @param where The address of the target contract for which `_who` loses permission.\n    /// @param who The address (EOA or contract) losing the permission.\n    event Revoked(\n        bytes32 indexed permissionId,\n        address indexed here,\n        address where,\n        address indexed who\n    );\n\n    /// @notice A modifier to make functions on inheriting contracts authorized. Permissions to call the function are checked through this permission manager.\n    /// @param _permissionId The permission identifier required to call the method this modifier is applied to.\n    modifier auth(bytes32 _permissionId) {\n        _auth(_permissionId);\n        _;\n    }\n\n    /// @notice Initialization method to set the initial owner of the permission manager.\n    /// @dev The initial owner is granted the `ROOT_PERMISSION_ID` permission.\n    /// @param _initialOwner The initial owner of the permission manager.\n    function __PermissionManager_init(address _initialOwner) internal onlyInitializing {\n        _initializePermissionManager(_initialOwner);\n    }\n\n    /// @notice Grants permission to an address to call methods in a contract guarded by an auth modifier with the specified permission identifier.\n    /// @dev Requires the `ROOT_PERMISSION_ID` permission.\n    /// @param _where The address of the target contract for which `_who` receives permission.\n    /// @param _who The address (EOA or contract) receiving the permission.\n    /// @param _permissionId The permission identifier.\n    /// @dev Note, that granting permissions with `_who` or `_where` equal to `ANY_ADDR` does not replace other permissions with specific `_who` and `_where` addresses that exist in parallel.\n    function grant(\n        address _where,\n        address _who,\n        bytes32 _permissionId\n    ) external virtual auth(ROOT_PERMISSION_ID) {\n        _grant(_where, _who, _permissionId);\n    }\n\n    /// @notice Grants permission to an address to call methods in a target contract guarded by an auth modifier with the specified permission identifier if the referenced condition permits it.\n    /// @dev Requires the `ROOT_PERMISSION_ID` permission\n    /// @param _where The address of the target contract for which `_who` receives permission.\n    /// @param _who The address (EOA or contract) receiving the permission.\n    /// @param _permissionId The permission identifier.\n    /// @param _condition The `PermissionCondition` that will be asked for authorization on calls connected to the specified permission identifier.\n    /// @dev Note, that granting permissions with `_who` or `_where` equal to `ANY_ADDR` does not replace other permissions with specific `_who` and `_where` addresses that exist in parallel.\n    function grantWithCondition(\n        address _where,\n        address _who,\n        bytes32 _permissionId,\n        IPermissionCondition _condition\n    ) external virtual auth(ROOT_PERMISSION_ID) {\n        _grantWithCondition(_where, _who, _permissionId, _condition);\n    }\n\n    /// @notice Revokes permission from an address to call methods in a target contract guarded by an auth modifier with the specified permission identifier.\n    /// @dev Requires the `ROOT_PERMISSION_ID` permission.\n    /// @param _where The address of the target contract for which `_who` loses permission.\n    /// @param _who The address (EOA or contract) losing the permission.\n    /// @param _permissionId The permission identifier.\n    /// @dev Note, that revoking permissions with `_who` or `_where` equal to `ANY_ADDR` does not revoke other permissions with specific `_who` and `_where` addresses that exist in parallel.\n    function revoke(\n        address _where,\n        address _who,\n        bytes32 _permissionId\n    ) external virtual auth(ROOT_PERMISSION_ID) {\n        _revoke(_where, _who, _permissionId);\n    }\n\n    /// @notice Applies an array of permission operations on a single target contracts `_where`.\n    /// @param _where The address of the single target contract.\n    /// @param items The array of single-targeted permission operations to apply.\n    function applySingleTargetPermissions(\n        address _where,\n        PermissionLib.SingleTargetPermission[] calldata items\n    ) external virtual auth(ROOT_PERMISSION_ID) {\n        for (uint256 i; i < items.length; ) {\n            PermissionLib.SingleTargetPermission memory item = items[i];\n\n            if (item.operation == PermissionLib.Operation.Grant) {\n                _grant(_where, item.who, item.permissionId);\n            } else if (item.operation == PermissionLib.Operation.Revoke) {\n                _revoke(_where, item.who, item.permissionId);\n            } else if (item.operation == PermissionLib.Operation.GrantWithCondition) {\n                revert GrantWithConditionNotSupported();\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Applies an array of permission operations on multiple target contracts `items[i].where`.\n    /// @param _items The array of multi-targeted permission operations to apply.\n    function applyMultiTargetPermissions(\n        PermissionLib.MultiTargetPermission[] calldata _items\n    ) external virtual auth(ROOT_PERMISSION_ID) {\n        for (uint256 i; i < _items.length; ) {\n            PermissionLib.MultiTargetPermission memory item = _items[i];\n\n            if (item.operation == PermissionLib.Operation.Grant) {\n                _grant(item.where, item.who, item.permissionId);\n            } else if (item.operation == PermissionLib.Operation.Revoke) {\n                _revoke(item.where, item.who, item.permissionId);\n            } else if (item.operation == PermissionLib.Operation.GrantWithCondition) {\n                _grantWithCondition(\n                    item.where,\n                    item.who,\n                    item.permissionId,\n                    IPermissionCondition(item.condition)\n                );\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Checks if an address has permission on a contract via a permission identifier and considers if `ANY_ADDRESS` was used in the granting process.\n    /// @param _where The address of the target contract for which `_who` receives permission.\n    /// @param _who The address (EOA or contract) for which the permission is checked.\n    /// @param _permissionId The permission identifier.\n    /// @param _data The optional data passed to the `PermissionCondition` registered.\n    /// @return Returns true if `_who` has the permissions on the target contract via the specified permission identifier.\n    function isGranted(\n        address _where,\n        address _who,\n        bytes32 _permissionId,\n        bytes memory _data\n    ) public view virtual returns (bool) {\n        return\n            _isGranted(_where, _who, _permissionId, _data) || // check if `_who` has permission for `_permissionId` on `_where`\n            _isGranted(_where, ANY_ADDR, _permissionId, _data) || // check if anyone has permission for `_permissionId` on `_where`\n            _isGranted(ANY_ADDR, _who, _permissionId, _data); // check if `_who` has permission for `_permissionI` on any contract\n    }\n\n    /// @notice Grants the `ROOT_PERMISSION_ID` permission to the initial owner during initialization of the permission manager.\n    /// @param _initialOwner The initial owner of the permission manager.\n    function _initializePermissionManager(address _initialOwner) internal {\n        _grant(address(this), _initialOwner, ROOT_PERMISSION_ID);\n    }\n\n    /// @notice This method is used in the external `grant` method of the permission manager.\n    /// @param _where The address of the target contract for which `_who` receives permission.\n    /// @param _who The address (EOA or contract) owning the permission.\n    /// @param _permissionId The permission identifier.\n    /// @dev Note, that granting permissions with `_who` or `_where` equal to `ANY_ADDR` does not replace other permissions with specific `_who` and `_where` addresses that exist in parallel.\n    function _grant(address _where, address _who, bytes32 _permissionId) internal virtual {\n        if (_where == ANY_ADDR || _who == ANY_ADDR) {\n            revert PermissionsForAnyAddressDisallowed();\n        }\n\n        bytes32 permHash = permissionHash(_where, _who, _permissionId);\n\n        address currentFlag = permissionsHashed[permHash];\n\n        // Means permHash is not currently set.\n        if (currentFlag == UNSET_FLAG) {\n            permissionsHashed[permHash] = ALLOW_FLAG;\n\n            emit Granted(_permissionId, msg.sender, _where, _who, ALLOW_FLAG);\n        }\n    }\n\n    /// @notice This method is used in the external `grantWithCondition` method of the permission manager.\n    /// @param _where The address of the target contract for which `_who` receives permission.\n    /// @param _who The address (EOA or contract) owning the permission.\n    /// @param _permissionId The permission identifier.\n    /// @param _condition An address either resolving to a `PermissionCondition` contract address or being the `ALLOW_FLAG` address (`address(2)`).\n    /// @dev Note, that granting permissions with `_who` or `_where` equal to `ANY_ADDR` does not replace other permissions with specific `_who` and `_where` addresses that exist in parallel.\n    function _grantWithCondition(\n        address _where,\n        address _who,\n        bytes32 _permissionId,\n        IPermissionCondition _condition\n    ) internal virtual {\n        address conditionAddr = address(_condition);\n\n        if (!conditionAddr.isContract()) {\n            revert ConditionNotAContract(_condition);\n        }\n\n        if (\n            !PermissionCondition(conditionAddr).supportsInterface(\n                type(IPermissionCondition).interfaceId\n            )\n        ) {\n            revert ConditionInterfacNotSupported(_condition);\n        }\n\n        if (_where == ANY_ADDR && _who == ANY_ADDR) {\n            revert AnyAddressDisallowedForWhoAndWhere();\n        }\n\n        if (_where == ANY_ADDR || _who == ANY_ADDR) {\n            if (\n                _permissionId == ROOT_PERMISSION_ID ||\n                isPermissionRestrictedForAnyAddr(_permissionId)\n            ) {\n                revert PermissionsForAnyAddressDisallowed();\n            }\n        }\n\n        bytes32 permHash = permissionHash(_where, _who, _permissionId);\n\n        address currentCondition = permissionsHashed[permHash];\n\n        // Means permHash is not currently set.\n        if (currentCondition == UNSET_FLAG) {\n            permissionsHashed[permHash] = conditionAddr;\n\n            emit Granted(_permissionId, msg.sender, _where, _who, conditionAddr);\n        } else if (currentCondition != conditionAddr) {\n            // Revert if `permHash` is already granted, but uses a different condition.\n            // If we don't revert, we either should:\n            //   - allow overriding the condition on the same permission\n            //     which could be confusing whoever granted the same permission first\n            //   - or do nothing and succeed silently which could be confusing for the caller.\n            revert PermissionAlreadyGrantedForDifferentCondition({\n                where: _where,\n                who: _who,\n                permissionId: _permissionId,\n                currentCondition: currentCondition,\n                newCondition: conditionAddr\n            });\n        }\n    }\n\n    /// @notice This method is used in the public `revoke` method of the permission manager.\n    /// @param _where The address of the target contract for which `_who` receives permission.\n    /// @param _who The address (EOA or contract) owning the permission.\n    /// @param _permissionId The permission identifier.\n    /// @dev Note, that revoking permissions with `_who` or `_where` equal to `ANY_ADDR` does not revoke other permissions with specific `_who` and `_where` addresses that might have been granted in parallel.\n    function _revoke(address _where, address _who, bytes32 _permissionId) internal virtual {\n        bytes32 permHash = permissionHash(_where, _who, _permissionId);\n        if (permissionsHashed[permHash] != UNSET_FLAG) {\n            permissionsHashed[permHash] = UNSET_FLAG;\n\n            emit Revoked(_permissionId, msg.sender, _where, _who);\n        }\n    }\n\n    /// @notice Checks if a caller is granted permissions on a target contract via a permission identifier and redirects the approval to a `PermissionCondition` if this was specified in the setup.\n    /// @param _where The address of the target contract for which `_who` receives permission.\n    /// @param _who The address (EOA or contract) owning the permission.\n    /// @param _permissionId The permission identifier.\n    /// @param _data The optional data passed to the `PermissionCondition` registered.\n    /// @return Returns true if `_who` has the permissions on the contract via the specified permissionId identifier.\n    function _isGranted(\n        address _where,\n        address _who,\n        bytes32 _permissionId,\n        bytes memory _data\n    ) internal view virtual returns (bool) {\n        address accessFlagOrCondition = permissionsHashed[\n            permissionHash(_where, _who, _permissionId)\n        ];\n\n        if (accessFlagOrCondition == UNSET_FLAG) return false;\n        if (accessFlagOrCondition == ALLOW_FLAG) return true;\n\n        // Since it's not a flag, assume it's a PermissionCondition and try-catch to skip failures\n        try\n            IPermissionCondition(accessFlagOrCondition).isGranted(\n                _where,\n                _who,\n                _permissionId,\n                _data\n            )\n        returns (bool allowed) {\n            if (allowed) return true;\n        } catch {}\n\n        return false;\n    }\n\n    /// @notice A private function to be used to check permissions on the permission manager contract (`address(this)`) itself.\n    /// @param _permissionId The permission identifier required to call the method this modifier is applied to.\n    function _auth(bytes32 _permissionId) internal view virtual {\n        if (!isGranted(address(this), msg.sender, _permissionId, msg.data)) {\n            revert Unauthorized({\n                where: address(this),\n                who: msg.sender,\n                permissionId: _permissionId\n            });\n        }\n    }\n\n    /// @notice Generates the hash for the `permissionsHashed` mapping obtained from the word \"PERMISSION\", the contract address, the address owning the permission, and the permission identifier.\n    /// @param _where The address of the target contract for which `_who` receives permission.\n    /// @param _who The address (EOA or contract) owning the permission.\n    /// @param _permissionId The permission identifier.\n    /// @return The permission hash.\n    function permissionHash(\n        address _where,\n        address _who,\n        bytes32 _permissionId\n    ) internal pure virtual returns (bytes32) {\n        return keccak256(abi.encodePacked(\"PERMISSION\", _who, _where, _permissionId));\n    }\n\n    /// @notice Decides if the granting permissionId is restricted when `_who == ANY_ADDR` or `_where == ANY_ADDR`.\n    /// @param _permissionId The permission identifier.\n    /// @return Whether or not the permission is restricted.\n    /// @dev By default, every permission is unrestricted and it is the derived contract's responsibility to override it. Note, that the `ROOT_PERMISSION_ID` is included and not required to be set it again.\n    function isPermissionRestrictedForAnyAddr(\n        bytes32 _permissionId\n    ) internal view virtual returns (bool) {\n        (_permissionId); // silence the warning.\n        return false;\n    }\n\n    /// @notice This empty reserved space is put in place to allow future versions to add new variables without shifting down storage in the inheritance chain (see [OpenZeppelin's guide about storage gaps](https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps)).\n    uint256[49] private __gap;\n}\n"
    },
    "@aragon/osx/core/plugin/dao-authorizable/DaoAuthorizableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.8;\n\nimport {ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\n\nimport {IDAO} from \"../../dao/IDAO.sol\";\nimport {_auth} from \"../../utils/auth.sol\";\n\n/// @title DaoAuthorizableUpgradeable\n/// @author Aragon Association - 2022-2023\n/// @notice An abstract contract providing a meta-transaction compatible modifier for upgradeable or cloneable contracts to authorize function calls through an associated DAO.\n/// @dev Make sure to call `__DaoAuthorizableUpgradeable_init` during initialization of the inheriting contract.\nabstract contract DaoAuthorizableUpgradeable is ContextUpgradeable {\n    /// @notice The associated DAO managing the permissions of inheriting contracts.\n    IDAO private dao_;\n\n    /// @notice Initializes the contract by setting the associated DAO.\n    /// @param _dao The associated DAO address.\n    function __DaoAuthorizableUpgradeable_init(IDAO _dao) internal onlyInitializing {\n        dao_ = _dao;\n    }\n\n    /// @notice Returns the DAO contract.\n    /// @return The DAO contract.\n    function dao() public view returns (IDAO) {\n        return dao_;\n    }\n\n    /// @notice A modifier to make functions on inheriting contracts authorized. Permissions to call the function are checked through the associated DAO's permission manager.\n    /// @param _permissionId The permission identifier required to call the method this modifier is applied to.\n    modifier auth(bytes32 _permissionId) {\n        _auth(dao_, address(this), _msgSender(), _permissionId, _msgData());\n        _;\n    }\n\n    /// @notice This empty reserved space is put in place to allow future versions to add new variables without shifting down storage in the inheritance chain (see [OpenZeppelin's guide about storage gaps](https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps)).\n    uint256[49] private __gap;\n}\n"
    },
    "@aragon/osx/core/plugin/IPlugin.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.8;\n\n/// @title IPlugin\n/// @author Aragon Association - 2022-2023\n/// @notice An interface defining the traits of a plugin.\ninterface IPlugin {\n    enum PluginType {\n        UUPS,\n        Cloneable,\n        Constructable\n    }\n\n    /// @notice Returns the plugin's type\n    function pluginType() external view returns (PluginType);\n}\n"
    },
    "@aragon/osx/core/plugin/membership/IMembership.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.8;\n\n/// @title IMembership\n/// @author Aragon Association - 2022-2023\n/// @notice An interface to be implemented by DAO plugins that define membership.\ninterface IMembership {\n    /// @notice Emitted when members are added to the DAO plugin.\n    /// @param members The list of new members being added.\n    event MembersAdded(address[] members);\n\n    /// @notice Emitted when members are removed from the DAO plugin.\n    /// @param members The list of existing members being removed.\n    event MembersRemoved(address[] members);\n\n    /// @notice Emitted to announce the membership being defined by a contract.\n    /// @param definingContract The contract defining the membership.\n    event MembershipContractAnnounced(address indexed definingContract);\n\n    /// @notice Checks if an account is a member of the DAO.\n    /// @param _account The address of the account to be checked.\n    /// @return Whether the account is a member or not.\n    /// @dev This function must be implemented in the plugin contract that introduces the members to the DAO.\n    function isMember(address _account) external view returns (bool);\n}\n"
    },
    "@aragon/osx/core/plugin/PluginUUPSUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.8;\n\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport {IERC1822ProxiableUpgradeable} from \"@openzeppelin/contracts-upgradeable/interfaces/draft-IERC1822Upgradeable.sol\";\nimport {ERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\n\nimport {IDAO} from \"../dao/IDAO.sol\";\nimport {DaoAuthorizableUpgradeable} from \"./dao-authorizable/DaoAuthorizableUpgradeable.sol\";\nimport {IPlugin} from \"./IPlugin.sol\";\n\n/// @title PluginUUPSUpgradeable\n/// @author Aragon Association - 2022-2023\n/// @notice An abstract, upgradeable contract to inherit from when creating a plugin being deployed via the UUPS pattern (see [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822)).\nabstract contract PluginUUPSUpgradeable is\n    IPlugin,\n    ERC165Upgradeable,\n    UUPSUpgradeable,\n    DaoAuthorizableUpgradeable\n{\n    // NOTE: When adding new state variables to the contract, the size of `_gap` has to be adapted below as well.\n\n    /// @notice Disables the initializers on the implementation contract to prevent it from being left uninitialized.\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @inheritdoc IPlugin\n    function pluginType() public pure override returns (PluginType) {\n        return PluginType.UUPS;\n    }\n\n    /// @notice The ID of the permission required to call the `_authorizeUpgrade` function.\n    bytes32 public constant UPGRADE_PLUGIN_PERMISSION_ID = keccak256(\"UPGRADE_PLUGIN_PERMISSION\");\n\n    /// @notice Initializes the plugin by storing the associated DAO.\n    /// @param _dao The DAO contract.\n    function __PluginUUPSUpgradeable_init(IDAO _dao) internal virtual onlyInitializing {\n        __DaoAuthorizableUpgradeable_init(_dao);\n    }\n\n    /// @notice Checks if an interface is supported by this or its parent contract.\n    /// @param _interfaceId The ID of the interface.\n    /// @return Returns `true` if the interface is supported.\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\n        return\n            _interfaceId == type(IPlugin).interfaceId ||\n            _interfaceId == type(IERC1822ProxiableUpgradeable).interfaceId ||\n            super.supportsInterface(_interfaceId);\n    }\n\n    /// @notice Returns the address of the implementation contract in the [proxy storage slot](https://eips.ethereum.org/EIPS/eip-1967) slot the [UUPS proxy](https://eips.ethereum.org/EIPS/eip-1822) is pointing to.\n    /// @return The address of the implementation contract.\n    function implementation() public view returns (address) {\n        return _getImplementation();\n    }\n\n    /// @notice Internal method authorizing the upgrade of the contract via the [upgradeability mechanism for UUPS proxies](https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable) (see [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822)).\n    /// @dev The caller must have the `UPGRADE_PLUGIN_PERMISSION_ID` permission.\n    function _authorizeUpgrade(\n        address\n    ) internal virtual override auth(UPGRADE_PLUGIN_PERMISSION_ID) {}\n\n    /// @notice This empty reserved space is put in place to allow future versions to add new variables without shifting down storage in the inheritance chain (see [OpenZeppelin's guide about storage gaps](https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps)).\n    uint256[50] private __gap;\n}\n"
    },
    "@aragon/osx/core/plugin/proposal/IProposal.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.8;\n\nimport {IDAO} from \"../../dao/IDAO.sol\";\n\n/// @title IProposal\n/// @author Aragon Association - 2022-2023\n/// @notice An interface to be implemented by DAO plugins that create and execute proposals.\ninterface IProposal {\n    /// @notice Emitted when a proposal is created.\n    /// @param proposalId The ID of the proposal.\n    /// @param creator  The creator of the proposal.\n    /// @param startDate The start date of the proposal in seconds.\n    /// @param endDate The end date of the proposal in seconds.\n    /// @param metadata The metadata of the proposal.\n    /// @param actions The actions that will be executed if the proposal passes.\n    /// @param allowFailureMap A bitmap allowing the proposal to succeed, even if individual actions might revert. If the bit at index `i` is 1, the proposal succeeds even if the `i`th action reverts. A failure map value of 0 requires every action to not revert.\n    event ProposalCreated(\n        uint256 indexed proposalId,\n        address indexed creator,\n        uint64 startDate,\n        uint64 endDate,\n        bytes metadata,\n        IDAO.Action[] actions,\n        uint256 allowFailureMap\n    );\n\n    /// @notice Emitted when a proposal is executed.\n    /// @param proposalId The ID of the proposal.\n    event ProposalExecuted(uint256 indexed proposalId);\n\n    /// @notice Returns the proposal count determining the next proposal ID.\n    /// @return The proposal count.\n    function proposalCount() external view returns (uint256);\n}\n"
    },
    "@aragon/osx/core/plugin/proposal/ProposalUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.8;\n\nimport {CountersUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol\";\nimport {ERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\n\nimport \"./IProposal.sol\";\n\n/// @title ProposalUpgradeable\n/// @author Aragon Association - 2022-2023\n/// @notice An abstract contract containing the traits and internal functionality to create and execute proposals that can be inherited by upgradeable DAO plugins.\nabstract contract ProposalUpgradeable is IProposal, ERC165Upgradeable {\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n\n    /// @notice The incremental ID for proposals and executions.\n    CountersUpgradeable.Counter private proposalCounter;\n\n    /// @inheritdoc IProposal\n    function proposalCount() public view override returns (uint256) {\n        return proposalCounter.current();\n    }\n\n    /// @notice Checks if this or the parent contract supports an interface by its ID.\n    /// @param _interfaceId The ID of the interface.\n    /// @return Returns `true` if the interface is supported.\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\n        return _interfaceId == type(IProposal).interfaceId || super.supportsInterface(_interfaceId);\n    }\n\n    /// @notice Creates a proposal ID.\n    /// @return proposalId The proposal ID.\n    function _createProposalId() internal returns (uint256 proposalId) {\n        proposalId = proposalCount();\n        proposalCounter.increment();\n    }\n\n    /// @notice Internal function to create a proposal.\n    /// @param _metadata The proposal metadata.\n    /// @param _startDate The start date of the proposal in seconds.\n    /// @param _endDate The end date of the proposal in seconds.\n    /// @param _allowFailureMap A bitmap allowing the proposal to succeed, even if individual actions might revert. If the bit at index `i` is 1, the proposal succeeds even if the `i`th action reverts. A failure map value of 0 requires every action to not revert.\n    /// @param _actions The actions that will be executed after the proposal passes.\n    /// @return proposalId The ID of the proposal.\n    function _createProposal(\n        address _creator,\n        bytes calldata _metadata,\n        uint64 _startDate,\n        uint64 _endDate,\n        IDAO.Action[] calldata _actions,\n        uint256 _allowFailureMap\n    ) internal virtual returns (uint256 proposalId) {\n        proposalId = _createProposalId();\n\n        emit ProposalCreated({\n            proposalId: proposalId,\n            creator: _creator,\n            metadata: _metadata,\n            startDate: _startDate,\n            endDate: _endDate,\n            actions: _actions,\n            allowFailureMap: _allowFailureMap\n        });\n    }\n\n    /// @notice Internal function to execute a proposal.\n    /// @param _proposalId The ID of the proposal to be executed.\n    /// @param _actions The array of actions to be executed.\n    /// @param _allowFailureMap A bitmap allowing the proposal to succeed, even if individual actions might revert. If the bit at index `i` is 1, the proposal succeeds even if the `i`th action reverts. A failure map value of 0 requires every action to not revert.\n    /// @return execResults The array with the results of the executed actions.\n    /// @return failureMap The failure map encoding which actions have failed.\n    function _executeProposal(\n        IDAO _dao,\n        uint256 _proposalId,\n        IDAO.Action[] memory _actions,\n        uint256 _allowFailureMap\n    ) internal virtual returns (bytes[] memory execResults, uint256 failureMap) {\n        (execResults, failureMap) = _dao.execute(bytes32(_proposalId), _actions, _allowFailureMap);\n        emit ProposalExecuted({proposalId: _proposalId});\n    }\n\n    /// @notice This empty reserved space is put in place to allow future versions to add new variables without shifting down storage in the inheritance chain (see [OpenZeppelin's guide about storage gaps](https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps)).\n    uint256[49] private __gap;\n}\n"
    },
    "@aragon/osx/core/utils/auth.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.8;\n\nimport {IDAO} from \"../dao/IDAO.sol\";\n\n/// @notice Thrown if a call is unauthorized in the associated DAO.\n/// @param dao The associated DAO.\n/// @param where The context in which the authorization reverted.\n/// @param who The address (EOA or contract) missing the permission.\n/// @param permissionId The permission identifier.\nerror DaoUnauthorized(address dao, address where, address who, bytes32 permissionId);\n\n/// @notice A free function checking if a caller is granted permissions on a target contract via a permission identifier that redirects the approval to a `PermissionCondition` if this was specified in the setup.\n/// @param _where The address of the target contract for which `who` receives permission.\n/// @param _who The address (EOA or contract) owning the permission.\n/// @param _permissionId The permission identifier.\n/// @param _data The optional data passed to the `PermissionCondition` registered.\nfunction _auth(\n    IDAO _dao,\n    address _where,\n    address _who,\n    bytes32 _permissionId,\n    bytes calldata _data\n) view {\n    if (!_dao.hasPermission(_where, _who, _permissionId, _data))\n        revert DaoUnauthorized({\n            dao: address(_dao),\n            where: _where,\n            who: _who,\n            permissionId: _permissionId\n        });\n}\n"
    },
    "@aragon/osx/framework/plugin/setup/IPluginSetup.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.8;\n\nimport {PermissionLib} from \"../../../core/permission/PermissionLib.sol\";\nimport {IDAO} from \"../../../core/dao/IDAO.sol\";\n\n/// @title IPluginSetup\n/// @author Aragon Association - 2022-2023\n/// @notice The interface required for a plugin setup contract to be consumed by the `PluginSetupProcessor` for plugin installations, updates, and uninstallations.\ninterface IPluginSetup {\n    /// @notice The data associated with a prepared setup.\n    /// @param helpers The address array of helpers (contracts or EOAs) associated with this plugin version after the installation or update.\n    /// @param permissions The array of multi-targeted permission operations to be applied by the `PluginSetupProcessor` to the installing or updating DAO.\n    struct PreparedSetupData {\n        address[] helpers;\n        PermissionLib.MultiTargetPermission[] permissions;\n    }\n\n    /// @notice The payload for plugin updates and uninstallations containing the existing contracts as well as optional data to be consumed by the plugin setup.\n    /// @param plugin The address of the `Plugin`.\n    /// @param currentHelpers The address array of all current helpers (contracts or EOAs) associated with the plugin to update from.\n    /// @param data The bytes-encoded data containing the input parameters for the preparation of update/uninstall as specified in the corresponding ABI on the version's metadata.\n    struct SetupPayload {\n        address plugin;\n        address[] currentHelpers;\n        bytes data;\n    }\n\n    /// @notice Prepares the installation of a plugin.\n    /// @param _dao The address of the installing DAO.\n    /// @param _data The bytes-encoded data containing the input parameters for the installation as specified in the plugin's build metadata JSON file.\n    /// @return plugin The address of the `Plugin` contract being prepared for installation.\n    /// @return preparedSetupData The deployed plugin's relevant data which consists of helpers and permissions.\n    function prepareInstallation(\n        address _dao,\n        bytes calldata _data\n    ) external returns (address plugin, PreparedSetupData memory preparedSetupData);\n\n    /// @notice Prepares the update of a plugin.\n    /// @param _dao The address of the updating DAO.\n    /// @param _currentBuild The build number of the plugin to update from.\n    /// @param _payload The relevant data necessary for the `prepareUpdate`. See above.\n    /// @return initData The initialization data to be passed to upgradeable contracts when the update is applied in the `PluginSetupProcessor`.\n    /// @return preparedSetupData The deployed plugin's relevant data which consists of helpers and permissions.\n    function prepareUpdate(\n        address _dao,\n        uint16 _currentBuild,\n        SetupPayload calldata _payload\n    ) external returns (bytes memory initData, PreparedSetupData memory preparedSetupData);\n\n    /// @notice Prepares the uninstallation of a plugin.\n    /// @param _dao The address of the uninstalling DAO.\n    /// @param _payload The relevant data necessary for the `prepareUninstallation`. See above.\n    /// @return permissions The array of multi-targeted permission operations to be applied by the `PluginSetupProcessor` to the uninstalling DAO.\n    function prepareUninstallation(\n        address _dao,\n        SetupPayload calldata _payload\n    ) external returns (PermissionLib.MultiTargetPermission[] memory permissions);\n\n    /// @notice Returns the plugin implementation address.\n    /// @return The address of the plugin implementation contract.\n    /// @dev The implementation can be instantiated via the `new` keyword, cloned via the minimal clones pattern (see [ERC-1167](https://eips.ethereum.org/EIPS/eip-1167)), or proxied via the UUPS pattern (see [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822)).\n    function implementation() external view returns (address);\n}\n"
    },
    "@aragon/osx/framework/plugin/setup/PluginSetup.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.8;\n\nimport {ERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {ERC165Checker} from \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\nimport {Clones} from \"@openzeppelin/contracts/proxy/Clones.sol\";\n\nimport {PermissionLib} from \"../../../core/permission/PermissionLib.sol\";\nimport {createERC1967Proxy as createERC1967} from \"../../../utils/Proxy.sol\";\nimport {IPluginSetup} from \"./IPluginSetup.sol\";\n\n/// @title PluginSetup\n/// @author Aragon Association - 2022-2023\n/// @notice An abstract contract that developers have to inherit from to write the setup of a plugin.\nabstract contract PluginSetup is ERC165, IPluginSetup {\n    /// @inheritdoc IPluginSetup\n    function prepareUpdate(\n        address _dao,\n        uint16 _currentBuild,\n        SetupPayload calldata _payload\n    )\n        external\n        virtual\n        override\n        returns (bytes memory initData, PreparedSetupData memory preparedSetupData)\n    {}\n\n    /// @notice A convenience function to create an [ERC-1967](https://eips.ethereum.org/EIPS/eip-1967) proxy contract pointing to an implementation and being associated to a DAO.\n    /// @param _implementation The address of the implementation contract to which the proxy is pointing to.\n    /// @param _data The data to initialize the storage of the proxy contract.\n    /// @return The address of the created proxy contract.\n    function createERC1967Proxy(\n        address _implementation,\n        bytes memory _data\n    ) internal returns (address) {\n        return createERC1967(_implementation, _data);\n    }\n\n    /// @notice Checks if this or the parent contract supports an interface by its ID.\n    /// @param _interfaceId The ID of the interface.\n    /// @return Returns `true` if the interface is supported.\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\n        return\n            _interfaceId == type(IPluginSetup).interfaceId || super.supportsInterface(_interfaceId);\n    }\n}\n"
    },
    "@aragon/osx/plugins/governance/majority-voting/IMajorityVoting.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.8;\n\nimport {IDAO} from \"../../../core/dao/IDAO.sol\";\n\n/// @title IMajorityVoting\n/// @author Aragon Association - 2022-2023\n/// @notice The interface of majority voting plugin.\ninterface IMajorityVoting {\n    /// @notice Vote options that a voter can chose from.\n    /// @param None The default option state of a voter indicating the absence from the vote. This option neither influences support nor participation.\n    /// @param Abstain This option does not influence the support but counts towards participation.\n    /// @param Yes This option increases the support and counts towards participation.\n    /// @param No This option decreases the support and counts towards participation.\n    enum VoteOption {\n        None,\n        Abstain,\n        Yes,\n        No\n    }\n\n    /// @notice Emitted when a vote is cast by a voter.\n    /// @param proposalId The ID of the proposal.\n    /// @param voter The voter casting the vote.\n    /// @param voteOption The casted vote option.\n    /// @param votingPower The voting power behind this vote.\n    event VoteCast(\n        uint256 indexed proposalId,\n        address indexed voter,\n        VoteOption voteOption,\n        uint256 votingPower\n    );\n\n    /// @notice Returns the support threshold parameter stored in the voting settings.\n    /// @return The support threshold parameter.\n    function supportThreshold() external view returns (uint32);\n\n    /// @notice Returns the minimum participation parameter stored in the voting settings.\n    /// @return The minimum participation parameter.\n    function minParticipation() external view returns (uint32);\n\n    /// @notice Checks if the support value defined as $$\\texttt{support} = \\frac{N_\\text{yes}}{N_\\text{yes}+N_\\text{no}}$$ for a proposal vote is greater than the support threshold.\n    /// @param _proposalId The ID of the proposal.\n    /// @return Returns `true` if the  support is greater than the support threshold and `false` otherwise.\n    function isSupportThresholdReached(uint256 _proposalId) external view returns (bool);\n\n    /// @notice Checks if the worst-case support value defined as $$\\texttt{worstCaseSupport} = \\frac{N_\\text{yes}}{ N_\\text{total}-N_\\text{abstain}}$$ for a proposal vote is greater than the support threshold.\n    /// @param _proposalId The ID of the proposal.\n    /// @return Returns `true` if the worst-case support is greater than the support threshold and `false` otherwise.\n    function isSupportThresholdReachedEarly(uint256 _proposalId) external view returns (bool);\n\n    /// @notice Checks if the participation value defined as $$\\texttt{participation} = \\frac{N_\\text{yes}+N_\\text{no}+N_\\text{abstain}}{N_\\text{total}}$$ for a proposal vote is greater or equal than the minimum participation value.\n    /// @param _proposalId The ID of the proposal.\n    /// @return Returns `true` if the participation is greater than the minimum participation and `false` otherwise.\n    function isMinParticipationReached(uint256 _proposalId) external view returns (bool);\n\n    /// @notice Checks if an account can participate on a proposal vote. This can be because the vote\n    /// - has not started,\n    /// - has ended,\n    /// - was executed, or\n    /// - the voter doesn't have voting powers.\n    /// @param _proposalId The proposal Id.\n    /// @param _account The account address to be checked.\n    /// @param  _voteOption Whether the voter abstains, supports or opposes the proposal.\n    /// @return Returns true if the account is allowed to vote.\n    /// @dev The function assumes the queried proposal exists.\n    function canVote(\n        uint256 _proposalId,\n        address _account,\n        VoteOption _voteOption\n    ) external view returns (bool);\n\n    /// @notice Checks if a proposal can be executed.\n    /// @param _proposalId The ID of the proposal to be checked.\n    /// @return True if the proposal can be executed, false otherwise.\n    function canExecute(uint256 _proposalId) external view returns (bool);\n\n    /// @notice Votes for a vote option and, optionally, executes the proposal.\n    /// @dev `_voteOption`, 1 -> abstain, 2 -> yes, 3 -> no\n    /// @param _proposalId The ID of the proposal.\n    /// @param _voteOption The chosen vote option.\n    /// @param _tryEarlyExecution If `true`,  early execution is tried after the vote cast. The call does not revert if early execution is not possible.\n    function vote(uint256 _proposalId, VoteOption _voteOption, bool _tryEarlyExecution) external;\n\n    /// @notice Executes a proposal.\n    /// @param _proposalId The ID of the proposal to be executed.\n    function execute(uint256 _proposalId) external;\n\n    /// @notice Returns whether the account has voted for the proposal.  Note, that this does not check if the account has voting power.\n    /// @param _proposalId The ID of the proposal.\n    /// @param _account The account address to be checked.\n    /// @return The vote option cast by a voter for a certain proposal.\n    function getVoteOption(\n        uint256 _proposalId,\n        address _account\n    ) external view returns (VoteOption);\n}\n"
    },
    "@aragon/osx/plugins/governance/majority-voting/MajorityVotingBase.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.8;\n\nimport {ERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {SafeCastUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\n\nimport {IProposal} from \"../../../core/plugin/proposal/IProposal.sol\";\nimport {ProposalUpgradeable} from \"../../../core/plugin/proposal/ProposalUpgradeable.sol\";\nimport {PluginUUPSUpgradeable} from \"../../../core/plugin/PluginUUPSUpgradeable.sol\";\nimport {IDAO} from \"../../../core/dao/IDAO.sol\";\nimport {RATIO_BASE, RatioOutOfBounds} from \"../../utils/Ratio.sol\";\nimport {IMajorityVoting} from \"./IMajorityVoting.sol\";\n\n/// @title MajorityVotingBase\n/// @author Aragon Association - 2022-2023\n/// @notice The abstract implementation of majority voting plugins.\n///\n/// ### Parameterization\n///\n/// We define two parameters\n/// $$\\texttt{support} = \\frac{N_\\text{yes}}{N_\\text{yes} + N_\\text{no}} \\in [0,1]$$\n/// and\n/// $$\\texttt{participation} = \\frac{N_\\text{yes} + N_\\text{no} + N_\\text{abstain}}{N_\\text{total}} \\in [0,1],$$\n/// where $N_\\text{yes}$, $N_\\text{no}$, and $N_\\text{abstain}$ are the yes, no, and abstain votes that have been cast and $N_\\text{total}$ is the total voting power available at proposal creation time.\n///\n/// #### Limit Values: Support Threshold & Minimum Participation\n///\n/// Two limit values are associated with these parameters and decide if a proposal execution should be possible: $\\texttt{supportThreshold} \\in [0,1]$ and $\\texttt{minParticipation} \\in [0,1]$.\n///\n/// For threshold values, $>$ comparison is used. This **does not** include the threshold value. E.g., for $\\texttt{supportThreshold} = 50\\%$, the criterion is fulfilled if there is at least one more yes than no votes ($N_\\text{yes} = N_\\text{no} + 1$).\n/// For minimum values, $\\ge{}$ comparison is used. This **does** include the minimum participation value. E.g., for $\\texttt{minParticipation} = 40\\%$ and $N_\\text{total} = 10$, the criterion is fulfilled if 4 out of 10 votes were casted.\n///\n/// Majority voting implies that the support threshold is set with\n/// $$\\texttt{supportThreshold} \\ge 50\\% .$$\n/// However, this is not enforced by the contract code and developers can make unsafe parameters and only the frontend will warn about bad parameter settings.\n///\n/// ### Execution Criteria\n///\n/// After the vote is closed, two criteria decide if the proposal passes.\n///\n/// #### The Support Criterion\n///\n/// For a proposal to pass, the required ratio of yes and no votes must be met:\n/// $$(1- \\texttt{supportThreshold}) \\cdot N_\\text{yes} > \\texttt{supportThreshold} \\cdot N_\\text{no}.$$\n/// Note, that the inequality yields the simple majority voting condition for $\\texttt{supportThreshold}=\\frac{1}{2}$.\n///\n/// #### The Participation Criterion\n///\n/// For a proposal to pass, the minimum voting power must have been cast:\n/// $$N_\\text{yes} + N_\\text{no} + N_\\text{abstain} \\ge \\texttt{minVotingPower},$$\n/// where $\\texttt{minVotingPower} = \\texttt{minParticipation} \\cdot N_\\text{total}$.\n///\n/// ### Vote Replacement Execution\n///\n/// The contract allows votes to be replaced. Voters can vote multiple times and only the latest voteOption is tallied.\n///\n/// ### Early Execution\n///\n/// This contract allows a proposal to be executed early, iff the vote outcome cannot change anymore by more people voting. Accordingly, vote replacement and early execution are /// mutually exclusive options.\n/// The outcome cannot change anymore iff the support threshold is met even if all remaining votes are no votes. We call this number the worst-case number of no votes and define it as\n///\n/// $$N_\\text{no, worst-case} = N_\\text{no, worst-case} + \\texttt{remainingVotes}$$\n///\n/// where\n///\n/// $$\\texttt{remainingVotes} = N_\\text{total}-\\underbrace{(N_\\text{yes}+N_\\text{no}+N_\\text{abstain})}_{\\text{turnout}}.$$\n///\n/// We can use this quantity to calculate the worst-case support that would be obtained if all remaining votes are casted with no:\n///\n/// $$\n/// \\begin{align*}\n///   \\texttt{worstCaseSupport}\n///   &= \\frac{N_\\text{yes}}{N_\\text{yes} + (N_\\text{no, worst-case})} \\\\[3mm]\n///   &= \\frac{N_\\text{yes}}{N_\\text{yes} + (N_\\text{no} + \\texttt{remainingVotes})} \\\\[3mm]\n///   &= \\frac{N_\\text{yes}}{N_\\text{yes} +  N_\\text{no} + N_\\text{total} - (N_\\text{yes} + N_\\text{no} + N_\\text{abstain})} \\\\[3mm]\n///   &= \\frac{N_\\text{yes}}{N_\\text{total} - N_\\text{abstain}}\n/// \\end{align*}\n/// $$\n///\n/// In analogy, we can modify [the support criterion](#the-support-criterion) from above to allow for early execution:\n///\n/// $$\n/// \\begin{align*}\n///   (1 - \\texttt{supportThreshold}) \\cdot N_\\text{yes}\n///   &> \\texttt{supportThreshold} \\cdot  N_\\text{no, worst-case} \\\\[3mm]\n///   &> \\texttt{supportThreshold} \\cdot (N_\\text{no} + \\texttt{remainingVotes}) \\\\[3mm]\n///   &> \\texttt{supportThreshold} \\cdot (N_\\text{no} + N_\\text{total}-(N_\\text{yes}+N_\\text{no}+N_\\text{abstain})) \\\\[3mm]\n///   &> \\texttt{supportThreshold} \\cdot (N_\\text{total} - N_\\text{yes} - N_\\text{abstain})\n/// \\end{align*}\n/// $$\n///\n/// Accordingly, early execution is possible when the vote is open, the modified support criterion, and the particicpation criterion are met.\n/// @dev This contract implements the `IMajorityVoting` interface.\nabstract contract MajorityVotingBase is\n    IMajorityVoting,\n    Initializable,\n    ERC165Upgradeable,\n    PluginUUPSUpgradeable,\n    ProposalUpgradeable\n{\n    using SafeCastUpgradeable for uint256;\n\n    /// @notice The different voting modes available.\n    /// @param Standard In standard mode, early execution and vote replacement are disabled.\n    /// @param EarlyExecution In early execution mode, a proposal can be executed early before the end date if the vote outcome cannot mathematically change by more voters voting.\n    /// @param VoteReplacement In vote replacement mode, voters can change their vote multiple times and only the latest vote option is tallied.\n    enum VotingMode {\n        Standard,\n        EarlyExecution,\n        VoteReplacement\n    }\n\n    /// @notice A container for the majority voting settings that will be applied as parameters on proposal creation.\n    /// @param votingMode A parameter to select the vote mode. In standard mode (0), early execution and vote replacement are disabled. In early execution mode (1), a proposal can be executed early before the end date if the vote outcome cannot mathematically change by more voters voting. In vote replacement mode (2), voters can change their vote multiple times and only the latest vote option is tallied.\n    /// @param supportThreshold The support threshold value. Its value has to be in the interval [0, 10^6] defined by `RATIO_BASE = 10**6`.\n    /// @param minParticipation The minimum participation value. Its value has to be in the interval [0, 10^6] defined by `RATIO_BASE = 10**6`.\n    /// @param minDuration The minimum duration of the proposal vote in seconds.\n    /// @param minProposerVotingPower The minimum voting power required to create a proposal.\n    struct VotingSettings {\n        VotingMode votingMode;\n        uint32 supportThreshold;\n        uint32 minParticipation;\n        uint64 minDuration;\n        uint256 minProposerVotingPower;\n    }\n\n    /// @notice A container for proposal-related information.\n    /// @param executed Whether the proposal is executed or not.\n    /// @param parameters The proposal parameters at the time of the proposal creation.\n    /// @param tally The vote tally of the proposal.\n    /// @param voters The votes casted by the voters.\n    /// @param actions The actions to be executed when the proposal passes.\n    /// @param allowFailureMap A bitmap allowing the proposal to succeed, even if individual actions might revert. If the bit at index `i` is 1, the proposal succeeds even if the `i`th action reverts. A failure map value of 0 requires every action to not revert.\n    struct Proposal {\n        bool executed;\n        ProposalParameters parameters;\n        Tally tally;\n        mapping(address => IMajorityVoting.VoteOption) voters;\n        IDAO.Action[] actions;\n        uint256 allowFailureMap;\n    }\n\n    /// @notice A container for the proposal parameters at the time of proposal creation.\n    /// @param votingMode A parameter to select the vote mode.\n    /// @param supportThreshold The support threshold value. The value has to be in the interval [0, 10^6] defined by `RATIO_BASE = 10**6`.\n    /// @param startDate The start date of the proposal vote.\n    /// @param endDate The end date of the proposal vote.\n    /// @param snapshotBlock The number of the block prior to the proposal creation.\n    /// @param minVotingPower The minimum voting power needed.\n    struct ProposalParameters {\n        VotingMode votingMode;\n        uint32 supportThreshold;\n        uint64 startDate;\n        uint64 endDate;\n        uint64 snapshotBlock;\n        uint256 minVotingPower;\n    }\n\n    /// @notice A container for the proposal vote tally.\n    /// @param abstain The number of abstain votes casted.\n    /// @param yes The number of yes votes casted.\n    /// @param no The number of no votes casted.\n    struct Tally {\n        uint256 abstain;\n        uint256 yes;\n        uint256 no;\n    }\n\n    /// @notice The [ERC-165](https://eips.ethereum.org/EIPS/eip-165) interface ID of the contract.\n    bytes4 internal constant MAJORITY_VOTING_BASE_INTERFACE_ID =\n        this.minDuration.selector ^\n            this.minProposerVotingPower.selector ^\n            this.votingMode.selector ^\n            this.totalVotingPower.selector ^\n            this.getProposal.selector ^\n            this.updateVotingSettings.selector ^\n            this.createProposal.selector;\n\n    /// @notice The ID of the permission required to call the `updateVotingSettings` function.\n    bytes32 public constant UPDATE_VOTING_SETTINGS_PERMISSION_ID =\n        keccak256(\"UPDATE_VOTING_SETTINGS_PERMISSION\");\n\n    /// @notice A mapping between proposal IDs and proposal information.\n    mapping(uint256 => Proposal) internal proposals;\n\n    /// @notice The struct storing the voting settings.\n    VotingSettings private votingSettings;\n\n    /// @notice Thrown if a date is out of bounds.\n    /// @param limit The limit value.\n    /// @param actual The actual value.\n    error DateOutOfBounds(uint64 limit, uint64 actual);\n\n    /// @notice Thrown if the minimal duration value is out of bounds (less than one hour or greater than 1 year).\n    /// @param limit The limit value.\n    /// @param actual The actual value.\n    error MinDurationOutOfBounds(uint64 limit, uint64 actual);\n\n    /// @notice Thrown when a sender is not allowed to create a proposal.\n    /// @param sender The sender address.\n    error ProposalCreationForbidden(address sender);\n\n    /// @notice Thrown if an account is not allowed to cast a vote. This can be because the vote\n    /// - has not started,\n    /// - has ended,\n    /// - was executed, or\n    /// - the account doesn't have voting powers.\n    /// @param proposalId The ID of the proposal.\n    /// @param account The address of the _account.\n    /// @param voteOption The chosen vote option.\n    error VoteCastForbidden(uint256 proposalId, address account, VoteOption voteOption);\n\n    /// @notice Thrown if the proposal execution is forbidden.\n    /// @param proposalId The ID of the proposal.\n    error ProposalExecutionForbidden(uint256 proposalId);\n\n    /// @notice Emitted when the voting settings are updated.\n    /// @param votingMode A parameter to select the vote mode.\n    /// @param supportThreshold The support threshold value.\n    /// @param minParticipation The minimum participation value.\n    /// @param minDuration The minimum duration of the proposal vote in seconds.\n    /// @param minProposerVotingPower The minimum voting power required to create a proposal.\n    event VotingSettingsUpdated(\n        VotingMode votingMode,\n        uint32 supportThreshold,\n        uint32 minParticipation,\n        uint64 minDuration,\n        uint256 minProposerVotingPower\n    );\n\n    /// @notice Initializes the component to be used by inheriting contracts.\n    /// @dev This method is required to support [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822).\n    /// @param _dao The IDAO interface of the associated DAO.\n    /// @param _votingSettings The voting settings.\n    function __MajorityVotingBase_init(\n        IDAO _dao,\n        VotingSettings calldata _votingSettings\n    ) internal onlyInitializing {\n        __PluginUUPSUpgradeable_init(_dao);\n        _updateVotingSettings(_votingSettings);\n    }\n\n    /// @notice Checks if this or the parent contract supports an interface by its ID.\n    /// @param _interfaceId The ID of the interface.\n    /// @return Returns `true` if the interface is supported.\n    function supportsInterface(\n        bytes4 _interfaceId\n    )\n        public\n        view\n        virtual\n        override(ERC165Upgradeable, PluginUUPSUpgradeable, ProposalUpgradeable)\n        returns (bool)\n    {\n        return\n            _interfaceId == MAJORITY_VOTING_BASE_INTERFACE_ID ||\n            _interfaceId == type(IMajorityVoting).interfaceId ||\n            super.supportsInterface(_interfaceId);\n    }\n\n    /// @inheritdoc IMajorityVoting\n    function vote(\n        uint256 _proposalId,\n        VoteOption _voteOption,\n        bool _tryEarlyExecution\n    ) public virtual {\n        address account = _msgSender();\n\n        if (!_canVote(_proposalId, account, _voteOption)) {\n            revert VoteCastForbidden({\n                proposalId: _proposalId,\n                account: account,\n                voteOption: _voteOption\n            });\n        }\n        _vote(_proposalId, _voteOption, account, _tryEarlyExecution);\n    }\n\n    /// @inheritdoc IMajorityVoting\n    function execute(uint256 _proposalId) public virtual {\n        if (!_canExecute(_proposalId)) {\n            revert ProposalExecutionForbidden(_proposalId);\n        }\n        _execute(_proposalId);\n    }\n\n    /// @inheritdoc IMajorityVoting\n    function getVoteOption(\n        uint256 _proposalId,\n        address _voter\n    ) public view virtual returns (VoteOption) {\n        return proposals[_proposalId].voters[_voter];\n    }\n\n    /// @inheritdoc IMajorityVoting\n    function canVote(\n        uint256 _proposalId,\n        address _voter,\n        VoteOption _voteOption\n    ) public view virtual returns (bool) {\n        return _canVote(_proposalId, _voter, _voteOption);\n    }\n\n    /// @inheritdoc IMajorityVoting\n    function canExecute(uint256 _proposalId) public view virtual returns (bool) {\n        return _canExecute(_proposalId);\n    }\n\n    /// @inheritdoc IMajorityVoting\n    function isSupportThresholdReached(uint256 _proposalId) public view virtual returns (bool) {\n        Proposal storage proposal_ = proposals[_proposalId];\n\n        // The code below implements the formula of the support criterion explained in the top of this file.\n        // `(1 - supportThreshold) * N_yes > supportThreshold *  N_no`\n        return\n            (RATIO_BASE - proposal_.parameters.supportThreshold) * proposal_.tally.yes >\n            proposal_.parameters.supportThreshold * proposal_.tally.no;\n    }\n\n    /// @inheritdoc IMajorityVoting\n    function isSupportThresholdReachedEarly(\n        uint256 _proposalId\n    ) public view virtual returns (bool) {\n        Proposal storage proposal_ = proposals[_proposalId];\n\n        uint256 noVotesWorstCase = totalVotingPower(proposal_.parameters.snapshotBlock) -\n            proposal_.tally.yes -\n            proposal_.tally.abstain;\n\n        // The code below implements the formula of the early execution support criterion explained in the top of this file.\n        // `(1 - supportThreshold) * N_yes > supportThreshold *  N_no,worst-case`\n        return\n            (RATIO_BASE - proposal_.parameters.supportThreshold) * proposal_.tally.yes >\n            proposal_.parameters.supportThreshold * noVotesWorstCase;\n    }\n\n    /// @inheritdoc IMajorityVoting\n    function isMinParticipationReached(uint256 _proposalId) public view virtual returns (bool) {\n        Proposal storage proposal_ = proposals[_proposalId];\n\n        // The code below implements the formula of the participation criterion explained in the top of this file.\n        // `N_yes + N_no + N_abstain >= minVotingPower = minParticipation * N_total`\n        return\n            proposal_.tally.yes + proposal_.tally.no + proposal_.tally.abstain >=\n            proposal_.parameters.minVotingPower;\n    }\n\n    /// @inheritdoc IMajorityVoting\n    function supportThreshold() public view virtual returns (uint32) {\n        return votingSettings.supportThreshold;\n    }\n\n    /// @inheritdoc IMajorityVoting\n    function minParticipation() public view virtual returns (uint32) {\n        return votingSettings.minParticipation;\n    }\n\n    /// @notice Returns the minimum duration parameter stored in the voting settings.\n    /// @return The minimum duration parameter.\n    function minDuration() public view virtual returns (uint64) {\n        return votingSettings.minDuration;\n    }\n\n    /// @notice Returns the minimum voting power required to create a proposal stored in the voting settings.\n    /// @return The minimum voting power required to create a proposal.\n    function minProposerVotingPower() public view virtual returns (uint256) {\n        return votingSettings.minProposerVotingPower;\n    }\n\n    /// @notice Returns the vote mode stored in the voting settings.\n    /// @return The vote mode parameter.\n    function votingMode() public view virtual returns (VotingMode) {\n        return votingSettings.votingMode;\n    }\n\n    /// @notice Returns the total voting power checkpointed for a specific block number.\n    /// @param _blockNumber The block number.\n    /// @return The total voting power.\n    function totalVotingPower(uint256 _blockNumber) public view virtual returns (uint256);\n\n    /// @notice Returns all information for a proposal vote by its ID.\n    /// @param _proposalId The ID of the proposal.\n    /// @return open Whether the proposal is open or not.\n    /// @return executed Whether the proposal is executed or not.\n    /// @return parameters The parameters of the proposal vote.\n    /// @return tally The current tally of the proposal vote.\n    /// @return actions The actions to be executed in the associated DAO after the proposal has passed.\n    /// @return allowFailureMap The bit map representations of which actions are allowed to revert so tx still succeeds.\n    function getProposal(\n        uint256 _proposalId\n    )\n        public\n        view\n        virtual\n        returns (\n            bool open,\n            bool executed,\n            ProposalParameters memory parameters,\n            Tally memory tally,\n            IDAO.Action[] memory actions,\n            uint256 allowFailureMap\n        )\n    {\n        Proposal storage proposal_ = proposals[_proposalId];\n\n        open = _isProposalOpen(proposal_);\n        executed = proposal_.executed;\n        parameters = proposal_.parameters;\n        tally = proposal_.tally;\n        actions = proposal_.actions;\n        allowFailureMap = proposal_.allowFailureMap;\n    }\n\n    /// @notice Updates the voting settings.\n    /// @param _votingSettings The new voting settings.\n    function updateVotingSettings(\n        VotingSettings calldata _votingSettings\n    ) external virtual auth(UPDATE_VOTING_SETTINGS_PERMISSION_ID) {\n        _updateVotingSettings(_votingSettings);\n    }\n\n    /// @notice Creates a new majority voting proposal.\n    /// @param _metadata The metadata of the proposal.\n    /// @param _actions The actions that will be executed after the proposal passes.\n    /// @param _allowFailureMap Allows proposal to succeed even if an action reverts. Uses bitmap representation. If the bit at index `x` is 1, the tx succeeds even if the action at `x` failed. Passing 0 will be treated as atomic execution.\n    /// @param _startDate The start date of the proposal vote. If 0, the current timestamp is used and the vote starts immediately.\n    /// @param _endDate The end date of the proposal vote. If 0, `_startDate + minDuration` is used.\n    /// @param _voteOption The chosen vote option to be casted on proposal creation.\n    /// @param _tryEarlyExecution If `true`,  early execution is tried after the vote cast. The call does not revert if early execution is not possible.\n    /// @return proposalId The ID of the proposal.\n    function createProposal(\n        bytes calldata _metadata,\n        IDAO.Action[] calldata _actions,\n        uint256 _allowFailureMap,\n        uint64 _startDate,\n        uint64 _endDate,\n        VoteOption _voteOption,\n        bool _tryEarlyExecution\n    ) external virtual returns (uint256 proposalId);\n\n    /// @notice Internal function to cast a vote. It assumes the queried vote exists.\n    /// @param _proposalId The ID of the proposal.\n    /// @param _voteOption The chosen vote option to be casted on the proposal vote.\n    /// @param _tryEarlyExecution If `true`,  early execution is tried after the vote cast. The call does not revert if early execution is not possible.\n    function _vote(\n        uint256 _proposalId,\n        VoteOption _voteOption,\n        address _voter,\n        bool _tryEarlyExecution\n    ) internal virtual;\n\n    /// @notice Internal function to execute a vote. It assumes the queried proposal exists.\n    /// @param _proposalId The ID of the proposal.\n    function _execute(uint256 _proposalId) internal virtual {\n        proposals[_proposalId].executed = true;\n\n        _executeProposal(\n            dao(),\n            _proposalId,\n            proposals[_proposalId].actions,\n            proposals[_proposalId].allowFailureMap\n        );\n    }\n\n    /// @notice Internal function to check if a voter can vote. It assumes the queried proposal exists.\n    /// @param _proposalId The ID of the proposal.\n    /// @param _voter The address of the voter to check.\n    /// @param  _voteOption Whether the voter abstains, supports or opposes the proposal.\n    /// @return Returns `true` if the given voter can vote on a certain proposal and `false` otherwise.\n    function _canVote(\n        uint256 _proposalId,\n        address _voter,\n        VoteOption _voteOption\n    ) internal view virtual returns (bool);\n\n    /// @notice Internal function to check if a proposal can be executed. It assumes the queried proposal exists.\n    /// @param _proposalId The ID of the proposal.\n    /// @return True if the proposal can be executed, false otherwise.\n    /// @dev Threshold and minimal values are compared with `>` and `>=` comparators, respectively.\n    function _canExecute(uint256 _proposalId) internal view virtual returns (bool) {\n        Proposal storage proposal_ = proposals[_proposalId];\n\n        // Verify that the vote has not been executed already.\n        if (proposal_.executed) {\n            return false;\n        }\n\n        if (_isProposalOpen(proposal_)) {\n            // Early execution\n            if (proposal_.parameters.votingMode != VotingMode.EarlyExecution) {\n                return false;\n            }\n            if (!isSupportThresholdReachedEarly(_proposalId)) {\n                return false;\n            }\n        } else {\n            // Normal execution\n            if (!isSupportThresholdReached(_proposalId)) {\n                return false;\n            }\n        }\n        if (!isMinParticipationReached(_proposalId)) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /// @notice Internal function to check if a proposal vote is still open.\n    /// @param proposal_ The proposal struct.\n    /// @return True if the proposal vote is open, false otherwise.\n    function _isProposalOpen(Proposal storage proposal_) internal view virtual returns (bool) {\n        uint64 currentTime = block.timestamp.toUint64();\n\n        return\n            proposal_.parameters.startDate <= currentTime &&\n            currentTime < proposal_.parameters.endDate &&\n            !proposal_.executed;\n    }\n\n    /// @notice Internal function to update the plugin-wide proposal vote settings.\n    /// @param _votingSettings The voting settings to be validated and updated.\n    function _updateVotingSettings(VotingSettings calldata _votingSettings) internal virtual {\n        // Require the support threshold value to be in the interval [0, 10^6-1], because `>` comparision is used in the support criterion and >100% could never be reached.\n        if (_votingSettings.supportThreshold > RATIO_BASE - 1) {\n            revert RatioOutOfBounds({\n                limit: RATIO_BASE - 1,\n                actual: _votingSettings.supportThreshold\n            });\n        }\n\n        // Require the minimum participation value to be in the interval [0, 10^6], because `>=` comparision is used in the participation criterion.\n        if (_votingSettings.minParticipation > RATIO_BASE) {\n            revert RatioOutOfBounds({limit: RATIO_BASE, actual: _votingSettings.minParticipation});\n        }\n\n        if (_votingSettings.minDuration < 60 minutes) {\n            revert MinDurationOutOfBounds({limit: 60 minutes, actual: _votingSettings.minDuration});\n        }\n\n        if (_votingSettings.minDuration > 365 days) {\n            revert MinDurationOutOfBounds({limit: 365 days, actual: _votingSettings.minDuration});\n        }\n\n        votingSettings = _votingSettings;\n\n        emit VotingSettingsUpdated({\n            votingMode: _votingSettings.votingMode,\n            supportThreshold: _votingSettings.supportThreshold,\n            minParticipation: _votingSettings.minParticipation,\n            minDuration: _votingSettings.minDuration,\n            minProposerVotingPower: _votingSettings.minProposerVotingPower\n        });\n    }\n\n    /// @notice Validates and returns the proposal vote dates.\n    /// @param _start The start date of the proposal vote. If 0, the current timestamp is used and the vote starts immediately.\n    /// @param _end The end date of the proposal vote. If 0, `_start + minDuration` is used.\n    /// @return startDate The validated start date of the proposal vote.\n    /// @return endDate The validated end date of the proposal vote.\n    function _validateProposalDates(\n        uint64 _start,\n        uint64 _end\n    ) internal view virtual returns (uint64 startDate, uint64 endDate) {\n        uint64 currentTimestamp = block.timestamp.toUint64();\n\n        if (_start == 0) {\n            startDate = currentTimestamp;\n        } else {\n            startDate = _start;\n\n            if (startDate < currentTimestamp) {\n                revert DateOutOfBounds({limit: currentTimestamp, actual: startDate});\n            }\n        }\n\n        uint64 earliestEndDate = startDate + votingSettings.minDuration; // Since `minDuration` is limited to 1 year, `startDate + minDuration` can only overflow if the `startDate` is after `type(uint64).max - minDuration`. In this case, the proposal creation will revert and another date can be picked.\n\n        if (_end == 0) {\n            endDate = earliestEndDate;\n        } else {\n            endDate = _end;\n\n            if (endDate < earliestEndDate) {\n                revert DateOutOfBounds({limit: earliestEndDate, actual: endDate});\n            }\n        }\n    }\n\n    /// @notice This empty reserved space is put in place to allow future versions to add new variables without shifting down storage in the inheritance chain (see [OpenZeppelin's guide about storage gaps](https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps)).\n    uint256[47] private __gap;\n}\n"
    },
    "@aragon/osx/plugins/utils/Ratio.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.8;\n\n// The base value to encode real-valued ratios on the interval `[0,1]` as integers on the interval `[0, 10**6]`.\nuint256 constant RATIO_BASE = 10 ** 6;\n\n/// @notice Thrown if a ratio value exceeds the maximal value of `10**6`.\n/// @param limit The maximal value.\n/// @param actual The actual value.\nerror RatioOutOfBounds(uint256 limit, uint256 actual);\n\n/// @notice Applies a ratio to a value and ceils the remainder.\n/// @param _value The value to which the ratio is applied.\n/// @param _ratio The ratio that must be in the interval `[0, 10**6]`.\n/// @return result The resulting value.\nfunction _applyRatioCeiled(uint256 _value, uint256 _ratio) pure returns (uint256 result) {\n    if (_ratio > RATIO_BASE) {\n        revert RatioOutOfBounds({limit: RATIO_BASE, actual: _ratio});\n    }\n\n    _value = _value * _ratio;\n    uint256 remainder = _value % RATIO_BASE;\n    result = _value / RATIO_BASE;\n\n    // Check if ceiling is needed\n    if (remainder != 0) {\n        ++result;\n    }\n}\n"
    },
    "@aragon/osx/utils/protocol/IProtocolVersion.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.8;\n\n/// @title IProtocolVersion\n/// @author Aragon Association - 2022-2023\n/// @notice An interface defining the semantic OSx protocol version.\ninterface IProtocolVersion {\n    /// @notice Returns the protocol version at which the current contract was built. Use it to check for future upgrades that might be applicable.\n    /// @return _version Returns the semantic OSx protocol version.\n    function protocolVersion() external view returns (uint8[3] memory _version);\n}\n"
    },
    "@aragon/osx/utils/Proxy.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.8;\n\nimport \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\";\n\n/// @notice Free function to create a [ERC-1967](https://eips.ethereum.org/EIPS/eip-1967) proxy contract based on the passed base contract address.\n/// @param _logic The base contract address.\n/// @param _data The constructor arguments for this contract.\n/// @return The address of the proxy contract created.\n/// @dev Initializes the upgradeable proxy with an initial implementation specified by _logic. If _data is non-empty, it’s used as data in a delegate call to _logic. This will typically be an encoded function call, and allows initializing the storage of the proxy like a Solidity constructor (see [OpenZeppelin ERC1967Proxy-constructor](https://docs.openzeppelin.com/contracts/4.x/api/proxy#ERC1967Proxy-constructor-address-bytes-)).\nfunction createERC1967Proxy(address _logic, bytes memory _data) returns (address) {\n    return address(new ERC1967Proxy(_logic, _data));\n}\n"
    },
    "@aragon/osx/utils/UncheckedMath.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.8;\n\n/// @notice Increments an unsigned integer by one without checking the result for overflow errors (using safe math).\n/// @param i The number to be incremented.\n/// @return The number incremented by one.\nfunction _uncheckedIncrement(uint256 i) pure returns (uint256) {\n    unchecked {\n        ++i;\n    }\n    return i;\n}\n\n/// @notice Adds two unsigned integers without checking the result for overflow errors (using safe math).\n/// @param a The first summand.\n/// @param b The second summand.\n/// @return The sum.\nfunction _uncheckedAdd(uint256 a, uint256 b) pure returns (uint256) {\n    unchecked {\n        return a + b;\n    }\n}\n\n/// @notice Subtracts two unsigned integers without checking the result for overflow errors (using safe math).\n/// @param a The minuend.\n/// @param b The subtrahend.\n/// @return The difference.\nfunction _uncheckedSub(uint256 a, uint256 b) pure returns (uint256) {\n    unchecked {\n        return a - b;\n    }\n}\n"
    },
    "@ensdomains/buffer/contracts/Buffer.sol": {
      "content": "// SPDX-License-Identifier: BSD-2-Clause\npragma solidity ^0.8.4;\n\n/**\n* @dev A library for working with mutable byte buffers in Solidity.\n*\n* Byte buffers are mutable and expandable, and provide a variety of primitives\n* for appending to them. At any time you can fetch a bytes object containing the\n* current contents of the buffer. The bytes object should not be stored between\n* operations, as it may change due to resizing of the buffer.\n*/\nlibrary Buffer {\n    /**\n    * @dev Represents a mutable buffer. Buffers have a current value (buf) and\n    *      a capacity. The capacity may be longer than the current value, in\n    *      which case it can be extended without the need to allocate more memory.\n    */\n    struct buffer {\n        bytes buf;\n        uint capacity;\n    }\n\n    /**\n    * @dev Initializes a buffer with an initial capacity.\n    * @param buf The buffer to initialize.\n    * @param capacity The number of bytes of space to allocate the buffer.\n    * @return The buffer, for chaining.\n    */\n    function init(buffer memory buf, uint capacity) internal pure returns(buffer memory) {\n        if (capacity % 32 != 0) {\n            capacity += 32 - (capacity % 32);\n        }\n        // Allocate space for the buffer data\n        buf.capacity = capacity;\n        assembly {\n            let ptr := mload(0x40)\n            mstore(buf, ptr)\n            mstore(ptr, 0)\n            let fpm := add(32, add(ptr, capacity))\n            if lt(fpm, ptr) {\n                revert(0, 0)\n            }\n            mstore(0x40, fpm)\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Initializes a new buffer from an existing bytes object.\n    *      Changes to the buffer may mutate the original value.\n    * @param b The bytes object to initialize the buffer with.\n    * @return A new buffer.\n    */\n    function fromBytes(bytes memory b) internal pure returns(buffer memory) {\n        buffer memory buf;\n        buf.buf = b;\n        buf.capacity = b.length;\n        return buf;\n    }\n\n    function resize(buffer memory buf, uint capacity) private pure {\n        bytes memory oldbuf = buf.buf;\n        init(buf, capacity);\n        append(buf, oldbuf);\n    }\n\n    /**\n    * @dev Sets buffer length to 0.\n    * @param buf The buffer to truncate.\n    * @return The original buffer, for chaining..\n    */\n    function truncate(buffer memory buf) internal pure returns (buffer memory) {\n        assembly {\n            let bufptr := mload(buf)\n            mstore(bufptr, 0)\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Appends len bytes of a byte string to a buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @param len The number of bytes to copy.\n    * @return The original buffer, for chaining.\n    */\n    function append(buffer memory buf, bytes memory data, uint len) internal pure returns(buffer memory) {\n        require(len <= data.length);\n\n        uint off = buf.buf.length;\n        uint newCapacity = off + len;\n        if (newCapacity > buf.capacity) {\n            resize(buf, newCapacity * 2);\n        }\n\n        uint dest;\n        uint src;\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Length of existing buffer data\n            let buflen := mload(bufptr)\n            // Start address = buffer address + offset + sizeof(buffer length)\n            dest := add(add(bufptr, 32), off)\n            // Update buffer length if we're extending it\n            if gt(newCapacity, buflen) {\n                mstore(bufptr, newCapacity)\n            }\n            src := add(data, 32)\n        }\n\n        // Copy word-length chunks while possible\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        unchecked {\n            uint mask = (256 ** (32 - len)) - 1;\n            assembly {\n                let srcpart := and(mload(src), not(mask))\n                let destpart := and(mload(dest), mask)\n                mstore(dest, or(destpart, srcpart))\n            }\n        }\n\n        return buf;\n    }\n\n    /**\n    * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\n        return append(buf, data, data.length);\n    }\n\n    /**\n    * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\n    *      capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function appendUint8(buffer memory buf, uint8 data) internal pure returns(buffer memory) {\n        uint off = buf.buf.length;\n        uint offPlusOne = off + 1;\n        if (off >= buf.capacity) {\n            resize(buf, offPlusOne * 2);\n        }\n\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Address = buffer address + sizeof(buffer length) + off\n            let dest := add(add(bufptr, off), 32)\n            mstore8(dest, data)\n            // Update buffer length if we extended it\n            if gt(offPlusOne, mload(bufptr)) {\n                mstore(bufptr, offPlusOne)\n            }\n        }\n\n        return buf;\n    }\n\n    /**\n    * @dev Appends len bytes of bytes32 to a buffer. Resizes if doing so would\n    *      exceed the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @param len The number of bytes to write (left-aligned).\n    * @return The original buffer, for chaining.\n    */\n    function append(buffer memory buf, bytes32 data, uint len) private pure returns(buffer memory) {\n        uint off = buf.buf.length;\n        uint newCapacity = len + off;\n        if (newCapacity > buf.capacity) {\n            resize(buf, newCapacity * 2);\n        }\n\n        unchecked {\n            uint mask = (256 ** len) - 1;\n            // Right-align data\n            data = data >> (8 * (32 - len));\n            assembly {\n                // Memory address of the buffer data\n                let bufptr := mload(buf)\n                // Address = buffer address + sizeof(buffer length) + newCapacity\n                let dest := add(bufptr, newCapacity)\n                mstore(dest, or(and(mload(dest), not(mask)), data))\n                // Update buffer length if we extended it\n                if gt(newCapacity, mload(bufptr)) {\n                    mstore(bufptr, newCapacity)\n                }\n            }\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chhaining.\n    */\n    function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\n        return append(buf, bytes32(data), 20);\n    }\n\n    /**\n    * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\n        return append(buf, data, 32);\n    }\n\n    /**\n     * @dev Appends a byte to the end of the buffer. Resizes if doing so would\n     *      exceed the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param data The data to append.\n     * @param len The number of bytes to write (right-aligned).\n     * @return The original buffer.\n     */\n    function appendInt(buffer memory buf, uint data, uint len) internal pure returns(buffer memory) {\n        uint off = buf.buf.length;\n        uint newCapacity = len + off;\n        if (newCapacity > buf.capacity) {\n            resize(buf, newCapacity * 2);\n        }\n\n        uint mask = (256 ** len) - 1;\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Address = buffer address + sizeof(buffer length) + newCapacity\n            let dest := add(bufptr, newCapacity)\n            mstore(dest, or(and(mload(dest), not(mask)), data))\n            // Update buffer length if we extended it\n            if gt(newCapacity, mload(bufptr)) {\n                mstore(bufptr, newCapacity)\n            }\n        }\n        return buf;\n    }\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/dnssec-oracle/BytesUtils.sol": {
      "content": "pragma solidity ^0.8.4;\n\nlibrary BytesUtils {\n    error OffsetOutOfBoundsError(uint256 offset, uint256 length);\n\n    /*\n     * @dev Returns the keccak-256 hash of a byte range.\n     * @param self The byte string to hash.\n     * @param offset The position to start hashing at.\n     * @param len The number of bytes to hash.\n     * @return The hash of the byte range.\n     */\n    function keccak(\n        bytes memory self,\n        uint256 offset,\n        uint256 len\n    ) internal pure returns (bytes32 ret) {\n        require(offset + len <= self.length);\n        assembly {\n            ret := keccak256(add(add(self, 32), offset), len)\n        }\n    }\n\n    /*\n     * @dev Returns a positive number if `other` comes lexicographically after\n     *      `self`, a negative number if it comes before, or zero if the\n     *      contents of the two bytes are equal.\n     * @param self The first bytes to compare.\n     * @param other The second bytes to compare.\n     * @return The result of the comparison.\n     */\n    function compare(\n        bytes memory self,\n        bytes memory other\n    ) internal pure returns (int256) {\n        return compare(self, 0, self.length, other, 0, other.length);\n    }\n\n    /*\n     * @dev Returns a positive number if `other` comes lexicographically after\n     *      `self`, a negative number if it comes before, or zero if the\n     *      contents of the two bytes are equal. Comparison is done per-rune,\n     *      on unicode codepoints.\n     * @param self The first bytes to compare.\n     * @param offset The offset of self.\n     * @param len    The length of self.\n     * @param other The second bytes to compare.\n     * @param otheroffset The offset of the other string.\n     * @param otherlen    The length of the other string.\n     * @return The result of the comparison.\n     */\n    function compare(\n        bytes memory self,\n        uint256 offset,\n        uint256 len,\n        bytes memory other,\n        uint256 otheroffset,\n        uint256 otherlen\n    ) internal pure returns (int256) {\n        if (offset + len > self.length) {\n            revert OffsetOutOfBoundsError(offset + len, self.length);\n        }\n        if (otheroffset + otherlen > other.length) {\n            revert OffsetOutOfBoundsError(otheroffset + otherlen, other.length);\n        }\n\n        uint256 shortest = len;\n        if (otherlen < len) shortest = otherlen;\n\n        uint256 selfptr;\n        uint256 otherptr;\n\n        assembly {\n            selfptr := add(self, add(offset, 32))\n            otherptr := add(other, add(otheroffset, 32))\n        }\n        for (uint256 idx = 0; idx < shortest; idx += 32) {\n            uint256 a;\n            uint256 b;\n            assembly {\n                a := mload(selfptr)\n                b := mload(otherptr)\n            }\n            if (a != b) {\n                // Mask out irrelevant bytes and check again\n                uint256 mask;\n                if (shortest - idx >= 32) {\n                    mask = type(uint256).max;\n                } else {\n                    mask = ~(2 ** (8 * (idx + 32 - shortest)) - 1);\n                }\n                int256 diff = int256(a & mask) - int256(b & mask);\n                if (diff != 0) return diff;\n            }\n            selfptr += 32;\n            otherptr += 32;\n        }\n\n        return int256(len) - int256(otherlen);\n    }\n\n    /*\n     * @dev Returns true if the two byte ranges are equal.\n     * @param self The first byte range to compare.\n     * @param offset The offset into the first byte range.\n     * @param other The second byte range to compare.\n     * @param otherOffset The offset into the second byte range.\n     * @param len The number of bytes to compare\n     * @return True if the byte ranges are equal, false otherwise.\n     */\n    function equals(\n        bytes memory self,\n        uint256 offset,\n        bytes memory other,\n        uint256 otherOffset,\n        uint256 len\n    ) internal pure returns (bool) {\n        return keccak(self, offset, len) == keccak(other, otherOffset, len);\n    }\n\n    /*\n     * @dev Returns true if the two byte ranges are equal with offsets.\n     * @param self The first byte range to compare.\n     * @param offset The offset into the first byte range.\n     * @param other The second byte range to compare.\n     * @param otherOffset The offset into the second byte range.\n     * @return True if the byte ranges are equal, false otherwise.\n     */\n    function equals(\n        bytes memory self,\n        uint256 offset,\n        bytes memory other,\n        uint256 otherOffset\n    ) internal pure returns (bool) {\n        return\n            keccak(self, offset, self.length - offset) ==\n            keccak(other, otherOffset, other.length - otherOffset);\n    }\n\n    /*\n     * @dev Compares a range of 'self' to all of 'other' and returns True iff\n     *      they are equal.\n     * @param self The first byte range to compare.\n     * @param offset The offset into the first byte range.\n     * @param other The second byte range to compare.\n     * @return True if the byte ranges are equal, false otherwise.\n     */\n    function equals(\n        bytes memory self,\n        uint256 offset,\n        bytes memory other\n    ) internal pure returns (bool) {\n        return\n            self.length == offset + other.length &&\n            equals(self, offset, other, 0, other.length);\n    }\n\n    /*\n     * @dev Returns true if the two byte ranges are equal.\n     * @param self The first byte range to compare.\n     * @param other The second byte range to compare.\n     * @return True if the byte ranges are equal, false otherwise.\n     */\n    function equals(\n        bytes memory self,\n        bytes memory other\n    ) internal pure returns (bool) {\n        return\n            self.length == other.length &&\n            equals(self, 0, other, 0, self.length);\n    }\n\n    /*\n     * @dev Returns the 8-bit number at the specified index of self.\n     * @param self The byte string.\n     * @param idx The index into the bytes\n     * @return The specified 8 bits of the string, interpreted as an integer.\n     */\n    function readUint8(\n        bytes memory self,\n        uint256 idx\n    ) internal pure returns (uint8 ret) {\n        return uint8(self[idx]);\n    }\n\n    /*\n     * @dev Returns the 16-bit number at the specified index of self.\n     * @param self The byte string.\n     * @param idx The index into the bytes\n     * @return The specified 16 bits of the string, interpreted as an integer.\n     */\n    function readUint16(\n        bytes memory self,\n        uint256 idx\n    ) internal pure returns (uint16 ret) {\n        require(idx + 2 <= self.length);\n        assembly {\n            ret := and(mload(add(add(self, 2), idx)), 0xFFFF)\n        }\n    }\n\n    /*\n     * @dev Returns the 32-bit number at the specified index of self.\n     * @param self The byte string.\n     * @param idx The index into the bytes\n     * @return The specified 32 bits of the string, interpreted as an integer.\n     */\n    function readUint32(\n        bytes memory self,\n        uint256 idx\n    ) internal pure returns (uint32 ret) {\n        require(idx + 4 <= self.length);\n        assembly {\n            ret := and(mload(add(add(self, 4), idx)), 0xFFFFFFFF)\n        }\n    }\n\n    /*\n     * @dev Returns the 32 byte value at the specified index of self.\n     * @param self The byte string.\n     * @param idx The index into the bytes\n     * @return The specified 32 bytes of the string.\n     */\n    function readBytes32(\n        bytes memory self,\n        uint256 idx\n    ) internal pure returns (bytes32 ret) {\n        require(idx + 32 <= self.length);\n        assembly {\n            ret := mload(add(add(self, 32), idx))\n        }\n    }\n\n    /*\n     * @dev Returns the 32 byte value at the specified index of self.\n     * @param self The byte string.\n     * @param idx The index into the bytes\n     * @return The specified 32 bytes of the string.\n     */\n    function readBytes20(\n        bytes memory self,\n        uint256 idx\n    ) internal pure returns (bytes20 ret) {\n        require(idx + 20 <= self.length);\n        assembly {\n            ret := and(\n                mload(add(add(self, 32), idx)),\n                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000\n            )\n        }\n    }\n\n    /*\n     * @dev Returns the n byte value at the specified index of self.\n     * @param self The byte string.\n     * @param idx The index into the bytes.\n     * @param len The number of bytes.\n     * @return The specified 32 bytes of the string.\n     */\n    function readBytesN(\n        bytes memory self,\n        uint256 idx,\n        uint256 len\n    ) internal pure returns (bytes32 ret) {\n        require(len <= 32);\n        require(idx + len <= self.length);\n        assembly {\n            let mask := not(sub(exp(256, sub(32, len)), 1))\n            ret := and(mload(add(add(self, 32), idx)), mask)\n        }\n    }\n\n    function memcpy(uint256 dest, uint256 src, uint256 len) private pure {\n        // Copy word-length chunks while possible\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        unchecked {\n            uint256 mask = (256 ** (32 - len)) - 1;\n            assembly {\n                let srcpart := and(mload(src), not(mask))\n                let destpart := and(mload(dest), mask)\n                mstore(dest, or(destpart, srcpart))\n            }\n        }\n    }\n\n    /*\n     * @dev Copies a substring into a new byte string.\n     * @param self The byte string to copy from.\n     * @param offset The offset to start copying at.\n     * @param len The number of bytes to copy.\n     */\n    function substring(\n        bytes memory self,\n        uint256 offset,\n        uint256 len\n    ) internal pure returns (bytes memory) {\n        require(offset + len <= self.length);\n\n        bytes memory ret = new bytes(len);\n        uint256 dest;\n        uint256 src;\n\n        assembly {\n            dest := add(ret, 32)\n            src := add(add(self, 32), offset)\n        }\n        memcpy(dest, src, len);\n\n        return ret;\n    }\n\n    // Maps characters from 0x30 to 0x7A to their base32 values.\n    // 0xFF represents invalid characters in that range.\n    bytes constant base32HexTable =\n        hex\"00010203040506070809FFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1FFFFFFFFFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1F\";\n\n    /**\n     * @dev Decodes unpadded base32 data of up to one word in length.\n     * @param self The data to decode.\n     * @param off Offset into the string to start at.\n     * @param len Number of characters to decode.\n     * @return The decoded data, left aligned.\n     */\n    function base32HexDecodeWord(\n        bytes memory self,\n        uint256 off,\n        uint256 len\n    ) internal pure returns (bytes32) {\n        require(len <= 52);\n\n        uint256 ret = 0;\n        uint8 decoded;\n        for (uint256 i = 0; i < len; i++) {\n            bytes1 char = self[off + i];\n            require(char >= 0x30 && char <= 0x7A);\n            decoded = uint8(base32HexTable[uint256(uint8(char)) - 0x30]);\n            require(decoded <= 0x20);\n            if (i == len - 1) {\n                break;\n            }\n            ret = (ret << 5) | decoded;\n        }\n\n        uint256 bitlen = len * 5;\n        if (len % 8 == 0) {\n            // Multiple of 8 characters, no padding\n            ret = (ret << 5) | decoded;\n        } else if (len % 8 == 2) {\n            // Two extra characters - 1 byte\n            ret = (ret << 3) | (decoded >> 2);\n            bitlen -= 2;\n        } else if (len % 8 == 4) {\n            // Four extra characters - 2 bytes\n            ret = (ret << 1) | (decoded >> 4);\n            bitlen -= 4;\n        } else if (len % 8 == 5) {\n            // Five extra characters - 3 bytes\n            ret = (ret << 4) | (decoded >> 1);\n            bitlen -= 1;\n        } else if (len % 8 == 7) {\n            // Seven extra characters - 4 bytes\n            ret = (ret << 2) | (decoded >> 3);\n            bitlen -= 3;\n        } else {\n            revert();\n        }\n\n        return bytes32(ret << (256 - bitlen));\n    }\n\n    /**\n     * @dev Finds the first occurrence of the byte `needle` in `self`.\n     * @param self The string to search\n     * @param off The offset to start searching at\n     * @param len The number of bytes to search\n     * @param needle The byte to search for\n     * @return The offset of `needle` in `self`, or 2**256-1 if it was not found.\n     */\n    function find(\n        bytes memory self,\n        uint256 off,\n        uint256 len,\n        bytes1 needle\n    ) internal pure returns (uint256) {\n        for (uint256 idx = off; idx < off + len; idx++) {\n            if (self[idx] == needle) {\n                return idx;\n            }\n        }\n        return type(uint256).max;\n    }\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/dnssec-oracle/RRUtils.sol": {
      "content": "pragma solidity ^0.8.4;\n\nimport \"./BytesUtils.sol\";\nimport \"@ensdomains/buffer/contracts/Buffer.sol\";\n\n/**\n * @dev RRUtils is a library that provides utilities for parsing DNS resource records.\n */\nlibrary RRUtils {\n    using BytesUtils for *;\n    using Buffer for *;\n\n    /**\n     * @dev Returns the number of bytes in the DNS name at 'offset' in 'self'.\n     * @param self The byte array to read a name from.\n     * @param offset The offset to start reading at.\n     * @return The length of the DNS name at 'offset', in bytes.\n     */\n    function nameLength(\n        bytes memory self,\n        uint256 offset\n    ) internal pure returns (uint256) {\n        uint256 idx = offset;\n        while (true) {\n            assert(idx < self.length);\n            uint256 labelLen = self.readUint8(idx);\n            idx += labelLen + 1;\n            if (labelLen == 0) {\n                break;\n            }\n        }\n        return idx - offset;\n    }\n\n    /**\n     * @dev Returns a DNS format name at the specified offset of self.\n     * @param self The byte array to read a name from.\n     * @param offset The offset to start reading at.\n     * @return ret The name.\n     */\n    function readName(\n        bytes memory self,\n        uint256 offset\n    ) internal pure returns (bytes memory ret) {\n        uint256 len = nameLength(self, offset);\n        return self.substring(offset, len);\n    }\n\n    /**\n     * @dev Returns the number of labels in the DNS name at 'offset' in 'self'.\n     * @param self The byte array to read a name from.\n     * @param offset The offset to start reading at.\n     * @return The number of labels in the DNS name at 'offset', in bytes.\n     */\n    function labelCount(\n        bytes memory self,\n        uint256 offset\n    ) internal pure returns (uint256) {\n        uint256 count = 0;\n        while (true) {\n            assert(offset < self.length);\n            uint256 labelLen = self.readUint8(offset);\n            offset += labelLen + 1;\n            if (labelLen == 0) {\n                break;\n            }\n            count += 1;\n        }\n        return count;\n    }\n\n    uint256 constant RRSIG_TYPE = 0;\n    uint256 constant RRSIG_ALGORITHM = 2;\n    uint256 constant RRSIG_LABELS = 3;\n    uint256 constant RRSIG_TTL = 4;\n    uint256 constant RRSIG_EXPIRATION = 8;\n    uint256 constant RRSIG_INCEPTION = 12;\n    uint256 constant RRSIG_KEY_TAG = 16;\n    uint256 constant RRSIG_SIGNER_NAME = 18;\n\n    struct SignedSet {\n        uint16 typeCovered;\n        uint8 algorithm;\n        uint8 labels;\n        uint32 ttl;\n        uint32 expiration;\n        uint32 inception;\n        uint16 keytag;\n        bytes signerName;\n        bytes data;\n        bytes name;\n    }\n\n    function readSignedSet(\n        bytes memory data\n    ) internal pure returns (SignedSet memory self) {\n        self.typeCovered = data.readUint16(RRSIG_TYPE);\n        self.algorithm = data.readUint8(RRSIG_ALGORITHM);\n        self.labels = data.readUint8(RRSIG_LABELS);\n        self.ttl = data.readUint32(RRSIG_TTL);\n        self.expiration = data.readUint32(RRSIG_EXPIRATION);\n        self.inception = data.readUint32(RRSIG_INCEPTION);\n        self.keytag = data.readUint16(RRSIG_KEY_TAG);\n        self.signerName = readName(data, RRSIG_SIGNER_NAME);\n        self.data = data.substring(\n            RRSIG_SIGNER_NAME + self.signerName.length,\n            data.length - RRSIG_SIGNER_NAME - self.signerName.length\n        );\n    }\n\n    function rrs(\n        SignedSet memory rrset\n    ) internal pure returns (RRIterator memory) {\n        return iterateRRs(rrset.data, 0);\n    }\n\n    /**\n     * @dev An iterator over resource records.\n     */\n    struct RRIterator {\n        bytes data;\n        uint256 offset;\n        uint16 dnstype;\n        uint16 class;\n        uint32 ttl;\n        uint256 rdataOffset;\n        uint256 nextOffset;\n    }\n\n    /**\n     * @dev Begins iterating over resource records.\n     * @param self The byte string to read from.\n     * @param offset The offset to start reading at.\n     * @return ret An iterator object.\n     */\n    function iterateRRs(\n        bytes memory self,\n        uint256 offset\n    ) internal pure returns (RRIterator memory ret) {\n        ret.data = self;\n        ret.nextOffset = offset;\n        next(ret);\n    }\n\n    /**\n     * @dev Returns true iff there are more RRs to iterate.\n     * @param iter The iterator to check.\n     * @return True iff the iterator has finished.\n     */\n    function done(RRIterator memory iter) internal pure returns (bool) {\n        return iter.offset >= iter.data.length;\n    }\n\n    /**\n     * @dev Moves the iterator to the next resource record.\n     * @param iter The iterator to advance.\n     */\n    function next(RRIterator memory iter) internal pure {\n        iter.offset = iter.nextOffset;\n        if (iter.offset >= iter.data.length) {\n            return;\n        }\n\n        // Skip the name\n        uint256 off = iter.offset + nameLength(iter.data, iter.offset);\n\n        // Read type, class, and ttl\n        iter.dnstype = iter.data.readUint16(off);\n        off += 2;\n        iter.class = iter.data.readUint16(off);\n        off += 2;\n        iter.ttl = iter.data.readUint32(off);\n        off += 4;\n\n        // Read the rdata\n        uint256 rdataLength = iter.data.readUint16(off);\n        off += 2;\n        iter.rdataOffset = off;\n        iter.nextOffset = off + rdataLength;\n    }\n\n    /**\n     * @dev Returns the name of the current record.\n     * @param iter The iterator.\n     * @return A new bytes object containing the owner name from the RR.\n     */\n    function name(RRIterator memory iter) internal pure returns (bytes memory) {\n        return\n            iter.data.substring(\n                iter.offset,\n                nameLength(iter.data, iter.offset)\n            );\n    }\n\n    /**\n     * @dev Returns the rdata portion of the current record.\n     * @param iter The iterator.\n     * @return A new bytes object containing the RR's RDATA.\n     */\n    function rdata(\n        RRIterator memory iter\n    ) internal pure returns (bytes memory) {\n        return\n            iter.data.substring(\n                iter.rdataOffset,\n                iter.nextOffset - iter.rdataOffset\n            );\n    }\n\n    uint256 constant DNSKEY_FLAGS = 0;\n    uint256 constant DNSKEY_PROTOCOL = 2;\n    uint256 constant DNSKEY_ALGORITHM = 3;\n    uint256 constant DNSKEY_PUBKEY = 4;\n\n    struct DNSKEY {\n        uint16 flags;\n        uint8 protocol;\n        uint8 algorithm;\n        bytes publicKey;\n    }\n\n    function readDNSKEY(\n        bytes memory data,\n        uint256 offset,\n        uint256 length\n    ) internal pure returns (DNSKEY memory self) {\n        self.flags = data.readUint16(offset + DNSKEY_FLAGS);\n        self.protocol = data.readUint8(offset + DNSKEY_PROTOCOL);\n        self.algorithm = data.readUint8(offset + DNSKEY_ALGORITHM);\n        self.publicKey = data.substring(\n            offset + DNSKEY_PUBKEY,\n            length - DNSKEY_PUBKEY\n        );\n    }\n\n    uint256 constant DS_KEY_TAG = 0;\n    uint256 constant DS_ALGORITHM = 2;\n    uint256 constant DS_DIGEST_TYPE = 3;\n    uint256 constant DS_DIGEST = 4;\n\n    struct DS {\n        uint16 keytag;\n        uint8 algorithm;\n        uint8 digestType;\n        bytes digest;\n    }\n\n    function readDS(\n        bytes memory data,\n        uint256 offset,\n        uint256 length\n    ) internal pure returns (DS memory self) {\n        self.keytag = data.readUint16(offset + DS_KEY_TAG);\n        self.algorithm = data.readUint8(offset + DS_ALGORITHM);\n        self.digestType = data.readUint8(offset + DS_DIGEST_TYPE);\n        self.digest = data.substring(offset + DS_DIGEST, length - DS_DIGEST);\n    }\n\n    function isSubdomainOf(\n        bytes memory self,\n        bytes memory other\n    ) internal pure returns (bool) {\n        uint256 off = 0;\n        uint256 counts = labelCount(self, 0);\n        uint256 othercounts = labelCount(other, 0);\n\n        while (counts > othercounts) {\n            off = progress(self, off);\n            counts--;\n        }\n\n        return self.equals(off, other, 0);\n    }\n\n    function compareNames(\n        bytes memory self,\n        bytes memory other\n    ) internal pure returns (int256) {\n        if (self.equals(other)) {\n            return 0;\n        }\n\n        uint256 off;\n        uint256 otheroff;\n        uint256 prevoff;\n        uint256 otherprevoff;\n        uint256 counts = labelCount(self, 0);\n        uint256 othercounts = labelCount(other, 0);\n\n        // Keep removing labels from the front of the name until both names are equal length\n        while (counts > othercounts) {\n            prevoff = off;\n            off = progress(self, off);\n            counts--;\n        }\n\n        while (othercounts > counts) {\n            otherprevoff = otheroff;\n            otheroff = progress(other, otheroff);\n            othercounts--;\n        }\n\n        // Compare the last nonequal labels to each other\n        while (counts > 0 && !self.equals(off, other, otheroff)) {\n            prevoff = off;\n            off = progress(self, off);\n            otherprevoff = otheroff;\n            otheroff = progress(other, otheroff);\n            counts -= 1;\n        }\n\n        if (off == 0) {\n            return -1;\n        }\n        if (otheroff == 0) {\n            return 1;\n        }\n\n        return\n            self.compare(\n                prevoff + 1,\n                self.readUint8(prevoff),\n                other,\n                otherprevoff + 1,\n                other.readUint8(otherprevoff)\n            );\n    }\n\n    /**\n     * @dev Compares two serial numbers using RFC1982 serial number math.\n     */\n    function serialNumberGte(\n        uint32 i1,\n        uint32 i2\n    ) internal pure returns (bool) {\n        unchecked {\n            return int32(i1) - int32(i2) >= 0;\n        }\n    }\n\n    function progress(\n        bytes memory body,\n        uint256 off\n    ) internal pure returns (uint256) {\n        return off + 1 + body.readUint8(off);\n    }\n\n    /**\n     * @dev Computes the keytag for a chunk of data.\n     * @param data The data to compute a keytag for.\n     * @return The computed key tag.\n     */\n    function computeKeytag(bytes memory data) internal pure returns (uint16) {\n        /* This function probably deserves some explanation.\n         * The DNSSEC keytag function is a checksum that relies on summing up individual bytes\n         * from the input string, with some mild bitshifting. Here's a Naive solidity implementation:\n         *\n         *     function computeKeytag(bytes memory data) internal pure returns (uint16) {\n         *         uint ac;\n         *         for (uint i = 0; i < data.length; i++) {\n         *             ac += i & 1 == 0 ? uint16(data.readUint8(i)) << 8 : data.readUint8(i);\n         *         }\n         *         return uint16(ac + (ac >> 16));\n         *     }\n         *\n         * The EVM, with its 256 bit words, is exceedingly inefficient at doing byte-by-byte operations;\n         * the code above, on reasonable length inputs, consumes over 100k gas. But we can make the EVM's\n         * large words work in our favour.\n         *\n         * The code below works by treating the input as a series of 256 bit words. It first masks out\n         * even and odd bytes from each input word, adding them to two separate accumulators `ac1` and `ac2`.\n         * The bytes are separated by empty bytes, so as long as no individual sum exceeds 2^16-1, we're\n         * effectively summing 16 different numbers with each EVM ADD opcode.\n         *\n         * Once it's added up all the inputs, it has to add all the 16 bit values in `ac1` and `ac2` together.\n         * It does this using the same trick - mask out every other value, shift to align them, add them together.\n         * After the first addition on both accumulators, there's enough room to add the two accumulators together,\n         * and the remaining sums can be done just on ac1.\n         */\n        unchecked {\n            require(data.length <= 8192, \"Long keys not permitted\");\n            uint256 ac1;\n            uint256 ac2;\n            for (uint256 i = 0; i < data.length + 31; i += 32) {\n                uint256 word;\n                assembly {\n                    word := mload(add(add(data, 32), i))\n                }\n                if (i + 32 > data.length) {\n                    uint256 unused = 256 - (data.length - i) * 8;\n                    word = (word >> unused) << unused;\n                }\n                ac1 +=\n                    (word &\n                        0xFF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00) >>\n                    8;\n                ac2 += (word &\n                    0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF);\n            }\n            ac1 =\n                (ac1 &\n                    0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) +\n                ((ac1 &\n                    0xFFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000) >>\n                    16);\n            ac2 =\n                (ac2 &\n                    0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) +\n                ((ac2 &\n                    0xFFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000) >>\n                    16);\n            ac1 = (ac1 << 8) + ac2;\n            ac1 =\n                (ac1 &\n                    0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) +\n                ((ac1 &\n                    0xFFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000) >>\n                    32);\n            ac1 =\n                (ac1 &\n                    0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) +\n                ((ac1 &\n                    0xFFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF0000000000000000) >>\n                    64);\n            ac1 =\n                (ac1 &\n                    0x00000000000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) +\n                (ac1 >> 128);\n            ac1 += (ac1 >> 16) & 0xFFFF;\n            return uint16(ac1);\n        }\n    }\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/ethregistrar/IBaseRegistrar.sol": {
      "content": "import \"../registry/ENS.sol\";\nimport \"./IBaseRegistrar.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\ninterface IBaseRegistrar is IERC721 {\n    event ControllerAdded(address indexed controller);\n    event ControllerRemoved(address indexed controller);\n    event NameMigrated(\n        uint256 indexed id,\n        address indexed owner,\n        uint256 expires\n    );\n    event NameRegistered(\n        uint256 indexed id,\n        address indexed owner,\n        uint256 expires\n    );\n    event NameRenewed(uint256 indexed id, uint256 expires);\n\n    // Authorises a controller, who can register and renew domains.\n    function addController(address controller) external;\n\n    // Revoke controller permission for an address.\n    function removeController(address controller) external;\n\n    // Set the resolver for the TLD this registrar manages.\n    function setResolver(address resolver) external;\n\n    // Returns the expiration timestamp of the specified label hash.\n    function nameExpires(uint256 id) external view returns (uint256);\n\n    // Returns true iff the specified name is available for registration.\n    function available(uint256 id) external view returns (bool);\n\n    /**\n     * @dev Register a name.\n     */\n    function register(\n        uint256 id,\n        address owner,\n        uint256 duration\n    ) external returns (uint256);\n\n    function renew(uint256 id, uint256 duration) external returns (uint256);\n\n    /**\n     * @dev Reclaim ownership of a name in ENS, if you own it in the registrar.\n     */\n    function reclaim(uint256 id, address owner) external;\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/registry/ENS.sol": {
      "content": "pragma solidity >=0.8.4;\n\ninterface ENS {\n    // Logged when the owner of a node assigns a new owner to a subnode.\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n\n    // Logged when the owner of a node transfers ownership to a new account.\n    event Transfer(bytes32 indexed node, address owner);\n\n    // Logged when the resolver for a node changes.\n    event NewResolver(bytes32 indexed node, address resolver);\n\n    // Logged when the TTL of a node changes\n    event NewTTL(bytes32 indexed node, uint64 ttl);\n\n    // Logged when an operator is added or removed.\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        bytes32 label,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        bytes32 label,\n        address owner\n    ) external returns (bytes32);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setOwner(bytes32 node, address owner) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function setApprovalForAll(address operator, bool approved) external;\n\n    function owner(bytes32 node) external view returns (address);\n\n    function resolver(bytes32 node) external view returns (address);\n\n    function ttl(bytes32 node) external view returns (uint64);\n\n    function recordExists(bytes32 node) external view returns (bool);\n\n    function isApprovedForAll(\n        address owner,\n        address operator\n    ) external view returns (bool);\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/registry/ENSRegistry.sol": {
      "content": "pragma solidity >=0.8.4;\n\nimport \"./ENS.sol\";\n\n/**\n * The ENS registry contract.\n */\ncontract ENSRegistry is ENS {\n    struct Record {\n        address owner;\n        address resolver;\n        uint64 ttl;\n    }\n\n    mapping(bytes32 => Record) records;\n    mapping(address => mapping(address => bool)) operators;\n\n    // Permits modifications only by the owner of the specified node.\n    modifier authorised(bytes32 node) {\n        address owner = records[node].owner;\n        require(owner == msg.sender || operators[owner][msg.sender]);\n        _;\n    }\n\n    /**\n     * @dev Constructs a new ENS registry.\n     */\n    constructor() public {\n        records[0x0].owner = msg.sender;\n    }\n\n    /**\n     * @dev Sets the record for a node.\n     * @param node The node to update.\n     * @param owner The address of the new owner.\n     * @param resolver The address of the resolver.\n     * @param ttl The TTL in seconds.\n     */\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external virtual override {\n        setOwner(node, owner);\n        _setResolverAndTTL(node, resolver, ttl);\n    }\n\n    /**\n     * @dev Sets the record for a subnode.\n     * @param node The parent node.\n     * @param label The hash of the label specifying the subnode.\n     * @param owner The address of the new owner.\n     * @param resolver The address of the resolver.\n     * @param ttl The TTL in seconds.\n     */\n    function setSubnodeRecord(\n        bytes32 node,\n        bytes32 label,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external virtual override {\n        bytes32 subnode = setSubnodeOwner(node, label, owner);\n        _setResolverAndTTL(subnode, resolver, ttl);\n    }\n\n    /**\n     * @dev Transfers ownership of a node to a new address. May only be called by the current owner of the node.\n     * @param node The node to transfer ownership of.\n     * @param owner The address of the new owner.\n     */\n    function setOwner(\n        bytes32 node,\n        address owner\n    ) public virtual override authorised(node) {\n        _setOwner(node, owner);\n        emit Transfer(node, owner);\n    }\n\n    /**\n     * @dev Transfers ownership of a subnode keccak256(node, label) to a new address. May only be called by the owner of the parent node.\n     * @param node The parent node.\n     * @param label The hash of the label specifying the subnode.\n     * @param owner The address of the new owner.\n     */\n    function setSubnodeOwner(\n        bytes32 node,\n        bytes32 label,\n        address owner\n    ) public virtual override authorised(node) returns (bytes32) {\n        bytes32 subnode = keccak256(abi.encodePacked(node, label));\n        _setOwner(subnode, owner);\n        emit NewOwner(node, label, owner);\n        return subnode;\n    }\n\n    /**\n     * @dev Sets the resolver address for the specified node.\n     * @param node The node to update.\n     * @param resolver The address of the resolver.\n     */\n    function setResolver(\n        bytes32 node,\n        address resolver\n    ) public virtual override authorised(node) {\n        emit NewResolver(node, resolver);\n        records[node].resolver = resolver;\n    }\n\n    /**\n     * @dev Sets the TTL for the specified node.\n     * @param node The node to update.\n     * @param ttl The TTL in seconds.\n     */\n    function setTTL(\n        bytes32 node,\n        uint64 ttl\n    ) public virtual override authorised(node) {\n        emit NewTTL(node, ttl);\n        records[node].ttl = ttl;\n    }\n\n    /**\n     * @dev Enable or disable approval for a third party (\"operator\") to manage\n     *  all of `msg.sender`'s ENS records. Emits the ApprovalForAll event.\n     * @param operator Address to add to the set of authorized operators.\n     * @param approved True if the operator is approved, false to revoke approval.\n     */\n    function setApprovalForAll(\n        address operator,\n        bool approved\n    ) external virtual override {\n        operators[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    /**\n     * @dev Returns the address that owns the specified node.\n     * @param node The specified node.\n     * @return address of the owner.\n     */\n    function owner(\n        bytes32 node\n    ) public view virtual override returns (address) {\n        address addr = records[node].owner;\n        if (addr == address(this)) {\n            return address(0x0);\n        }\n\n        return addr;\n    }\n\n    /**\n     * @dev Returns the address of the resolver for the specified node.\n     * @param node The specified node.\n     * @return address of the resolver.\n     */\n    function resolver(\n        bytes32 node\n    ) public view virtual override returns (address) {\n        return records[node].resolver;\n    }\n\n    /**\n     * @dev Returns the TTL of a node, and any records associated with it.\n     * @param node The specified node.\n     * @return ttl of the node.\n     */\n    function ttl(bytes32 node) public view virtual override returns (uint64) {\n        return records[node].ttl;\n    }\n\n    /**\n     * @dev Returns whether a record has been imported to the registry.\n     * @param node The specified node.\n     * @return Bool if record exists\n     */\n    function recordExists(\n        bytes32 node\n    ) public view virtual override returns (bool) {\n        return records[node].owner != address(0x0);\n    }\n\n    /**\n     * @dev Query if an address is an authorized operator for another address.\n     * @param owner The address that owns the records.\n     * @param operator The address that acts on behalf of the owner.\n     * @return True if `operator` is an approved operator for `owner`, false otherwise.\n     */\n    function isApprovedForAll(\n        address owner,\n        address operator\n    ) external view virtual override returns (bool) {\n        return operators[owner][operator];\n    }\n\n    function _setOwner(bytes32 node, address owner) internal virtual {\n        records[node].owner = owner;\n    }\n\n    function _setResolverAndTTL(\n        bytes32 node,\n        address resolver,\n        uint64 ttl\n    ) internal {\n        if (resolver != records[node].resolver) {\n            records[node].resolver = resolver;\n            emit NewResolver(node, resolver);\n        }\n\n        if (ttl != records[node].ttl) {\n            records[node].ttl = ttl;\n            emit NewTTL(node, ttl);\n        }\n    }\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/registry/FIFSRegistrar.sol": {
      "content": "pragma solidity >=0.8.4;\n\nimport \"./ENS.sol\";\n\n/**\n * A registrar that allocates subdomains to the first person to claim them.\n */\ncontract FIFSRegistrar {\n    ENS ens;\n    bytes32 rootNode;\n\n    modifier only_owner(bytes32 label) {\n        address currentOwner = ens.owner(\n            keccak256(abi.encodePacked(rootNode, label))\n        );\n        require(currentOwner == address(0x0) || currentOwner == msg.sender);\n        _;\n    }\n\n    /**\n     * Constructor.\n     * @param ensAddr The address of the ENS registry.\n     * @param node The node that this registrar administers.\n     */\n    constructor(ENS ensAddr, bytes32 node) public {\n        ens = ensAddr;\n        rootNode = node;\n    }\n\n    /**\n     * Register a name, or change the owner of an existing registration.\n     * @param label The hash of the label to register.\n     * @param owner The address of the new owner.\n     */\n    function register(bytes32 label, address owner) public only_owner(label) {\n        ens.setSubnodeOwner(rootNode, label, owner);\n    }\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/resolvers/IMulticallable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface IMulticallable {\n    function multicall(\n        bytes[] calldata data\n    ) external returns (bytes[] memory results);\n\n    function multicallWithNodeCheck(\n        bytes32,\n        bytes[] calldata data\n    ) external returns (bytes[] memory results);\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/resolvers/Multicallable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./IMulticallable.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\nabstract contract Multicallable is IMulticallable, ERC165 {\n    function _multicall(\n        bytes32 nodehash,\n        bytes[] calldata data\n    ) internal returns (bytes[] memory results) {\n        results = new bytes[](data.length);\n        for (uint256 i = 0; i < data.length; i++) {\n            if (nodehash != bytes32(0)) {\n                bytes32 txNamehash = bytes32(data[i][4:36]);\n                require(\n                    txNamehash == nodehash,\n                    \"multicall: All records must have a matching namehash\"\n                );\n            }\n            (bool success, bytes memory result) = address(this).delegatecall(\n                data[i]\n            );\n            require(success);\n            results[i] = result;\n        }\n        return results;\n    }\n\n    // This function provides an extra security check when called\n    // from priviledged contracts (such as EthRegistrarController)\n    // that can set records on behalf of the node owners\n    function multicallWithNodeCheck(\n        bytes32 nodehash,\n        bytes[] calldata data\n    ) external returns (bytes[] memory results) {\n        return _multicall(nodehash, data);\n    }\n\n    function multicall(\n        bytes[] calldata data\n    ) public override returns (bytes[] memory results) {\n        return _multicall(bytes32(0), data);\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) public view virtual override returns (bool) {\n        return\n            interfaceID == type(IMulticallable).interfaceId ||\n            super.supportsInterface(interfaceID);\n    }\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/resolvers/profiles/ABIResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport \"./IABIResolver.sol\";\nimport \"../ResolverBase.sol\";\n\nabstract contract ABIResolver is IABIResolver, ResolverBase {\n    mapping(uint64 => mapping(bytes32 => mapping(uint256 => bytes))) versionable_abis;\n\n    /**\n     * Sets the ABI associated with an ENS node.\n     * Nodes may have one ABI of each content type. To remove an ABI, set it to\n     * the empty string.\n     * @param node The node to update.\n     * @param contentType The content type of the ABI\n     * @param data The ABI data.\n     */\n    function setABI(\n        bytes32 node,\n        uint256 contentType,\n        bytes calldata data\n    ) external virtual authorised(node) {\n        // Content types must be powers of 2\n        require(((contentType - 1) & contentType) == 0);\n\n        versionable_abis[recordVersions[node]][node][contentType] = data;\n        emit ABIChanged(node, contentType);\n    }\n\n    /**\n     * Returns the ABI associated with an ENS node.\n     * Defined in EIP205.\n     * @param node The ENS node to query\n     * @param contentTypes A bitwise OR of the ABI formats accepted by the caller.\n     * @return contentType The content type of the return value\n     * @return data The ABI data\n     */\n    function ABI(\n        bytes32 node,\n        uint256 contentTypes\n    ) external view virtual override returns (uint256, bytes memory) {\n        mapping(uint256 => bytes) storage abiset = versionable_abis[\n            recordVersions[node]\n        ][node];\n\n        for (\n            uint256 contentType = 1;\n            contentType <= contentTypes;\n            contentType <<= 1\n        ) {\n            if (\n                (contentType & contentTypes) != 0 &&\n                abiset[contentType].length > 0\n            ) {\n                return (contentType, abiset[contentType]);\n            }\n        }\n\n        return (0, bytes(\"\"));\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) public view virtual override returns (bool) {\n        return\n            interfaceID == type(IABIResolver).interfaceId ||\n            super.supportsInterface(interfaceID);\n    }\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/resolvers/profiles/AddrResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport \"../ResolverBase.sol\";\nimport \"./IAddrResolver.sol\";\nimport \"./IAddressResolver.sol\";\n\nabstract contract AddrResolver is\n    IAddrResolver,\n    IAddressResolver,\n    ResolverBase\n{\n    uint256 private constant COIN_TYPE_ETH = 60;\n\n    mapping(uint64 => mapping(bytes32 => mapping(uint256 => bytes))) versionable_addresses;\n\n    /**\n     * Sets the address associated with an ENS node.\n     * May only be called by the owner of that node in the ENS registry.\n     * @param node The node to update.\n     * @param a The address to set.\n     */\n    function setAddr(\n        bytes32 node,\n        address a\n    ) external virtual authorised(node) {\n        setAddr(node, COIN_TYPE_ETH, addressToBytes(a));\n    }\n\n    /**\n     * Returns the address associated with an ENS node.\n     * @param node The ENS node to query.\n     * @return The associated address.\n     */\n    function addr(\n        bytes32 node\n    ) public view virtual override returns (address payable) {\n        bytes memory a = addr(node, COIN_TYPE_ETH);\n        if (a.length == 0) {\n            return payable(0);\n        }\n        return bytesToAddress(a);\n    }\n\n    function setAddr(\n        bytes32 node,\n        uint256 coinType,\n        bytes memory a\n    ) public virtual authorised(node) {\n        emit AddressChanged(node, coinType, a);\n        if (coinType == COIN_TYPE_ETH) {\n            emit AddrChanged(node, bytesToAddress(a));\n        }\n        versionable_addresses[recordVersions[node]][node][coinType] = a;\n    }\n\n    function addr(\n        bytes32 node,\n        uint256 coinType\n    ) public view virtual override returns (bytes memory) {\n        return versionable_addresses[recordVersions[node]][node][coinType];\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) public view virtual override returns (bool) {\n        return\n            interfaceID == type(IAddrResolver).interfaceId ||\n            interfaceID == type(IAddressResolver).interfaceId ||\n            super.supportsInterface(interfaceID);\n    }\n\n    function bytesToAddress(\n        bytes memory b\n    ) internal pure returns (address payable a) {\n        require(b.length == 20);\n        assembly {\n            a := div(mload(add(b, 32)), exp(256, 12))\n        }\n    }\n\n    function addressToBytes(address a) internal pure returns (bytes memory b) {\n        b = new bytes(20);\n        assembly {\n            mstore(add(b, 32), mul(a, exp(256, 12)))\n        }\n    }\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/resolvers/profiles/ContentHashResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport \"../ResolverBase.sol\";\nimport \"./IContentHashResolver.sol\";\n\nabstract contract ContentHashResolver is IContentHashResolver, ResolverBase {\n    mapping(uint64 => mapping(bytes32 => bytes)) versionable_hashes;\n\n    /**\n     * Sets the contenthash associated with an ENS node.\n     * May only be called by the owner of that node in the ENS registry.\n     * @param node The node to update.\n     * @param hash The contenthash to set\n     */\n    function setContenthash(\n        bytes32 node,\n        bytes calldata hash\n    ) external virtual authorised(node) {\n        versionable_hashes[recordVersions[node]][node] = hash;\n        emit ContenthashChanged(node, hash);\n    }\n\n    /**\n     * Returns the contenthash associated with an ENS node.\n     * @param node The ENS node to query.\n     * @return The associated contenthash.\n     */\n    function contenthash(\n        bytes32 node\n    ) external view virtual override returns (bytes memory) {\n        return versionable_hashes[recordVersions[node]][node];\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) public view virtual override returns (bool) {\n        return\n            interfaceID == type(IContentHashResolver).interfaceId ||\n            super.supportsInterface(interfaceID);\n    }\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/resolvers/profiles/DNSResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport \"../ResolverBase.sol\";\nimport \"../../dnssec-oracle/RRUtils.sol\";\nimport \"./IDNSRecordResolver.sol\";\nimport \"./IDNSZoneResolver.sol\";\n\nabstract contract DNSResolver is\n    IDNSRecordResolver,\n    IDNSZoneResolver,\n    ResolverBase\n{\n    using RRUtils for *;\n    using BytesUtils for bytes;\n\n    // Zone hashes for the domains.\n    // A zone hash is an EIP-1577 content hash in binary format that should point to a\n    // resource containing a single zonefile.\n    // node => contenthash\n    mapping(uint64 => mapping(bytes32 => bytes)) private versionable_zonehashes;\n\n    // The records themselves.  Stored as binary RRSETs\n    // node => version => name => resource => data\n    mapping(uint64 => mapping(bytes32 => mapping(bytes32 => mapping(uint16 => bytes))))\n        private versionable_records;\n\n    // Count of number of entries for a given name.  Required for DNS resolvers\n    // when resolving wildcards.\n    // node => version => name => number of records\n    mapping(uint64 => mapping(bytes32 => mapping(bytes32 => uint16)))\n        private versionable_nameEntriesCount;\n\n    /**\n     * Set one or more DNS records.  Records are supplied in wire-format.\n     * Records with the same node/name/resource must be supplied one after the\n     * other to ensure the data is updated correctly. For example, if the data\n     * was supplied:\n     *     a.example.com IN A 1.2.3.4\n     *     a.example.com IN A 5.6.7.8\n     *     www.example.com IN CNAME a.example.com.\n     * then this would store the two A records for a.example.com correctly as a\n     * single RRSET, however if the data was supplied:\n     *     a.example.com IN A 1.2.3.4\n     *     www.example.com IN CNAME a.example.com.\n     *     a.example.com IN A 5.6.7.8\n     * then this would store the first A record, the CNAME, then the second A\n     * record which would overwrite the first.\n     *\n     * @param node the namehash of the node for which to set the records\n     * @param data the DNS wire format records to set\n     */\n    function setDNSRecords(\n        bytes32 node,\n        bytes calldata data\n    ) external virtual authorised(node) {\n        uint16 resource = 0;\n        uint256 offset = 0;\n        bytes memory name;\n        bytes memory value;\n        bytes32 nameHash;\n        uint64 version = recordVersions[node];\n        // Iterate over the data to add the resource records\n        for (\n            RRUtils.RRIterator memory iter = data.iterateRRs(0);\n            !iter.done();\n            iter.next()\n        ) {\n            if (resource == 0) {\n                resource = iter.dnstype;\n                name = iter.name();\n                nameHash = keccak256(abi.encodePacked(name));\n                value = bytes(iter.rdata());\n            } else {\n                bytes memory newName = iter.name();\n                if (resource != iter.dnstype || !name.equals(newName)) {\n                    setDNSRRSet(\n                        node,\n                        name,\n                        resource,\n                        data,\n                        offset,\n                        iter.offset - offset,\n                        value.length == 0,\n                        version\n                    );\n                    resource = iter.dnstype;\n                    offset = iter.offset;\n                    name = newName;\n                    nameHash = keccak256(name);\n                    value = bytes(iter.rdata());\n                }\n            }\n        }\n        if (name.length > 0) {\n            setDNSRRSet(\n                node,\n                name,\n                resource,\n                data,\n                offset,\n                data.length - offset,\n                value.length == 0,\n                version\n            );\n        }\n    }\n\n    /**\n     * Obtain a DNS record.\n     * @param node the namehash of the node for which to fetch the record\n     * @param name the keccak-256 hash of the fully-qualified name for which to fetch the record\n     * @param resource the ID of the resource as per https://en.wikipedia.org/wiki/List_of_DNS_record_types\n     * @return the DNS record in wire format if present, otherwise empty\n     */\n    function dnsRecord(\n        bytes32 node,\n        bytes32 name,\n        uint16 resource\n    ) public view virtual override returns (bytes memory) {\n        return versionable_records[recordVersions[node]][node][name][resource];\n    }\n\n    /**\n     * Check if a given node has records.\n     * @param node the namehash of the node for which to check the records\n     * @param name the namehash of the node for which to check the records\n     */\n    function hasDNSRecords(\n        bytes32 node,\n        bytes32 name\n    ) public view virtual returns (bool) {\n        return (versionable_nameEntriesCount[recordVersions[node]][node][\n            name\n        ] != 0);\n    }\n\n    /**\n     * setZonehash sets the hash for the zone.\n     * May only be called by the owner of that node in the ENS registry.\n     * @param node The node to update.\n     * @param hash The zonehash to set\n     */\n    function setZonehash(\n        bytes32 node,\n        bytes calldata hash\n    ) external virtual authorised(node) {\n        uint64 currentRecordVersion = recordVersions[node];\n        bytes memory oldhash = versionable_zonehashes[currentRecordVersion][\n            node\n        ];\n        versionable_zonehashes[currentRecordVersion][node] = hash;\n        emit DNSZonehashChanged(node, oldhash, hash);\n    }\n\n    /**\n     * zonehash obtains the hash for the zone.\n     * @param node The ENS node to query.\n     * @return The associated contenthash.\n     */\n    function zonehash(\n        bytes32 node\n    ) external view virtual override returns (bytes memory) {\n        return versionable_zonehashes[recordVersions[node]][node];\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) public view virtual override returns (bool) {\n        return\n            interfaceID == type(IDNSRecordResolver).interfaceId ||\n            interfaceID == type(IDNSZoneResolver).interfaceId ||\n            super.supportsInterface(interfaceID);\n    }\n\n    function setDNSRRSet(\n        bytes32 node,\n        bytes memory name,\n        uint16 resource,\n        bytes memory data,\n        uint256 offset,\n        uint256 size,\n        bool deleteRecord,\n        uint64 version\n    ) private {\n        bytes32 nameHash = keccak256(name);\n        bytes memory rrData = data.substring(offset, size);\n        if (deleteRecord) {\n            if (\n                versionable_records[version][node][nameHash][resource].length !=\n                0\n            ) {\n                versionable_nameEntriesCount[version][node][nameHash]--;\n            }\n            delete (versionable_records[version][node][nameHash][resource]);\n            emit DNSRecordDeleted(node, name, resource);\n        } else {\n            if (\n                versionable_records[version][node][nameHash][resource].length ==\n                0\n            ) {\n                versionable_nameEntriesCount[version][node][nameHash]++;\n            }\n            versionable_records[version][node][nameHash][resource] = rrData;\n            emit DNSRecordChanged(node, name, resource, rrData);\n        }\n    }\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/resolvers/profiles/ExtendedResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ncontract ExtendedResolver {\n    function resolve(\n        bytes memory /* name */,\n        bytes memory data\n    ) external view returns (bytes memory) {\n        (bool success, bytes memory result) = address(this).staticcall(data);\n        if (success) {\n            return result;\n        } else {\n            // Revert with the reason provided by the call\n            assembly {\n                revert(add(result, 0x20), mload(result))\n            }\n        }\n    }\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/resolvers/profiles/IABIResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface IABIResolver {\n    event ABIChanged(bytes32 indexed node, uint256 indexed contentType);\n\n    /**\n     * Returns the ABI associated with an ENS node.\n     * Defined in EIP205.\n     * @param node The ENS node to query\n     * @param contentTypes A bitwise OR of the ABI formats accepted by the caller.\n     * @return contentType The content type of the return value\n     * @return data The ABI data\n     */\n    function ABI(\n        bytes32 node,\n        uint256 contentTypes\n    ) external view returns (uint256, bytes memory);\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/resolvers/profiles/IAddressResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\n/**\n * Interface for the new (multicoin) addr function.\n */\ninterface IAddressResolver {\n    event AddressChanged(\n        bytes32 indexed node,\n        uint256 coinType,\n        bytes newAddress\n    );\n\n    function addr(\n        bytes32 node,\n        uint256 coinType\n    ) external view returns (bytes memory);\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/resolvers/profiles/IAddrResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\n/**\n * Interface for the legacy (ETH-only) addr function.\n */\ninterface IAddrResolver {\n    event AddrChanged(bytes32 indexed node, address a);\n\n    /**\n     * Returns the address associated with an ENS node.\n     * @param node The ENS node to query.\n     * @return The associated address.\n     */\n    function addr(bytes32 node) external view returns (address payable);\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/resolvers/profiles/IContentHashResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface IContentHashResolver {\n    event ContenthashChanged(bytes32 indexed node, bytes hash);\n\n    /**\n     * Returns the contenthash associated with an ENS node.\n     * @param node The ENS node to query.\n     * @return The associated contenthash.\n     */\n    function contenthash(bytes32 node) external view returns (bytes memory);\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/resolvers/profiles/IDNSRecordResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface IDNSRecordResolver {\n    // DNSRecordChanged is emitted whenever a given node/name/resource's RRSET is updated.\n    event DNSRecordChanged(\n        bytes32 indexed node,\n        bytes name,\n        uint16 resource,\n        bytes record\n    );\n    // DNSRecordDeleted is emitted whenever a given node/name/resource's RRSET is deleted.\n    event DNSRecordDeleted(bytes32 indexed node, bytes name, uint16 resource);\n\n    /**\n     * Obtain a DNS record.\n     * @param node the namehash of the node for which to fetch the record\n     * @param name the keccak-256 hash of the fully-qualified name for which to fetch the record\n     * @param resource the ID of the resource as per https://en.wikipedia.org/wiki/List_of_DNS_record_types\n     * @return the DNS record in wire format if present, otherwise empty\n     */\n    function dnsRecord(\n        bytes32 node,\n        bytes32 name,\n        uint16 resource\n    ) external view returns (bytes memory);\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/resolvers/profiles/IDNSZoneResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface IDNSZoneResolver {\n    // DNSZonehashChanged is emitted whenever a given node's zone hash is updated.\n    event DNSZonehashChanged(\n        bytes32 indexed node,\n        bytes lastzonehash,\n        bytes zonehash\n    );\n\n    /**\n     * zonehash obtains the hash for the zone.\n     * @param node The ENS node to query.\n     * @return The associated contenthash.\n     */\n    function zonehash(bytes32 node) external view returns (bytes memory);\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/resolvers/profiles/IExtendedResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface IExtendedResolver {\n    function resolve(\n        bytes memory name,\n        bytes memory data\n    ) external view returns (bytes memory);\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/resolvers/profiles/IInterfaceResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface IInterfaceResolver {\n    event InterfaceChanged(\n        bytes32 indexed node,\n        bytes4 indexed interfaceID,\n        address implementer\n    );\n\n    /**\n     * Returns the address of a contract that implements the specified interface for this name.\n     * If an implementer has not been set for this interfaceID and name, the resolver will query\n     * the contract at `addr()`. If `addr()` is set, a contract exists at that address, and that\n     * contract implements EIP165 and returns `true` for the specified interfaceID, its address\n     * will be returned.\n     * @param node The ENS node to query.\n     * @param interfaceID The EIP 165 interface ID to check for.\n     * @return The address that implements this interface, or 0 if the interface is unsupported.\n     */\n    function interfaceImplementer(\n        bytes32 node,\n        bytes4 interfaceID\n    ) external view returns (address);\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/resolvers/profiles/INameResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface INameResolver {\n    event NameChanged(bytes32 indexed node, string name);\n\n    /**\n     * Returns the name associated with an ENS node, for reverse records.\n     * Defined in EIP181.\n     * @param node The ENS node to query.\n     * @return The associated name.\n     */\n    function name(bytes32 node) external view returns (string memory);\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/resolvers/profiles/InterfaceResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport \"../ResolverBase.sol\";\nimport \"./AddrResolver.sol\";\nimport \"./IInterfaceResolver.sol\";\n\nabstract contract InterfaceResolver is IInterfaceResolver, AddrResolver {\n    mapping(uint64 => mapping(bytes32 => mapping(bytes4 => address))) versionable_interfaces;\n\n    /**\n     * Sets an interface associated with a name.\n     * Setting the address to 0 restores the default behaviour of querying the contract at `addr()` for interface support.\n     * @param node The node to update.\n     * @param interfaceID The EIP 165 interface ID.\n     * @param implementer The address of a contract that implements this interface for this node.\n     */\n    function setInterface(\n        bytes32 node,\n        bytes4 interfaceID,\n        address implementer\n    ) external virtual authorised(node) {\n        versionable_interfaces[recordVersions[node]][node][\n            interfaceID\n        ] = implementer;\n        emit InterfaceChanged(node, interfaceID, implementer);\n    }\n\n    /**\n     * Returns the address of a contract that implements the specified interface for this name.\n     * If an implementer has not been set for this interfaceID and name, the resolver will query\n     * the contract at `addr()`. If `addr()` is set, a contract exists at that address, and that\n     * contract implements EIP165 and returns `true` for the specified interfaceID, its address\n     * will be returned.\n     * @param node The ENS node to query.\n     * @param interfaceID The EIP 165 interface ID to check for.\n     * @return The address that implements this interface, or 0 if the interface is unsupported.\n     */\n    function interfaceImplementer(\n        bytes32 node,\n        bytes4 interfaceID\n    ) external view virtual override returns (address) {\n        address implementer = versionable_interfaces[recordVersions[node]][\n            node\n        ][interfaceID];\n        if (implementer != address(0)) {\n            return implementer;\n        }\n\n        address a = addr(node);\n        if (a == address(0)) {\n            return address(0);\n        }\n\n        (bool success, bytes memory returnData) = a.staticcall(\n            abi.encodeWithSignature(\n                \"supportsInterface(bytes4)\",\n                type(IERC165).interfaceId\n            )\n        );\n        if (!success || returnData.length < 32 || returnData[31] == 0) {\n            // EIP 165 not supported by target\n            return address(0);\n        }\n\n        (success, returnData) = a.staticcall(\n            abi.encodeWithSignature(\"supportsInterface(bytes4)\", interfaceID)\n        );\n        if (!success || returnData.length < 32 || returnData[31] == 0) {\n            // Specified interface not supported by target\n            return address(0);\n        }\n\n        return a;\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) public view virtual override returns (bool) {\n        return\n            interfaceID == type(IInterfaceResolver).interfaceId ||\n            super.supportsInterface(interfaceID);\n    }\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/resolvers/profiles/IPubkeyResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface IPubkeyResolver {\n    event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y);\n\n    /**\n     * Returns the SECP256k1 public key associated with an ENS node.\n     * Defined in EIP 619.\n     * @param node The ENS node to query\n     * @return x The X coordinate of the curve point for the public key.\n     * @return y The Y coordinate of the curve point for the public key.\n     */\n    function pubkey(bytes32 node) external view returns (bytes32 x, bytes32 y);\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/resolvers/profiles/ITextResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface ITextResolver {\n    event TextChanged(\n        bytes32 indexed node,\n        string indexed indexedKey,\n        string key,\n        string value\n    );\n\n    /**\n     * Returns the text data associated with an ENS node and key.\n     * @param node The ENS node to query.\n     * @param key The text data key to query.\n     * @return The associated text data.\n     */\n    function text(\n        bytes32 node,\n        string calldata key\n    ) external view returns (string memory);\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/resolvers/profiles/IVersionableResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface IVersionableResolver {\n    event VersionChanged(bytes32 indexed node, uint64 newVersion);\n\n    function recordVersions(bytes32 node) external view returns (uint64);\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/resolvers/profiles/NameResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport \"../ResolverBase.sol\";\nimport \"./INameResolver.sol\";\n\nabstract contract NameResolver is INameResolver, ResolverBase {\n    mapping(uint64 => mapping(bytes32 => string)) versionable_names;\n\n    /**\n     * Sets the name associated with an ENS node, for reverse records.\n     * May only be called by the owner of that node in the ENS registry.\n     * @param node The node to update.\n     */\n    function setName(\n        bytes32 node,\n        string calldata newName\n    ) external virtual authorised(node) {\n        versionable_names[recordVersions[node]][node] = newName;\n        emit NameChanged(node, newName);\n    }\n\n    /**\n     * Returns the name associated with an ENS node, for reverse records.\n     * Defined in EIP181.\n     * @param node The ENS node to query.\n     * @return The associated name.\n     */\n    function name(\n        bytes32 node\n    ) external view virtual override returns (string memory) {\n        return versionable_names[recordVersions[node]][node];\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) public view virtual override returns (bool) {\n        return\n            interfaceID == type(INameResolver).interfaceId ||\n            super.supportsInterface(interfaceID);\n    }\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/resolvers/profiles/PubkeyResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport \"../ResolverBase.sol\";\nimport \"./IPubkeyResolver.sol\";\n\nabstract contract PubkeyResolver is IPubkeyResolver, ResolverBase {\n    struct PublicKey {\n        bytes32 x;\n        bytes32 y;\n    }\n\n    mapping(uint64 => mapping(bytes32 => PublicKey)) versionable_pubkeys;\n\n    /**\n     * Sets the SECP256k1 public key associated with an ENS node.\n     * @param node The ENS node to query\n     * @param x the X coordinate of the curve point for the public key.\n     * @param y the Y coordinate of the curve point for the public key.\n     */\n    function setPubkey(\n        bytes32 node,\n        bytes32 x,\n        bytes32 y\n    ) external virtual authorised(node) {\n        versionable_pubkeys[recordVersions[node]][node] = PublicKey(x, y);\n        emit PubkeyChanged(node, x, y);\n    }\n\n    /**\n     * Returns the SECP256k1 public key associated with an ENS node.\n     * Defined in EIP 619.\n     * @param node The ENS node to query\n     * @return x The X coordinate of the curve point for the public key.\n     * @return y The Y coordinate of the curve point for the public key.\n     */\n    function pubkey(\n        bytes32 node\n    ) external view virtual override returns (bytes32 x, bytes32 y) {\n        uint64 currentRecordVersion = recordVersions[node];\n        return (\n            versionable_pubkeys[currentRecordVersion][node].x,\n            versionable_pubkeys[currentRecordVersion][node].y\n        );\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) public view virtual override returns (bool) {\n        return\n            interfaceID == type(IPubkeyResolver).interfaceId ||\n            super.supportsInterface(interfaceID);\n    }\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/resolvers/profiles/TextResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport \"../ResolverBase.sol\";\nimport \"./ITextResolver.sol\";\n\nabstract contract TextResolver is ITextResolver, ResolverBase {\n    mapping(uint64 => mapping(bytes32 => mapping(string => string))) versionable_texts;\n\n    /**\n     * Sets the text data associated with an ENS node and key.\n     * May only be called by the owner of that node in the ENS registry.\n     * @param node The node to update.\n     * @param key The key to set.\n     * @param value The text data value to set.\n     */\n    function setText(\n        bytes32 node,\n        string calldata key,\n        string calldata value\n    ) external virtual authorised(node) {\n        versionable_texts[recordVersions[node]][node][key] = value;\n        emit TextChanged(node, key, key, value);\n    }\n\n    /**\n     * Returns the text data associated with an ENS node and key.\n     * @param node The ENS node to query.\n     * @param key The text data key to query.\n     * @return The associated text data.\n     */\n    function text(\n        bytes32 node,\n        string calldata key\n    ) external view virtual override returns (string memory) {\n        return versionable_texts[recordVersions[node]][node][key];\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) public view virtual override returns (bool) {\n        return\n            interfaceID == type(ITextResolver).interfaceId ||\n            super.supportsInterface(interfaceID);\n    }\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/resolvers/PublicResolver.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.17 <0.9.0;\n\nimport \"../registry/ENS.sol\";\nimport \"./profiles/ABIResolver.sol\";\nimport \"./profiles/AddrResolver.sol\";\nimport \"./profiles/ContentHashResolver.sol\";\nimport \"./profiles/DNSResolver.sol\";\nimport \"./profiles/InterfaceResolver.sol\";\nimport \"./profiles/NameResolver.sol\";\nimport \"./profiles/PubkeyResolver.sol\";\nimport \"./profiles/TextResolver.sol\";\nimport \"./profiles/ExtendedResolver.sol\";\nimport \"./Multicallable.sol\";\nimport \"../wrapper/INameWrapper.sol\";\n\n/**\n * A simple resolver anyone can use; only allows the owner of a node to set its\n * address.\n */\ncontract PublicResolver is\n    Multicallable,\n    ABIResolver,\n    AddrResolver,\n    ContentHashResolver,\n    DNSResolver,\n    InterfaceResolver,\n    NameResolver,\n    PubkeyResolver,\n    TextResolver,\n    ExtendedResolver\n{\n    ENS immutable ens;\n    INameWrapper immutable nameWrapper;\n    address immutable trustedETHController;\n    address immutable trustedReverseRegistrar;\n\n    /**\n     * A mapping of operators. An address that is authorised for an address\n     * may make any changes to the name that the owner could, but may not update\n     * the set of authorisations.\n     * (owner, operator) => approved\n     */\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * A mapping of delegates. A delegate that is authorised by an owner\n     * for a name may make changes to the name's resolver, but may not update\n     * the set of token approvals.\n     * (owner, name, delegate) => approved\n     */\n    mapping(address => mapping(bytes32 => mapping(address => bool)))\n        private _tokenApprovals;\n\n    // Logged when an operator is added or removed.\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    // Logged when a delegate is approved or  an approval is revoked.\n    event Approved(\n        address owner,\n        bytes32 indexed node,\n        address indexed delegate,\n        bool indexed approved\n    );\n\n    constructor(\n        ENS _ens,\n        INameWrapper wrapperAddress,\n        address _trustedETHController,\n        address _trustedReverseRegistrar\n    ) {\n        ens = _ens;\n        nameWrapper = wrapperAddress;\n        trustedETHController = _trustedETHController;\n        trustedReverseRegistrar = _trustedReverseRegistrar;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) external {\n        require(\n            msg.sender != operator,\n            \"ERC1155: setting approval status for self\"\n        );\n\n        _operatorApprovals[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(\n        address account,\n        address operator\n    ) public view returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev Approve a delegate to be able to updated records on a node.\n     */\n    function approve(bytes32 node, address delegate, bool approved) external {\n        require(msg.sender != delegate, \"Setting delegate status for self\");\n\n        _tokenApprovals[msg.sender][node][delegate] = approved;\n        emit Approved(msg.sender, node, delegate, approved);\n    }\n\n    /**\n     * @dev Check to see if the delegate has been approved by the owner for the node.\n     */\n    function isApprovedFor(\n        address owner,\n        bytes32 node,\n        address delegate\n    ) public view returns (bool) {\n        return _tokenApprovals[owner][node][delegate];\n    }\n\n    function isAuthorised(bytes32 node) internal view override returns (bool) {\n        if (\n            msg.sender == trustedETHController ||\n            msg.sender == trustedReverseRegistrar\n        ) {\n            return true;\n        }\n        address owner = ens.owner(node);\n        if (owner == address(nameWrapper)) {\n            owner = nameWrapper.ownerOf(uint256(node));\n        }\n        return\n            owner == msg.sender ||\n            isApprovedForAll(owner, msg.sender) ||\n            isApprovedFor(owner, node, msg.sender);\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    )\n        public\n        view\n        override(\n            Multicallable,\n            ABIResolver,\n            AddrResolver,\n            ContentHashResolver,\n            DNSResolver,\n            InterfaceResolver,\n            NameResolver,\n            PubkeyResolver,\n            TextResolver\n        )\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceID);\n    }\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/resolvers/Resolver.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport \"./profiles/IABIResolver.sol\";\nimport \"./profiles/IAddressResolver.sol\";\nimport \"./profiles/IAddrResolver.sol\";\nimport \"./profiles/IContentHashResolver.sol\";\nimport \"./profiles/IDNSRecordResolver.sol\";\nimport \"./profiles/IDNSZoneResolver.sol\";\nimport \"./profiles/IInterfaceResolver.sol\";\nimport \"./profiles/INameResolver.sol\";\nimport \"./profiles/IPubkeyResolver.sol\";\nimport \"./profiles/ITextResolver.sol\";\nimport \"./profiles/IExtendedResolver.sol\";\n\n/**\n * A generic resolver interface which includes all the functions including the ones deprecated\n */\ninterface Resolver is\n    IERC165,\n    IABIResolver,\n    IAddressResolver,\n    IAddrResolver,\n    IContentHashResolver,\n    IDNSRecordResolver,\n    IDNSZoneResolver,\n    IInterfaceResolver,\n    INameResolver,\n    IPubkeyResolver,\n    ITextResolver,\n    IExtendedResolver\n{\n    /* Deprecated events */\n    event ContentChanged(bytes32 indexed node, bytes32 hash);\n\n    function setABI(\n        bytes32 node,\n        uint256 contentType,\n        bytes calldata data\n    ) external;\n\n    function setAddr(bytes32 node, address addr) external;\n\n    function setAddr(bytes32 node, uint256 coinType, bytes calldata a) external;\n\n    function setContenthash(bytes32 node, bytes calldata hash) external;\n\n    function setDnsrr(bytes32 node, bytes calldata data) external;\n\n    function setName(bytes32 node, string calldata _name) external;\n\n    function setPubkey(bytes32 node, bytes32 x, bytes32 y) external;\n\n    function setText(\n        bytes32 node,\n        string calldata key,\n        string calldata value\n    ) external;\n\n    function setInterface(\n        bytes32 node,\n        bytes4 interfaceID,\n        address implementer\n    ) external;\n\n    function multicall(\n        bytes[] calldata data\n    ) external returns (bytes[] memory results);\n\n    function multicallWithNodeCheck(\n        bytes32 nodehash,\n        bytes[] calldata data\n    ) external returns (bytes[] memory results);\n\n    /* Deprecated functions */\n    function content(bytes32 node) external view returns (bytes32);\n\n    function multihash(bytes32 node) external view returns (bytes memory);\n\n    function setContent(bytes32 node, bytes32 hash) external;\n\n    function setMultihash(bytes32 node, bytes calldata hash) external;\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/resolvers/ResolverBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"./profiles/IVersionableResolver.sol\";\n\nabstract contract ResolverBase is ERC165, IVersionableResolver {\n    mapping(bytes32 => uint64) public recordVersions;\n\n    function isAuthorised(bytes32 node) internal view virtual returns (bool);\n\n    modifier authorised(bytes32 node) {\n        require(isAuthorised(node));\n        _;\n    }\n\n    /**\n     * Increments the record version associated with an ENS node.\n     * May only be called by the owner of that node in the ENS registry.\n     * @param node The node to update.\n     */\n    function clearRecords(bytes32 node) public virtual authorised(node) {\n        recordVersions[node]++;\n        emit VersionChanged(node, recordVersions[node]);\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) public view virtual override returns (bool) {\n        return\n            interfaceID == type(IVersionableResolver).interfaceId ||\n            super.supportsInterface(interfaceID);\n    }\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/wrapper/IMetadataService.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ~0.8.17;\n\ninterface IMetadataService {\n    function uri(uint256) external view returns (string memory);\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/wrapper/INameWrapper.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ~0.8.17;\n\nimport \"../registry/ENS.sol\";\nimport \"../ethregistrar/IBaseRegistrar.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"./IMetadataService.sol\";\nimport \"./INameWrapperUpgrade.sol\";\n\nuint32 constant CANNOT_UNWRAP = 1;\nuint32 constant CANNOT_BURN_FUSES = 2;\nuint32 constant CANNOT_TRANSFER = 4;\nuint32 constant CANNOT_SET_RESOLVER = 8;\nuint32 constant CANNOT_SET_TTL = 16;\nuint32 constant CANNOT_CREATE_SUBDOMAIN = 32;\n//uint16 reserved for parent controlled fuses from bit 17 to bit 32\nuint32 constant PARENT_CANNOT_CONTROL = 1 << 16;\nuint32 constant IS_DOT_ETH = 1 << 17;\nuint32 constant CAN_EXTEND_EXPIRY = 1 << 18;\nuint32 constant CAN_DO_EVERYTHING = 0;\nuint32 constant PARENT_CONTROLLED_FUSES = 0xFFFF0000;\n// all fuses apart from IS_DOT_ETH\nuint32 constant USER_SETTABLE_FUSES = 0xFFFDFFFF;\n\ninterface INameWrapper is IERC1155 {\n    event NameWrapped(\n        bytes32 indexed node,\n        bytes name,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    );\n\n    event NameUnwrapped(bytes32 indexed node, address owner);\n\n    event FusesSet(bytes32 indexed node, uint32 fuses);\n    event ExpiryExtended(bytes32 indexed node, uint64 expiry);\n\n    function ens() external view returns (ENS);\n\n    function registrar() external view returns (IBaseRegistrar);\n\n    function metadataService() external view returns (IMetadataService);\n\n    function names(bytes32) external view returns (bytes memory);\n\n    function name() external view returns (string memory);\n\n    function upgradeContract() external view returns (INameWrapperUpgrade);\n\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n\n    function wrap(\n        bytes calldata name,\n        address wrappedOwner,\n        address resolver\n    ) external;\n\n    function wrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint16 ownerControlledFuses,\n        address resolver\n    ) external;\n\n    function registerAndWrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint256 duration,\n        address resolver,\n        uint16 ownerControlledFuses\n    ) external returns (uint256 registrarExpiry);\n\n    function renew(\n        uint256 labelHash,\n        uint256 duration\n    ) external returns (uint256 expires);\n\n    function unwrap(bytes32 node, bytes32 label, address owner) external;\n\n    function unwrapETH2LD(\n        bytes32 label,\n        address newRegistrant,\n        address newController\n    ) external;\n\n    function upgrade(bytes calldata name, bytes calldata extraData) external;\n\n    function setFuses(\n        bytes32 node,\n        uint16 ownerControlledFuses\n    ) external returns (uint32 newFuses);\n\n    function setChildFuses(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        uint32 fuses,\n        uint64 expiry\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        string calldata label,\n        address owner,\n        address resolver,\n        uint64 ttl,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        string calldata label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function extendExpiry(\n        bytes32 node,\n        bytes32 labelhash,\n        uint64 expiry\n    ) external returns (uint64);\n\n    function canModifyName(\n        bytes32 node,\n        address addr\n    ) external view returns (bool);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function ownerOf(uint256 id) external view returns (address owner);\n\n    function getData(\n        uint256 id\n    ) external view returns (address, uint32, uint64);\n\n    function setMetadataService(IMetadataService _metadataService) external;\n\n    function uri(uint256 tokenId) external view returns (string memory);\n\n    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress) external;\n\n    function allFusesBurned(\n        bytes32 node,\n        uint32 fuseMask\n    ) external view returns (bool);\n\n    function isWrapped(bytes32) external view returns (bool);\n\n    function isWrapped(bytes32, bytes32) external view returns (bool);\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/wrapper/INameWrapperUpgrade.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ~0.8.17;\n\ninterface INameWrapperUpgrade {\n    function wrapFromUpgrade(\n        bytes calldata name,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry,\n        bytes calldata extraData\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/governance/utils/IVotesUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (governance/utils/IVotes.sol)\npragma solidity ^0.8.0;\n\n/**\n * @dev Common interface for {ERC20Votes}, {ERC721Votes}, and other {Votes}-enabled contracts.\n *\n * _Available since v4.5._\n */\ninterface IVotesUpgradeable {\n    /**\n     * @dev Emitted when an account changes their delegate.\n     */\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    /**\n     * @dev Emitted when a token transfer or delegate change results in changes to a delegate's number of votes.\n     */\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n\n    /**\n     * @dev Returns the current amount of votes that `account` has.\n     */\n    function getVotes(address account) external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of votes that `account` had at a specific moment in the past. If the `clock()` is\n     * configured to use block numbers, this will return the value at the end of the corresponding block.\n     */\n    function getPastVotes(address account, uint256 timepoint) external view returns (uint256);\n\n    /**\n     * @dev Returns the total supply of votes available at a specific moment in the past. If the `clock()` is\n     * configured to use block numbers, this will return the value at the end of the corresponding block.\n     *\n     * NOTE: This value is the sum of all available votes, which is not necessarily the sum of all delegated votes.\n     * Votes that have not been delegated are still part of total supply, even though they would not participate in a\n     * vote.\n     */\n    function getPastTotalSupply(uint256 timepoint) external view returns (uint256);\n\n    /**\n     * @dev Returns the delegate that `account` has chosen.\n     */\n    function delegates(address account) external view returns (address);\n\n    /**\n     * @dev Delegates votes from the sender to `delegatee`.\n     */\n    function delegate(address delegatee) external;\n\n    /**\n     * @dev Delegates votes from signer to `delegatee`.\n     */\n    function delegateBySig(address delegatee, uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/draft-IERC1822Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822ProxiableUpgradeable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/IERC1967Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC1967.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\n *\n * _Available since v4.8.3._\n */\ninterface IERC1967Upgradeable {\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/IERC5267Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC5267.sol)\n\npragma solidity ^0.8.0;\n\ninterface IERC5267Upgradeable {\n    /**\n     * @dev MAY be emitted to signal that the domain could have changed.\n     */\n    event EIP712DomainChanged();\n\n    /**\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\n     * signature.\n     */\n    function eip712Domain()\n        external\n        view\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        );\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/IERC5805Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC5805.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../governance/utils/IVotesUpgradeable.sol\";\nimport \"./IERC6372Upgradeable.sol\";\n\ninterface IERC5805Upgradeable is IERC6372Upgradeable, IVotesUpgradeable {}\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/IERC6372Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC6372.sol)\n\npragma solidity ^0.8.0;\n\ninterface IERC6372Upgradeable {\n    /**\n     * @dev Clock used for flagging checkpoints. Can be overridden to implement timestamp based checkpoints (and voting).\n     */\n    function clock() external view returns (uint48);\n\n    /**\n     * @dev Description of the clock\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function CLOCK_MODE() external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/beacon/IBeaconUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeaconUpgradeable {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeaconUpgradeable.sol\";\nimport \"../../interfaces/IERC1967Upgradeable.sol\";\nimport \"../../interfaces/draft-IERC1822Upgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/StorageSlotUpgradeable.sol\";\nimport \"../utils/Initializable.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n */\nabstract contract ERC1967UpgradeUpgradeable is Initializable, IERC1967Upgradeable {\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n    }\n\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/UUPSUpgradeable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../interfaces/draft-IERC1822Upgradeable.sol\";\nimport \"../ERC1967/ERC1967UpgradeUpgradeable.sol\";\nimport \"./Initializable.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n *\n * _Available since v4.1._\n */\nabstract contract UUPSUpgradeable is Initializable, IERC1822ProxiableUpgradeable, ERC1967UpgradeUpgradeable {\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n    address private immutable __self = address(this);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        require(address(this) != __self, \"Function must be called through delegatecall\");\n        require(_getImplementation() == __self, \"Function must be called through active proxy\");\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        require(address(this) == __self, \"UUPSUpgradeable: must not be called through delegatecall\");\n        _;\n    }\n\n    /**\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n        return _IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeTo(address newImplementation) public virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeTo} and {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155ReceiverUpgradeable is IERC165Upgradeable {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(\n        address[] calldata accounts,\n        uint256[] calldata ids\n    ) external view returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[45] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n// EIP-2612 is Final as of 2022-11-01. This file is deprecated.\n\nimport \"./IERC20PermitUpgradeable.sol\";\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/ERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20PermitUpgradeable.sol\";\nimport \"../ERC20Upgradeable.sol\";\nimport \"../../../utils/cryptography/ECDSAUpgradeable.sol\";\nimport \"../../../utils/cryptography/EIP712Upgradeable.sol\";\nimport \"../../../utils/CountersUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n *\n * @custom:storage-size 51\n */\nabstract contract ERC20PermitUpgradeable is Initializable, ERC20Upgradeable, IERC20PermitUpgradeable, EIP712Upgradeable {\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n\n    mapping(address => CountersUpgradeable.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private constant _PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    /**\n     * @dev In previous versions `_PERMIT_TYPEHASH` was declared as `immutable`.\n     * However, to ensure consistency with the upgradeable transpiler, we will continue\n     * to reserve a slot.\n     * @custom:oz-renamed-from _PERMIT_TYPEHASH\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private _PERMIT_TYPEHASH_DEPRECATED_SLOT;\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    function __ERC20Permit_init(string memory name) internal onlyInitializing {\n        __EIP712_init_unchained(name, \"1\");\n    }\n\n    function __ERC20Permit_init_unchained(string memory) internal onlyInitializing {}\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSAUpgradeable.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        CountersUpgradeable.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20VotesUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/ERC20Votes.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ERC20PermitUpgradeable.sol\";\nimport \"../../../interfaces/IERC5805Upgradeable.sol\";\nimport \"../../../utils/math/MathUpgradeable.sol\";\nimport \"../../../utils/math/SafeCastUpgradeable.sol\";\nimport \"../../../utils/cryptography/ECDSAUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of ERC20 to support Compound-like voting and delegation. This version is more generic than Compound's,\n * and supports token supply up to 2^224^ - 1, while COMP is limited to 2^96^ - 1.\n *\n * NOTE: If exact COMP compatibility is required, use the {ERC20VotesComp} variant of this module.\n *\n * This extension keeps a history (checkpoints) of each account's vote power. Vote power can be delegated either\n * by calling the {delegate} function directly, or by providing a signature to be used with {delegateBySig}. Voting\n * power can be queried through the public accessors {getVotes} and {getPastVotes}.\n *\n * By default, token balance does not account for voting power. This makes transfers cheaper. The downside is that it\n * requires users to delegate to themselves in order to activate checkpoints and have their voting power tracked.\n *\n * _Available since v4.2._\n */\nabstract contract ERC20VotesUpgradeable is Initializable, ERC20PermitUpgradeable, IERC5805Upgradeable {\n    function __ERC20Votes_init() internal onlyInitializing {\n    }\n\n    function __ERC20Votes_init_unchained() internal onlyInitializing {\n    }\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint224 votes;\n    }\n\n    bytes32 private constant _DELEGATION_TYPEHASH =\n        keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    mapping(address => address) private _delegates;\n    mapping(address => Checkpoint[]) private _checkpoints;\n    Checkpoint[] private _totalSupplyCheckpoints;\n\n    /**\n     * @dev Clock used for flagging checkpoints. Can be overridden to implement timestamp based checkpoints (and voting).\n     */\n    function clock() public view virtual override returns (uint48) {\n        return SafeCastUpgradeable.toUint48(block.number);\n    }\n\n    /**\n     * @dev Description of the clock\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function CLOCK_MODE() public view virtual override returns (string memory) {\n        // Check that the clock was not modified\n        require(clock() == block.number, \"ERC20Votes: broken clock mode\");\n        return \"mode=blocknumber&from=default\";\n    }\n\n    /**\n     * @dev Get the `pos`-th checkpoint for `account`.\n     */\n    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {\n        return _checkpoints[account][pos];\n    }\n\n    /**\n     * @dev Get number of checkpoints for `account`.\n     */\n    function numCheckpoints(address account) public view virtual returns (uint32) {\n        return SafeCastUpgradeable.toUint32(_checkpoints[account].length);\n    }\n\n    /**\n     * @dev Get the address `account` is currently delegating to.\n     */\n    function delegates(address account) public view virtual override returns (address) {\n        return _delegates[account];\n    }\n\n    /**\n     * @dev Gets the current votes balance for `account`\n     */\n    function getVotes(address account) public view virtual override returns (uint256) {\n        uint256 pos = _checkpoints[account].length;\n        unchecked {\n            return pos == 0 ? 0 : _checkpoints[account][pos - 1].votes;\n        }\n    }\n\n    /**\n     * @dev Retrieve the number of votes for `account` at the end of `timepoint`.\n     *\n     * Requirements:\n     *\n     * - `timepoint` must be in the past\n     */\n    function getPastVotes(address account, uint256 timepoint) public view virtual override returns (uint256) {\n        require(timepoint < clock(), \"ERC20Votes: future lookup\");\n        return _checkpointsLookup(_checkpoints[account], timepoint);\n    }\n\n    /**\n     * @dev Retrieve the `totalSupply` at the end of `timepoint`. Note, this value is the sum of all balances.\n     * It is NOT the sum of all the delegated votes!\n     *\n     * Requirements:\n     *\n     * - `timepoint` must be in the past\n     */\n    function getPastTotalSupply(uint256 timepoint) public view virtual override returns (uint256) {\n        require(timepoint < clock(), \"ERC20Votes: future lookup\");\n        return _checkpointsLookup(_totalSupplyCheckpoints, timepoint);\n    }\n\n    /**\n     * @dev Lookup a value in a list of (sorted) checkpoints.\n     */\n    function _checkpointsLookup(Checkpoint[] storage ckpts, uint256 timepoint) private view returns (uint256) {\n        // We run a binary search to look for the last (most recent) checkpoint taken before (or at) `timepoint`.\n        //\n        // Initially we check if the block is recent to narrow the search range.\n        // During the loop, the index of the wanted checkpoint remains in the range [low-1, high).\n        // With each iteration, either `low` or `high` is moved towards the middle of the range to maintain the invariant.\n        // - If the middle checkpoint is after `timepoint`, we look in [low, mid)\n        // - If the middle checkpoint is before or equal to `timepoint`, we look in [mid+1, high)\n        // Once we reach a single value (when low == high), we've found the right checkpoint at the index high-1, if not\n        // out of bounds (in which case we're looking too far in the past and the result is 0).\n        // Note that if the latest checkpoint available is exactly for `timepoint`, we end up with an index that is\n        // past the end of the array, so we technically don't find a checkpoint after `timepoint`, but it works out\n        // the same.\n        uint256 length = ckpts.length;\n\n        uint256 low = 0;\n        uint256 high = length;\n\n        if (length > 5) {\n            uint256 mid = length - MathUpgradeable.sqrt(length);\n            if (_unsafeAccess(ckpts, mid).fromBlock > timepoint) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        while (low < high) {\n            uint256 mid = MathUpgradeable.average(low, high);\n            if (_unsafeAccess(ckpts, mid).fromBlock > timepoint) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        unchecked {\n            return high == 0 ? 0 : _unsafeAccess(ckpts, high - 1).votes;\n        }\n    }\n\n    /**\n     * @dev Delegate votes from the sender to `delegatee`.\n     */\n    function delegate(address delegatee) public virtual override {\n        _delegate(_msgSender(), delegatee);\n    }\n\n    /**\n     * @dev Delegates votes from signer to `delegatee`\n     */\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= expiry, \"ERC20Votes: signature expired\");\n        address signer = ECDSAUpgradeable.recover(\n            _hashTypedDataV4(keccak256(abi.encode(_DELEGATION_TYPEHASH, delegatee, nonce, expiry))),\n            v,\n            r,\n            s\n        );\n        require(nonce == _useNonce(signer), \"ERC20Votes: invalid nonce\");\n        _delegate(signer, delegatee);\n    }\n\n    /**\n     * @dev Maximum token supply. Defaults to `type(uint224).max` (2^224^ - 1).\n     */\n    function _maxSupply() internal view virtual returns (uint224) {\n        return type(uint224).max;\n    }\n\n    /**\n     * @dev Snapshots the totalSupply after it has been increased.\n     */\n    function _mint(address account, uint256 amount) internal virtual override {\n        super._mint(account, amount);\n        require(totalSupply() <= _maxSupply(), \"ERC20Votes: total supply risks overflowing votes\");\n\n        _writeCheckpoint(_totalSupplyCheckpoints, _add, amount);\n    }\n\n    /**\n     * @dev Snapshots the totalSupply after it has been decreased.\n     */\n    function _burn(address account, uint256 amount) internal virtual override {\n        super._burn(account, amount);\n\n        _writeCheckpoint(_totalSupplyCheckpoints, _subtract, amount);\n    }\n\n    /**\n     * @dev Move voting power when tokens are transferred.\n     *\n     * Emits a {IVotes-DelegateVotesChanged} event.\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual override {\n        super._afterTokenTransfer(from, to, amount);\n\n        _moveVotingPower(delegates(from), delegates(to), amount);\n    }\n\n    /**\n     * @dev Change delegation for `delegator` to `delegatee`.\n     *\n     * Emits events {IVotes-DelegateChanged} and {IVotes-DelegateVotesChanged}.\n     */\n    function _delegate(address delegator, address delegatee) internal virtual {\n        address currentDelegate = delegates(delegator);\n        uint256 delegatorBalance = balanceOf(delegator);\n        _delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        _moveVotingPower(currentDelegate, delegatee, delegatorBalance);\n    }\n\n    function _moveVotingPower(address src, address dst, uint256 amount) private {\n        if (src != dst && amount > 0) {\n            if (src != address(0)) {\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[src], _subtract, amount);\n                emit DelegateVotesChanged(src, oldWeight, newWeight);\n            }\n\n            if (dst != address(0)) {\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[dst], _add, amount);\n                emit DelegateVotesChanged(dst, oldWeight, newWeight);\n            }\n        }\n    }\n\n    function _writeCheckpoint(\n        Checkpoint[] storage ckpts,\n        function(uint256, uint256) view returns (uint256) op,\n        uint256 delta\n    ) private returns (uint256 oldWeight, uint256 newWeight) {\n        uint256 pos = ckpts.length;\n\n        unchecked {\n            Checkpoint memory oldCkpt = pos == 0 ? Checkpoint(0, 0) : _unsafeAccess(ckpts, pos - 1);\n\n            oldWeight = oldCkpt.votes;\n            newWeight = op(oldWeight, delta);\n\n            if (pos > 0 && oldCkpt.fromBlock == clock()) {\n                _unsafeAccess(ckpts, pos - 1).votes = SafeCastUpgradeable.toUint224(newWeight);\n            } else {\n                ckpts.push(Checkpoint({fromBlock: SafeCastUpgradeable.toUint32(clock()), votes: SafeCastUpgradeable.toUint224(newWeight)}));\n            }\n        }\n    }\n\n    function _add(uint256 a, uint256 b) private pure returns (uint256) {\n        return a + b;\n    }\n\n    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Access an element of the array without performing bounds check. The position is assumed to be within bounds.\n     */\n    function _unsafeAccess(Checkpoint[] storage ckpts, uint256 pos) private pure returns (Checkpoint storage result) {\n        assembly {\n            mstore(0, ckpts.slot)\n            result.slot := add(keccak256(0, 0x20), pos)\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[47] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20WrapperUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/ERC20Wrapper.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20Upgradeable.sol\";\nimport \"../utils/SafeERC20Upgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of the ERC20 token contract to support token wrapping.\n *\n * Users can deposit and withdraw \"underlying tokens\" and receive a matching number of \"wrapped tokens\". This is useful\n * in conjunction with other modules. For example, combining this wrapping mechanism with {ERC20Votes} will allow the\n * wrapping of an existing \"basic\" ERC20 into a governance token.\n *\n * _Available since v4.2._\n *\n * @custom:storage-size 51\n */\nabstract contract ERC20WrapperUpgradeable is Initializable, ERC20Upgradeable {\n    IERC20Upgradeable private _underlying;\n\n    function __ERC20Wrapper_init(IERC20Upgradeable underlyingToken) internal onlyInitializing {\n        __ERC20Wrapper_init_unchained(underlyingToken);\n    }\n\n    function __ERC20Wrapper_init_unchained(IERC20Upgradeable underlyingToken) internal onlyInitializing {\n        require(underlyingToken != this, \"ERC20Wrapper: cannot self wrap\");\n        _underlying = underlyingToken;\n    }\n\n    /**\n     * @dev See {ERC20-decimals}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        try IERC20MetadataUpgradeable(address(_underlying)).decimals() returns (uint8 value) {\n            return value;\n        } catch {\n            return super.decimals();\n        }\n    }\n\n    /**\n     * @dev Returns the address of the underlying ERC-20 token that is being wrapped.\n     */\n    function underlying() public view returns (IERC20Upgradeable) {\n        return _underlying;\n    }\n\n    /**\n     * @dev Allow a user to deposit underlying tokens and mint the corresponding number of wrapped tokens.\n     */\n    function depositFor(address account, uint256 amount) public virtual returns (bool) {\n        address sender = _msgSender();\n        require(sender != address(this), \"ERC20Wrapper: wrapper can't deposit\");\n        SafeERC20Upgradeable.safeTransferFrom(_underlying, sender, address(this), amount);\n        _mint(account, amount);\n        return true;\n    }\n\n    /**\n     * @dev Allow a user to burn a number of wrapped tokens and withdraw the corresponding number of underlying tokens.\n     */\n    function withdrawTo(address account, uint256 amount) public virtual returns (bool) {\n        _burn(_msgSender(), amount);\n        SafeERC20Upgradeable.safeTransfer(_underlying, account, amount);\n        return true;\n    }\n\n    /**\n     * @dev Mint wrapped token to cover any underlyingTokens that would have been transferred by mistake. Internal\n     * function that can be exposed with access control if desired.\n     */\n    function _recover(address account) internal virtual returns (uint256) {\n        uint256 value = _underlying.balanceOf(address(this)) - totalSupply();\n        _mint(account, value);\n        return value;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20PermitUpgradeable {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\nimport \"../extensions/IERC20PermitUpgradeable.sol\";\nimport \"../../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && AddressUpgradeable.isContract(address(token));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721ReceiverUpgradeable {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/CheckpointsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Checkpoints.sol)\n// This file was procedurally generated from scripts/generate/templates/Checkpoints.js.\n\npragma solidity ^0.8.0;\n\nimport \"./math/MathUpgradeable.sol\";\nimport \"./math/SafeCastUpgradeable.sol\";\n\n/**\n * @dev This library defines the `History` struct, for checkpointing values as they change at different points in\n * time, and later looking up past values by block number. See {Votes} as an example.\n *\n * To create a history of checkpoints define a variable type `Checkpoints.History` in your contract, and store a new\n * checkpoint for the current transaction block using the {push} function.\n *\n * _Available since v4.5._\n */\nlibrary CheckpointsUpgradeable {\n    struct History {\n        Checkpoint[] _checkpoints;\n    }\n\n    struct Checkpoint {\n        uint32 _blockNumber;\n        uint224 _value;\n    }\n\n    /**\n     * @dev Returns the value at a given block number. If a checkpoint is not available at that block, the closest one\n     * before it is returned, or zero otherwise. Because the number returned corresponds to that at the end of the\n     * block, the requested block number must be in the past, excluding the current block.\n     */\n    function getAtBlock(History storage self, uint256 blockNumber) internal view returns (uint256) {\n        require(blockNumber < block.number, \"Checkpoints: block not yet mined\");\n        uint32 key = SafeCastUpgradeable.toUint32(blockNumber);\n\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns the value at a given block number. If a checkpoint is not available at that block, the closest one\n     * before it is returned, or zero otherwise. Similar to {upperLookup} but optimized for the case when the searched\n     * checkpoint is probably \"recent\", defined as being among the last sqrt(N) checkpoints where N is the number of\n     * checkpoints.\n     */\n    function getAtProbablyRecentBlock(History storage self, uint256 blockNumber) internal view returns (uint256) {\n        require(blockNumber < block.number, \"Checkpoints: block not yet mined\");\n        uint32 key = SafeCastUpgradeable.toUint32(blockNumber);\n\n        uint256 len = self._checkpoints.length;\n\n        uint256 low = 0;\n        uint256 high = len;\n\n        if (len > 5) {\n            uint256 mid = len - MathUpgradeable.sqrt(len);\n            if (key < _unsafeAccess(self._checkpoints, mid)._blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);\n\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Pushes a value onto a History so that it is stored as the checkpoint for the current block.\n     *\n     * Returns previous value and new value.\n     */\n    function push(History storage self, uint256 value) internal returns (uint256, uint256) {\n        return _insert(self._checkpoints, SafeCastUpgradeable.toUint32(block.number), SafeCastUpgradeable.toUint224(value));\n    }\n\n    /**\n     * @dev Pushes a value onto a History, by updating the latest value using binary operation `op`. The new value will\n     * be set to `op(latest, delta)`.\n     *\n     * Returns previous value and new value.\n     */\n    function push(\n        History storage self,\n        function(uint256, uint256) view returns (uint256) op,\n        uint256 delta\n    ) internal returns (uint256, uint256) {\n        return push(self, op(latest(self), delta));\n    }\n\n    /**\n     * @dev Returns the value in the most recent checkpoint, or zero if there are no checkpoints.\n     */\n    function latest(History storage self) internal view returns (uint224) {\n        uint256 pos = self._checkpoints.length;\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns whether there is a checkpoint in the structure (i.e. it is not empty), and if so the key and value\n     * in the most recent checkpoint.\n     */\n    function latestCheckpoint(\n        History storage self\n    ) internal view returns (bool exists, uint32 _blockNumber, uint224 _value) {\n        uint256 pos = self._checkpoints.length;\n        if (pos == 0) {\n            return (false, 0, 0);\n        } else {\n            Checkpoint memory ckpt = _unsafeAccess(self._checkpoints, pos - 1);\n            return (true, ckpt._blockNumber, ckpt._value);\n        }\n    }\n\n    /**\n     * @dev Returns the number of checkpoint.\n     */\n    function length(History storage self) internal view returns (uint256) {\n        return self._checkpoints.length;\n    }\n\n    /**\n     * @dev Pushes a (`key`, `value`) pair into an ordered list of checkpoints, either by inserting a new checkpoint,\n     * or by updating the last one.\n     */\n    function _insert(Checkpoint[] storage self, uint32 key, uint224 value) private returns (uint224, uint224) {\n        uint256 pos = self.length;\n\n        if (pos > 0) {\n            // Copying to memory is important here.\n            Checkpoint memory last = _unsafeAccess(self, pos - 1);\n\n            // Checkpoint keys must be non-decreasing.\n            require(last._blockNumber <= key, \"Checkpoint: decreasing keys\");\n\n            // Update or push new checkpoint\n            if (last._blockNumber == key) {\n                _unsafeAccess(self, pos - 1)._value = value;\n            } else {\n                self.push(Checkpoint({_blockNumber: key, _value: value}));\n            }\n            return (last._value, value);\n        } else {\n            self.push(Checkpoint({_blockNumber: key, _value: value}));\n            return (0, value);\n        }\n    }\n\n    /**\n     * @dev Return the index of the last (most recent) checkpoint with key lower or equal than the search key, or `high` if there is none.\n     * `low` and `high` define a section where to do the search, with inclusive `low` and exclusive `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _upperBinaryLookup(\n        Checkpoint[] storage self,\n        uint32 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = MathUpgradeable.average(low, high);\n            if (_unsafeAccess(self, mid)._blockNumber > key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Return the index of the first (oldest) checkpoint with key is greater or equal than the search key, or `high` if there is none.\n     * `low` and `high` define a section where to do the search, with inclusive `low` and exclusive `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _lowerBinaryLookup(\n        Checkpoint[] storage self,\n        uint32 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = MathUpgradeable.average(low, high);\n            if (_unsafeAccess(self, mid)._blockNumber < key) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Access an element of the array without performing bounds check. The position is assumed to be within bounds.\n     */\n    function _unsafeAccess(Checkpoint[] storage self, uint256 pos) private pure returns (Checkpoint storage result) {\n        assembly {\n            mstore(0, self.slot)\n            result.slot := add(keccak256(0, 0x20), pos)\n        }\n    }\n\n    struct Trace224 {\n        Checkpoint224[] _checkpoints;\n    }\n\n    struct Checkpoint224 {\n        uint32 _key;\n        uint224 _value;\n    }\n\n    /**\n     * @dev Pushes a (`key`, `value`) pair into a Trace224 so that it is stored as the checkpoint.\n     *\n     * Returns previous value and new value.\n     */\n    function push(Trace224 storage self, uint32 key, uint224 value) internal returns (uint224, uint224) {\n        return _insert(self._checkpoints, key, value);\n    }\n\n    /**\n     * @dev Returns the value in the first (oldest) checkpoint with key greater or equal than the search key, or zero if there is none.\n     */\n    function lowerLookup(Trace224 storage self, uint32 key) internal view returns (uint224) {\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _lowerBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == len ? 0 : _unsafeAccess(self._checkpoints, pos)._value;\n    }\n\n    /**\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero if there is none.\n     */\n    function upperLookup(Trace224 storage self, uint32 key) internal view returns (uint224) {\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero if there is none.\n     *\n     * NOTE: This is a variant of {upperLookup} that is optimised to find \"recent\" checkpoint (checkpoints with high keys).\n     */\n    function upperLookupRecent(Trace224 storage self, uint32 key) internal view returns (uint224) {\n        uint256 len = self._checkpoints.length;\n\n        uint256 low = 0;\n        uint256 high = len;\n\n        if (len > 5) {\n            uint256 mid = len - MathUpgradeable.sqrt(len);\n            if (key < _unsafeAccess(self._checkpoints, mid)._key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);\n\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns the value in the most recent checkpoint, or zero if there are no checkpoints.\n     */\n    function latest(Trace224 storage self) internal view returns (uint224) {\n        uint256 pos = self._checkpoints.length;\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns whether there is a checkpoint in the structure (i.e. it is not empty), and if so the key and value\n     * in the most recent checkpoint.\n     */\n    function latestCheckpoint(Trace224 storage self) internal view returns (bool exists, uint32 _key, uint224 _value) {\n        uint256 pos = self._checkpoints.length;\n        if (pos == 0) {\n            return (false, 0, 0);\n        } else {\n            Checkpoint224 memory ckpt = _unsafeAccess(self._checkpoints, pos - 1);\n            return (true, ckpt._key, ckpt._value);\n        }\n    }\n\n    /**\n     * @dev Returns the number of checkpoint.\n     */\n    function length(Trace224 storage self) internal view returns (uint256) {\n        return self._checkpoints.length;\n    }\n\n    /**\n     * @dev Pushes a (`key`, `value`) pair into an ordered list of checkpoints, either by inserting a new checkpoint,\n     * or by updating the last one.\n     */\n    function _insert(Checkpoint224[] storage self, uint32 key, uint224 value) private returns (uint224, uint224) {\n        uint256 pos = self.length;\n\n        if (pos > 0) {\n            // Copying to memory is important here.\n            Checkpoint224 memory last = _unsafeAccess(self, pos - 1);\n\n            // Checkpoint keys must be non-decreasing.\n            require(last._key <= key, \"Checkpoint: decreasing keys\");\n\n            // Update or push new checkpoint\n            if (last._key == key) {\n                _unsafeAccess(self, pos - 1)._value = value;\n            } else {\n                self.push(Checkpoint224({_key: key, _value: value}));\n            }\n            return (last._value, value);\n        } else {\n            self.push(Checkpoint224({_key: key, _value: value}));\n            return (0, value);\n        }\n    }\n\n    /**\n     * @dev Return the index of the last (most recent) checkpoint with key lower or equal than the search key, or `high` if there is none.\n     * `low` and `high` define a section where to do the search, with inclusive `low` and exclusive `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _upperBinaryLookup(\n        Checkpoint224[] storage self,\n        uint32 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = MathUpgradeable.average(low, high);\n            if (_unsafeAccess(self, mid)._key > key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Return the index of the first (oldest) checkpoint with key is greater or equal than the search key, or `high` if there is none.\n     * `low` and `high` define a section where to do the search, with inclusive `low` and exclusive `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _lowerBinaryLookup(\n        Checkpoint224[] storage self,\n        uint32 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = MathUpgradeable.average(low, high);\n            if (_unsafeAccess(self, mid)._key < key) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Access an element of the array without performing bounds check. The position is assumed to be within bounds.\n     */\n    function _unsafeAccess(\n        Checkpoint224[] storage self,\n        uint256 pos\n    ) private pure returns (Checkpoint224 storage result) {\n        assembly {\n            mstore(0, self.slot)\n            result.slot := add(keccak256(0, 0x20), pos)\n        }\n    }\n\n    struct Trace160 {\n        Checkpoint160[] _checkpoints;\n    }\n\n    struct Checkpoint160 {\n        uint96 _key;\n        uint160 _value;\n    }\n\n    /**\n     * @dev Pushes a (`key`, `value`) pair into a Trace160 so that it is stored as the checkpoint.\n     *\n     * Returns previous value and new value.\n     */\n    function push(Trace160 storage self, uint96 key, uint160 value) internal returns (uint160, uint160) {\n        return _insert(self._checkpoints, key, value);\n    }\n\n    /**\n     * @dev Returns the value in the first (oldest) checkpoint with key greater or equal than the search key, or zero if there is none.\n     */\n    function lowerLookup(Trace160 storage self, uint96 key) internal view returns (uint160) {\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _lowerBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == len ? 0 : _unsafeAccess(self._checkpoints, pos)._value;\n    }\n\n    /**\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero if there is none.\n     */\n    function upperLookup(Trace160 storage self, uint96 key) internal view returns (uint160) {\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero if there is none.\n     *\n     * NOTE: This is a variant of {upperLookup} that is optimised to find \"recent\" checkpoint (checkpoints with high keys).\n     */\n    function upperLookupRecent(Trace160 storage self, uint96 key) internal view returns (uint160) {\n        uint256 len = self._checkpoints.length;\n\n        uint256 low = 0;\n        uint256 high = len;\n\n        if (len > 5) {\n            uint256 mid = len - MathUpgradeable.sqrt(len);\n            if (key < _unsafeAccess(self._checkpoints, mid)._key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);\n\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns the value in the most recent checkpoint, or zero if there are no checkpoints.\n     */\n    function latest(Trace160 storage self) internal view returns (uint160) {\n        uint256 pos = self._checkpoints.length;\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns whether there is a checkpoint in the structure (i.e. it is not empty), and if so the key and value\n     * in the most recent checkpoint.\n     */\n    function latestCheckpoint(Trace160 storage self) internal view returns (bool exists, uint96 _key, uint160 _value) {\n        uint256 pos = self._checkpoints.length;\n        if (pos == 0) {\n            return (false, 0, 0);\n        } else {\n            Checkpoint160 memory ckpt = _unsafeAccess(self._checkpoints, pos - 1);\n            return (true, ckpt._key, ckpt._value);\n        }\n    }\n\n    /**\n     * @dev Returns the number of checkpoint.\n     */\n    function length(Trace160 storage self) internal view returns (uint256) {\n        return self._checkpoints.length;\n    }\n\n    /**\n     * @dev Pushes a (`key`, `value`) pair into an ordered list of checkpoints, either by inserting a new checkpoint,\n     * or by updating the last one.\n     */\n    function _insert(Checkpoint160[] storage self, uint96 key, uint160 value) private returns (uint160, uint160) {\n        uint256 pos = self.length;\n\n        if (pos > 0) {\n            // Copying to memory is important here.\n            Checkpoint160 memory last = _unsafeAccess(self, pos - 1);\n\n            // Checkpoint keys must be non-decreasing.\n            require(last._key <= key, \"Checkpoint: decreasing keys\");\n\n            // Update or push new checkpoint\n            if (last._key == key) {\n                _unsafeAccess(self, pos - 1)._value = value;\n            } else {\n                self.push(Checkpoint160({_key: key, _value: value}));\n            }\n            return (last._value, value);\n        } else {\n            self.push(Checkpoint160({_key: key, _value: value}));\n            return (0, value);\n        }\n    }\n\n    /**\n     * @dev Return the index of the last (most recent) checkpoint with key lower or equal than the search key, or `high` if there is none.\n     * `low` and `high` define a section where to do the search, with inclusive `low` and exclusive `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _upperBinaryLookup(\n        Checkpoint160[] storage self,\n        uint96 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = MathUpgradeable.average(low, high);\n            if (_unsafeAccess(self, mid)._key > key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Return the index of the first (oldest) checkpoint with key is greater or equal than the search key, or `high` if there is none.\n     * `low` and `high` define a section where to do the search, with inclusive `low` and exclusive `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _lowerBinaryLookup(\n        Checkpoint160[] storage self,\n        uint96 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = MathUpgradeable.average(low, high);\n            if (_unsafeAccess(self, mid)._key < key) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Access an element of the array without performing bounds check. The position is assumed to be within bounds.\n     */\n    function _unsafeAccess(\n        Checkpoint160[] storage self,\n        uint256 pos\n    ) private pure returns (Checkpoint160 storage result) {\n        assembly {\n            mstore(0, self.slot)\n            result.slot := add(keccak256(0, 0x20), pos)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary CountersUpgradeable {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../StringsUpgradeable.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSAUpgradeable {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV // Deprecated in v4.8\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", StringsUpgradeable.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, \"\\x19\\x01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\n     * `validator` and `data` according to the version 0 of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x00\", validator, data));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/cryptography/EIP712Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/EIP712.sol)\n\npragma solidity ^0.8.8;\n\nimport \"./ECDSAUpgradeable.sol\";\nimport \"../../interfaces/IERC5267Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain\n * separator of the implementation contract. This will cause the `_domainSeparatorV4` function to always rebuild the\n * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.\n *\n * _Available since v3.4._\n *\n * @custom:storage-size 52\n */\nabstract contract EIP712Upgradeable is Initializable, IERC5267Upgradeable {\n    bytes32 private constant _TYPE_HASH =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    /// @custom:oz-renamed-from _HASHED_NAME\n    bytes32 private _hashedName;\n    /// @custom:oz-renamed-from _HASHED_VERSION\n    bytes32 private _hashedVersion;\n\n    string private _name;\n    string private _version;\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        _name = name;\n        _version = version;\n\n        // Reset prior values in storage if upgrading\n        _hashedName = 0;\n        _hashedVersion = 0;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(_TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSAUpgradeable.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev See {EIP-5267}.\n     *\n     * _Available since v4.9._\n     */\n    function eip712Domain()\n        public\n        view\n        virtual\n        override\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        // If the hashed name and version in storage are non-zero, the contract hasn't been properly initialized\n        // and the EIP712 domain is not reliable, as it will be missing name and version.\n        require(_hashedName == 0 && _hashedVersion == 0, \"EIP712: Uninitialized\");\n\n        return (\n            hex\"0f\", // 01111\n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n\n    /**\n     * @dev The name parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712Name() internal virtual view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev The version parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712Version() internal virtual view returns (string memory) {\n        return _version;\n    }\n\n    /**\n     * @dev The hash of the name parameter for the EIP712 domain.\n     *\n     * NOTE: In previous versions this function was virtual. In this version you should override `_EIP712Name` instead.\n     */\n    function _EIP712NameHash() internal view returns (bytes32) {\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            // If the name is empty, the contract may have been upgraded without initializing the new storage.\n            // We return the name hash in storage if non-zero, otherwise we assume the name is empty by design.\n            bytes32 hashedName = _hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256(\"\");\n            }\n        }\n    }\n\n    /**\n     * @dev The hash of the version parameter for the EIP712 domain.\n     *\n     * NOTE: In previous versions this function was virtual. In this version you should override `_EIP712Version` instead.\n     */\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            // If the version is empty, the contract may have been upgraded without initializing the new storage.\n            // We return the version hash in storage if non-zero, otherwise we assume the version is empty by design.\n            bytes32 hashedVersion = _hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256(\"\");\n            }\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[48] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165CheckerUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/introspection/ERC165Checker.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\n\n/**\n * @dev Library used to query support of an interface declared via {IERC165}.\n *\n * Note that these functions return the actual result of the query: they do not\n * `revert` if an interface is not supported. It is up to the caller to decide\n * what to do in these cases.\n */\nlibrary ERC165CheckerUpgradeable {\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\n\n    /**\n     * @dev Returns true if `account` supports the {IERC165} interface.\n     */\n    function supportsERC165(address account) internal view returns (bool) {\n        // Any contract that implements ERC165 must explicitly indicate support of\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\n        return\n            supportsERC165InterfaceUnchecked(account, type(IERC165Upgradeable).interfaceId) &&\n            !supportsERC165InterfaceUnchecked(account, _INTERFACE_ID_INVALID);\n    }\n\n    /**\n     * @dev Returns true if `account` supports the interface defined by\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\n        // query support of both ERC165 as per the spec and support of _interfaceId\n        return supportsERC165(account) && supportsERC165InterfaceUnchecked(account, interfaceId);\n    }\n\n    /**\n     * @dev Returns a boolean array where each value corresponds to the\n     * interfaces passed in and whether they're supported or not. This allows\n     * you to batch check interfaces for a contract where your expectation\n     * is that some interfaces may not be supported.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * _Available since v3.4._\n     */\n    function getSupportedInterfaces(\n        address account,\n        bytes4[] memory interfaceIds\n    ) internal view returns (bool[] memory) {\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\n\n        // query support of ERC165 itself\n        if (supportsERC165(account)) {\n            // query support of each interface in interfaceIds\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\n                interfaceIdsSupported[i] = supportsERC165InterfaceUnchecked(account, interfaceIds[i]);\n            }\n        }\n\n        return interfaceIdsSupported;\n    }\n\n    /**\n     * @dev Returns true if `account` supports all the interfaces defined in\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\n     *\n     * Batch-querying can lead to gas savings by skipping repeated checks for\n     * {IERC165} support.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\n        // query support of ERC165 itself\n        if (!supportsERC165(account)) {\n            return false;\n        }\n\n        // query support of each interface in interfaceIds\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\n            if (!supportsERC165InterfaceUnchecked(account, interfaceIds[i])) {\n                return false;\n            }\n        }\n\n        // all interfaces supported\n        return true;\n    }\n\n    /**\n     * @notice Query if a contract implements an interface, does not check ERC165 support\n     * @param account The address of the contract to query for support of an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @return true if the contract at account indicates support of the interface with\n     * identifier interfaceId, false otherwise\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\n     * the behavior of this method is undefined. This precondition can be checked\n     * with {supportsERC165}.\n     *\n     * Some precompiled contracts will falsely indicate support for a given interface, so caution\n     * should be exercised when using this function.\n     *\n     * Interface identification is specified in ERC-165.\n     */\n    function supportsERC165InterfaceUnchecked(address account, bytes4 interfaceId) internal view returns (bool) {\n        // prepare call\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165Upgradeable.supportsInterface.selector, interfaceId);\n\n        // perform static call\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly {\n            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0x00)\n        }\n\n        return success && returnSize >= 0x20 && returnValue > 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165StorageUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165Storage.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Storage based implementation of the {IERC165} interface.\n *\n * Contracts may inherit from this and call {_registerInterface} to declare\n * their support of an interface.\n */\nabstract contract ERC165StorageUpgradeable is Initializable, ERC165Upgradeable {\n    function __ERC165Storage_init() internal onlyInitializing {\n    }\n\n    function __ERC165Storage_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Mapping of interface ids to whether or not it's supported.\n     */\n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return super.supportsInterface(interfaceId) || _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev Registers the contract as an implementer of the interface defined by\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\n     * registering its interface id is not required.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * Requirements:\n     *\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\n     */\n    function _registerInterface(bytes4 interfaceId) internal virtual {\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n        _supportedInterfaces[interfaceId] = true;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary MathUpgradeable {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCastUpgradeable {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 248 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 240 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 232 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 224 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 216 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 208 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 200 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 192 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 184 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 176 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 168 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 160 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 152 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 144 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 136 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 128 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 120 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 112 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 104 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 96 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 88 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 80 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 72 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 64 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 56 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 48 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 40 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 32 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 24 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 16 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 8 bits\");\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/SignedMathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMathUpgradeable {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\n * _Available since v4.9 for `string`, `bytes`._\n */\nlibrary StorageSlotUpgradeable {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/MathUpgradeable.sol\";\nimport \"./math/SignedMathUpgradeable.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMathUpgradeable.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/governance/utils/IVotes.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (governance/utils/IVotes.sol)\npragma solidity ^0.8.0;\n\n/**\n * @dev Common interface for {ERC20Votes}, {ERC721Votes}, and other {Votes}-enabled contracts.\n *\n * _Available since v4.5._\n */\ninterface IVotes {\n    /**\n     * @dev Emitted when an account changes their delegate.\n     */\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    /**\n     * @dev Emitted when a token transfer or delegate change results in changes to a delegate's number of votes.\n     */\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n\n    /**\n     * @dev Returns the current amount of votes that `account` has.\n     */\n    function getVotes(address account) external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of votes that `account` had at a specific moment in the past. If the `clock()` is\n     * configured to use block numbers, this will return the value at the end of the corresponding block.\n     */\n    function getPastVotes(address account, uint256 timepoint) external view returns (uint256);\n\n    /**\n     * @dev Returns the total supply of votes available at a specific moment in the past. If the `clock()` is\n     * configured to use block numbers, this will return the value at the end of the corresponding block.\n     *\n     * NOTE: This value is the sum of all available votes, which is not necessarily the sum of all delegated votes.\n     * Votes that have not been delegated are still part of total supply, even though they would not participate in a\n     * vote.\n     */\n    function getPastTotalSupply(uint256 timepoint) external view returns (uint256);\n\n    /**\n     * @dev Returns the delegate that `account` has chosen.\n     */\n    function delegates(address account) external view returns (address);\n\n    /**\n     * @dev Delegates votes from the sender to `delegatee`.\n     */\n    function delegate(address delegatee) external;\n\n    /**\n     * @dev Delegates votes from signer to `delegatee`.\n     */\n    function delegateBySig(address delegatee, uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s) external;\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1271.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1271.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC1271 standard signature validation method for\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\n *\n * _Available since v4.1._\n */\ninterface IERC1271 {\n    /**\n     * @dev Should return whether the signature provided is valid for the provided data\n     * @param hash      Hash of the data to be signed\n     * @param signature Signature byte array associated with _data\n     */\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1967.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC1967.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\n *\n * _Available since v4.8.3._\n */\ninterface IERC1967 {\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC5267.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC5267.sol)\n\npragma solidity ^0.8.0;\n\ninterface IERC5267 {\n    /**\n     * @dev MAY be emitted to signal that the domain could have changed.\n     */\n    event EIP712DomainChanged();\n\n    /**\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\n     * signature.\n     */\n    function eip712Domain()\n        external\n        view\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        );\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC5805.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC5805.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../governance/utils/IVotes.sol\";\nimport \"./IERC6372.sol\";\n\ninterface IERC5805 is IERC6372, IVotes {}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC6372.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC6372.sol)\n\npragma solidity ^0.8.0;\n\ninterface IERC6372 {\n    /**\n     * @dev Clock used for flagging checkpoints. Can be overridden to implement timestamp based checkpoints (and voting).\n     */\n    function clock() external view returns (uint48);\n\n    /**\n     * @dev Description of the clock\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function CLOCK_MODE() external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/Clones.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create(0, 0x09, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create2(0, 0x09, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(add(ptr, 0x38), deployer)\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\n            mstore(add(ptr, 0x14), implementation)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\n            mstore(add(ptr, 0x58), salt)\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\n            predicted := keccak256(add(ptr, 0x43), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt\n    ) internal view returns (address predicted) {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Proxy.sol\";\nimport \"./ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializing the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../interfaces/IERC1967.sol\";\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n */\nabstract contract ERC1967Upgrade is IERC1967 {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overridden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(\n        address[] calldata accounts,\n        uint256[] calldata ids\n    ) external view returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/ERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Permit.sol\";\nimport \"../ERC20.sol\";\nimport \"../../../utils/cryptography/ECDSA.sol\";\nimport \"../../../utils/cryptography/EIP712.sol\";\nimport \"../../../utils/Counters.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\n    using Counters for Counters.Counter;\n\n    mapping(address => Counters.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private constant _PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    /**\n     * @dev In previous versions `_PERMIT_TYPEHASH` was declared as `immutable`.\n     * However, to ensure consistency with the upgradeable transpiler, we will continue\n     * to reserve a slot.\n     * @custom:oz-renamed-from _PERMIT_TYPEHASH\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private _PERMIT_TYPEHASH_DEPRECATED_SLOT;\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        Counters.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/ERC20Votes.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ERC20Permit.sol\";\nimport \"../../../interfaces/IERC5805.sol\";\nimport \"../../../utils/math/Math.sol\";\nimport \"../../../utils/math/SafeCast.sol\";\nimport \"../../../utils/cryptography/ECDSA.sol\";\n\n/**\n * @dev Extension of ERC20 to support Compound-like voting and delegation. This version is more generic than Compound's,\n * and supports token supply up to 2^224^ - 1, while COMP is limited to 2^96^ - 1.\n *\n * NOTE: If exact COMP compatibility is required, use the {ERC20VotesComp} variant of this module.\n *\n * This extension keeps a history (checkpoints) of each account's vote power. Vote power can be delegated either\n * by calling the {delegate} function directly, or by providing a signature to be used with {delegateBySig}. Voting\n * power can be queried through the public accessors {getVotes} and {getPastVotes}.\n *\n * By default, token balance does not account for voting power. This makes transfers cheaper. The downside is that it\n * requires users to delegate to themselves in order to activate checkpoints and have their voting power tracked.\n *\n * _Available since v4.2._\n */\nabstract contract ERC20Votes is ERC20Permit, IERC5805 {\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint224 votes;\n    }\n\n    bytes32 private constant _DELEGATION_TYPEHASH =\n        keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    mapping(address => address) private _delegates;\n    mapping(address => Checkpoint[]) private _checkpoints;\n    Checkpoint[] private _totalSupplyCheckpoints;\n\n    /**\n     * @dev Clock used for flagging checkpoints. Can be overridden to implement timestamp based checkpoints (and voting).\n     */\n    function clock() public view virtual override returns (uint48) {\n        return SafeCast.toUint48(block.number);\n    }\n\n    /**\n     * @dev Description of the clock\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function CLOCK_MODE() public view virtual override returns (string memory) {\n        // Check that the clock was not modified\n        require(clock() == block.number, \"ERC20Votes: broken clock mode\");\n        return \"mode=blocknumber&from=default\";\n    }\n\n    /**\n     * @dev Get the `pos`-th checkpoint for `account`.\n     */\n    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {\n        return _checkpoints[account][pos];\n    }\n\n    /**\n     * @dev Get number of checkpoints for `account`.\n     */\n    function numCheckpoints(address account) public view virtual returns (uint32) {\n        return SafeCast.toUint32(_checkpoints[account].length);\n    }\n\n    /**\n     * @dev Get the address `account` is currently delegating to.\n     */\n    function delegates(address account) public view virtual override returns (address) {\n        return _delegates[account];\n    }\n\n    /**\n     * @dev Gets the current votes balance for `account`\n     */\n    function getVotes(address account) public view virtual override returns (uint256) {\n        uint256 pos = _checkpoints[account].length;\n        unchecked {\n            return pos == 0 ? 0 : _checkpoints[account][pos - 1].votes;\n        }\n    }\n\n    /**\n     * @dev Retrieve the number of votes for `account` at the end of `timepoint`.\n     *\n     * Requirements:\n     *\n     * - `timepoint` must be in the past\n     */\n    function getPastVotes(address account, uint256 timepoint) public view virtual override returns (uint256) {\n        require(timepoint < clock(), \"ERC20Votes: future lookup\");\n        return _checkpointsLookup(_checkpoints[account], timepoint);\n    }\n\n    /**\n     * @dev Retrieve the `totalSupply` at the end of `timepoint`. Note, this value is the sum of all balances.\n     * It is NOT the sum of all the delegated votes!\n     *\n     * Requirements:\n     *\n     * - `timepoint` must be in the past\n     */\n    function getPastTotalSupply(uint256 timepoint) public view virtual override returns (uint256) {\n        require(timepoint < clock(), \"ERC20Votes: future lookup\");\n        return _checkpointsLookup(_totalSupplyCheckpoints, timepoint);\n    }\n\n    /**\n     * @dev Lookup a value in a list of (sorted) checkpoints.\n     */\n    function _checkpointsLookup(Checkpoint[] storage ckpts, uint256 timepoint) private view returns (uint256) {\n        // We run a binary search to look for the last (most recent) checkpoint taken before (or at) `timepoint`.\n        //\n        // Initially we check if the block is recent to narrow the search range.\n        // During the loop, the index of the wanted checkpoint remains in the range [low-1, high).\n        // With each iteration, either `low` or `high` is moved towards the middle of the range to maintain the invariant.\n        // - If the middle checkpoint is after `timepoint`, we look in [low, mid)\n        // - If the middle checkpoint is before or equal to `timepoint`, we look in [mid+1, high)\n        // Once we reach a single value (when low == high), we've found the right checkpoint at the index high-1, if not\n        // out of bounds (in which case we're looking too far in the past and the result is 0).\n        // Note that if the latest checkpoint available is exactly for `timepoint`, we end up with an index that is\n        // past the end of the array, so we technically don't find a checkpoint after `timepoint`, but it works out\n        // the same.\n        uint256 length = ckpts.length;\n\n        uint256 low = 0;\n        uint256 high = length;\n\n        if (length > 5) {\n            uint256 mid = length - Math.sqrt(length);\n            if (_unsafeAccess(ckpts, mid).fromBlock > timepoint) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (_unsafeAccess(ckpts, mid).fromBlock > timepoint) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        unchecked {\n            return high == 0 ? 0 : _unsafeAccess(ckpts, high - 1).votes;\n        }\n    }\n\n    /**\n     * @dev Delegate votes from the sender to `delegatee`.\n     */\n    function delegate(address delegatee) public virtual override {\n        _delegate(_msgSender(), delegatee);\n    }\n\n    /**\n     * @dev Delegates votes from signer to `delegatee`\n     */\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= expiry, \"ERC20Votes: signature expired\");\n        address signer = ECDSA.recover(\n            _hashTypedDataV4(keccak256(abi.encode(_DELEGATION_TYPEHASH, delegatee, nonce, expiry))),\n            v,\n            r,\n            s\n        );\n        require(nonce == _useNonce(signer), \"ERC20Votes: invalid nonce\");\n        _delegate(signer, delegatee);\n    }\n\n    /**\n     * @dev Maximum token supply. Defaults to `type(uint224).max` (2^224^ - 1).\n     */\n    function _maxSupply() internal view virtual returns (uint224) {\n        return type(uint224).max;\n    }\n\n    /**\n     * @dev Snapshots the totalSupply after it has been increased.\n     */\n    function _mint(address account, uint256 amount) internal virtual override {\n        super._mint(account, amount);\n        require(totalSupply() <= _maxSupply(), \"ERC20Votes: total supply risks overflowing votes\");\n\n        _writeCheckpoint(_totalSupplyCheckpoints, _add, amount);\n    }\n\n    /**\n     * @dev Snapshots the totalSupply after it has been decreased.\n     */\n    function _burn(address account, uint256 amount) internal virtual override {\n        super._burn(account, amount);\n\n        _writeCheckpoint(_totalSupplyCheckpoints, _subtract, amount);\n    }\n\n    /**\n     * @dev Move voting power when tokens are transferred.\n     *\n     * Emits a {IVotes-DelegateVotesChanged} event.\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual override {\n        super._afterTokenTransfer(from, to, amount);\n\n        _moveVotingPower(delegates(from), delegates(to), amount);\n    }\n\n    /**\n     * @dev Change delegation for `delegator` to `delegatee`.\n     *\n     * Emits events {IVotes-DelegateChanged} and {IVotes-DelegateVotesChanged}.\n     */\n    function _delegate(address delegator, address delegatee) internal virtual {\n        address currentDelegate = delegates(delegator);\n        uint256 delegatorBalance = balanceOf(delegator);\n        _delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        _moveVotingPower(currentDelegate, delegatee, delegatorBalance);\n    }\n\n    function _moveVotingPower(address src, address dst, uint256 amount) private {\n        if (src != dst && amount > 0) {\n            if (src != address(0)) {\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[src], _subtract, amount);\n                emit DelegateVotesChanged(src, oldWeight, newWeight);\n            }\n\n            if (dst != address(0)) {\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[dst], _add, amount);\n                emit DelegateVotesChanged(dst, oldWeight, newWeight);\n            }\n        }\n    }\n\n    function _writeCheckpoint(\n        Checkpoint[] storage ckpts,\n        function(uint256, uint256) view returns (uint256) op,\n        uint256 delta\n    ) private returns (uint256 oldWeight, uint256 newWeight) {\n        uint256 pos = ckpts.length;\n\n        unchecked {\n            Checkpoint memory oldCkpt = pos == 0 ? Checkpoint(0, 0) : _unsafeAccess(ckpts, pos - 1);\n\n            oldWeight = oldCkpt.votes;\n            newWeight = op(oldWeight, delta);\n\n            if (pos > 0 && oldCkpt.fromBlock == clock()) {\n                _unsafeAccess(ckpts, pos - 1).votes = SafeCast.toUint224(newWeight);\n            } else {\n                ckpts.push(Checkpoint({fromBlock: SafeCast.toUint32(clock()), votes: SafeCast.toUint224(newWeight)}));\n            }\n        }\n    }\n\n    function _add(uint256 a, uint256 b) private pure returns (uint256) {\n        return a + b;\n    }\n\n    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Access an element of the array without performing bounds check. The position is assumed to be within bounds.\n     */\n    function _unsafeAccess(Checkpoint[] storage ckpts, uint256 pos) private pure returns (Checkpoint storage result) {\n        assembly {\n            mstore(0, ckpts.slot)\n            result.slot := add(keccak256(0, 0x20), pos)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner or approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId, 1);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n\n    /**\n     * @dev Unsafe write access to the balances, used by extensions that \"mint\" tokens using an {ownerOf} override.\n     *\n     * WARNING: Anyone calling this MUST ensure that the balances remain consistent with the ownership. The invariant\n     * being that for any address `a` the value returned by `balanceOf(a)` must be equal to the number of tokens such\n     * that `ownerOf(tokenId)` is `a`.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/extensions/ERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\nimport \"./IERC721Enumerable.sol\";\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n */\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721Enumerable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev See {ERC721-_beforeTokenTransfer}.\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, firstTokenId, batchSize);\n\n        if (batchSize > 1) {\n            // Will only trigger during construction. Batch transferring (minting) is not available afterwards.\n            revert(\"ERC721Enumerable: consecutive transfers not supported\");\n        }\n\n        uint256 tokenId = firstTokenId;\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV // Deprecated in v4.8\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, \"\\x19\\x01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\n     * `validator` and `data` according to the version 0 of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x00\", validator, data));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/EIP712.sol)\n\npragma solidity ^0.8.8;\n\nimport \"./ECDSA.sol\";\nimport \"../ShortStrings.sol\";\nimport \"../../interfaces/IERC5267.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain\n * separator of the implementation contract. This will cause the `_domainSeparatorV4` function to always rebuild the\n * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.\n *\n * _Available since v3.4._\n *\n * @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n */\nabstract contract EIP712 is IERC5267 {\n    using ShortStrings for *;\n\n    bytes32 private constant _TYPE_HASH =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _cachedDomainSeparator;\n    uint256 private immutable _cachedChainId;\n    address private immutable _cachedThis;\n\n    bytes32 private immutable _hashedName;\n    bytes32 private immutable _hashedVersion;\n\n    ShortString private immutable _name;\n    ShortString private immutable _version;\n    string private _nameFallback;\n    string private _versionFallback;\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        _name = name.toShortStringWithFallback(_nameFallback);\n        _version = version.toShortStringWithFallback(_versionFallback);\n        _hashedName = keccak256(bytes(name));\n        _hashedVersion = keccak256(bytes(version));\n\n        _cachedChainId = block.chainid;\n        _cachedDomainSeparator = _buildDomainSeparator();\n        _cachedThis = address(this);\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _cachedThis && block.chainid == _cachedChainId) {\n            return _cachedDomainSeparator;\n        } else {\n            return _buildDomainSeparator();\n        }\n    }\n\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(_TYPE_HASH, _hashedName, _hashedVersion, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev See {EIP-5267}.\n     *\n     * _Available since v4.9._\n     */\n    function eip712Domain()\n        public\n        view\n        virtual\n        override\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        return (\n            hex\"0f\", // 01111\n            _name.toStringWithFallback(_nameFallback),\n            _version.toStringWithFallback(_versionFallback),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165Checker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/introspection/ERC165Checker.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Library used to query support of an interface declared via {IERC165}.\n *\n * Note that these functions return the actual result of the query: they do not\n * `revert` if an interface is not supported. It is up to the caller to decide\n * what to do in these cases.\n */\nlibrary ERC165Checker {\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\n\n    /**\n     * @dev Returns true if `account` supports the {IERC165} interface.\n     */\n    function supportsERC165(address account) internal view returns (bool) {\n        // Any contract that implements ERC165 must explicitly indicate support of\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\n        return\n            supportsERC165InterfaceUnchecked(account, type(IERC165).interfaceId) &&\n            !supportsERC165InterfaceUnchecked(account, _INTERFACE_ID_INVALID);\n    }\n\n    /**\n     * @dev Returns true if `account` supports the interface defined by\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\n        // query support of both ERC165 as per the spec and support of _interfaceId\n        return supportsERC165(account) && supportsERC165InterfaceUnchecked(account, interfaceId);\n    }\n\n    /**\n     * @dev Returns a boolean array where each value corresponds to the\n     * interfaces passed in and whether they're supported or not. This allows\n     * you to batch check interfaces for a contract where your expectation\n     * is that some interfaces may not be supported.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * _Available since v3.4._\n     */\n    function getSupportedInterfaces(\n        address account,\n        bytes4[] memory interfaceIds\n    ) internal view returns (bool[] memory) {\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\n\n        // query support of ERC165 itself\n        if (supportsERC165(account)) {\n            // query support of each interface in interfaceIds\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\n                interfaceIdsSupported[i] = supportsERC165InterfaceUnchecked(account, interfaceIds[i]);\n            }\n        }\n\n        return interfaceIdsSupported;\n    }\n\n    /**\n     * @dev Returns true if `account` supports all the interfaces defined in\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\n     *\n     * Batch-querying can lead to gas savings by skipping repeated checks for\n     * {IERC165} support.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\n        // query support of ERC165 itself\n        if (!supportsERC165(account)) {\n            return false;\n        }\n\n        // query support of each interface in interfaceIds\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\n            if (!supportsERC165InterfaceUnchecked(account, interfaceIds[i])) {\n                return false;\n            }\n        }\n\n        // all interfaces supported\n        return true;\n    }\n\n    /**\n     * @notice Query if a contract implements an interface, does not check ERC165 support\n     * @param account The address of the contract to query for support of an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @return true if the contract at account indicates support of the interface with\n     * identifier interfaceId, false otherwise\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\n     * the behavior of this method is undefined. This precondition can be checked\n     * with {supportsERC165}.\n     *\n     * Some precompiled contracts will falsely indicate support for a given interface, so caution\n     * should be exercised when using this function.\n     *\n     * Interface identification is specified in ERC-165.\n     */\n    function supportsERC165InterfaceUnchecked(address account, bytes4 interfaceId) internal view returns (bool) {\n        // prepare call\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);\n\n        // perform static call\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly {\n            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0x00)\n        }\n\n        return success && returnSize >= 0x20 && returnValue > 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 248 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 240 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 232 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 224 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 216 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 208 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 200 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 192 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 184 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 176 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 168 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 160 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 152 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 144 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 136 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 128 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 120 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 112 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 104 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 96 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 88 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 80 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 72 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 64 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 56 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 48 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 40 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 32 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 24 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 16 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 8 bits\");\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ShortStrings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/ShortStrings.sol)\n\npragma solidity ^0.8.8;\n\nimport \"./StorageSlot.sol\";\n\n// | string  | 0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA   |\n// | length  | 0x                                                              BB |\ntype ShortString is bytes32;\n\n/**\n * @dev This library provides functions to convert short memory strings\n * into a `ShortString` type that can be used as an immutable variable.\n *\n * Strings of arbitrary length can be optimized using this library if\n * they are short enough (up to 31 bytes) by packing them with their\n * length (1 byte) in a single EVM word (32 bytes). Additionally, a\n * fallback mechanism can be used for every other case.\n *\n * Usage example:\n *\n * ```solidity\n * contract Named {\n *     using ShortStrings for *;\n *\n *     ShortString private immutable _name;\n *     string private _nameFallback;\n *\n *     constructor(string memory contractName) {\n *         _name = contractName.toShortStringWithFallback(_nameFallback);\n *     }\n *\n *     function name() external view returns (string memory) {\n *         return _name.toStringWithFallback(_nameFallback);\n *     }\n * }\n * ```\n */\nlibrary ShortStrings {\n    // Used as an identifier for strings longer than 31 bytes.\n    bytes32 private constant _FALLBACK_SENTINEL = 0x00000000000000000000000000000000000000000000000000000000000000FF;\n\n    error StringTooLong(string str);\n    error InvalidShortString();\n\n    /**\n     * @dev Encode a string of at most 31 chars into a `ShortString`.\n     *\n     * This will trigger a `StringTooLong` error is the input string is too long.\n     */\n    function toShortString(string memory str) internal pure returns (ShortString) {\n        bytes memory bstr = bytes(str);\n        if (bstr.length > 31) {\n            revert StringTooLong(str);\n        }\n        return ShortString.wrap(bytes32(uint256(bytes32(bstr)) | bstr.length));\n    }\n\n    /**\n     * @dev Decode a `ShortString` back to a \"normal\" string.\n     */\n    function toString(ShortString sstr) internal pure returns (string memory) {\n        uint256 len = byteLength(sstr);\n        // using `new string(len)` would work locally but is not memory safe.\n        string memory str = new string(32);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(str, len)\n            mstore(add(str, 0x20), sstr)\n        }\n        return str;\n    }\n\n    /**\n     * @dev Return the length of a `ShortString`.\n     */\n    function byteLength(ShortString sstr) internal pure returns (uint256) {\n        uint256 result = uint256(ShortString.unwrap(sstr)) & 0xFF;\n        if (result > 31) {\n            revert InvalidShortString();\n        }\n        return result;\n    }\n\n    /**\n     * @dev Encode a string into a `ShortString`, or write it to storage if it is too long.\n     */\n    function toShortStringWithFallback(string memory value, string storage store) internal returns (ShortString) {\n        if (bytes(value).length < 32) {\n            return toShortString(value);\n        } else {\n            StorageSlot.getStringSlot(store).value = value;\n            return ShortString.wrap(_FALLBACK_SENTINEL);\n        }\n    }\n\n    /**\n     * @dev Decode a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\n     */\n    function toStringWithFallback(ShortString value, string storage store) internal pure returns (string memory) {\n        if (ShortString.unwrap(value) != _FALLBACK_SENTINEL) {\n            return toString(value);\n        } else {\n            return store;\n        }\n    }\n\n    /**\n     * @dev Return the length of a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\n     *\n     * WARNING: This will return the \"byte length\" of the string. This may not reflect the actual length in terms of\n     * actual characters as the UTF-8 encoding of a single character can span over multiple bytes.\n     */\n    function byteLengthWithFallback(ShortString value, string storage store) internal view returns (uint256) {\n        if (ShortString.unwrap(value) != _FALLBACK_SENTINEL) {\n            return byteLength(value);\n        } else {\n            return bytes(store).length;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\n * _Available since v4.9 for `string`, `bytes`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\nimport \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "contracts/DAO/SharedAddress/ISharedAddress.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport {IDAO} from \"@aragon/osx/core/dao/IDAO.sol\";\r\n\r\nbytes32 constant GRANT_ACCESS_PERMISSION_ID = keccak256(\r\n    \"GRANT_ACCESS_PERMISSION\"\r\n);\r\nbytes32 constant REVOKE_ACCESS_PERMISSION_ID = keccak256(\r\n    \"REVOKE_ACCESS_PERMISSION\"\r\n);\r\n\r\ninterface ISharedAddress {\r\n    error NotWearingHat();\r\n    error AccessDenied();\r\n\r\n    event Execution(\r\n        uint256 indexed nonce,\r\n        address indexed sender,\r\n        uint256 hat,\r\n        IDAO.Action[] actions\r\n    );\r\n\r\n    event FullAccessGranted(uint256 indexed hat);\r\n    event FullZoneAccessGranted(uint256 indexed hat, address zone);\r\n    event FullFunctionAccessGranted(\r\n        uint256 indexed hat,\r\n        address zone,\r\n        bytes4 functionSelector\r\n    );\r\n\r\n    event FullAccessRevoked(uint256 indexed hat);\r\n    event FullZoneAccessRevoked(uint256 indexed hat, address zone);\r\n    event FullFunctionAccessRevoked(\r\n        uint256 indexed hat,\r\n        address zone,\r\n        bytes4 functionSelector\r\n    );\r\n\r\n    /// @notice Verifies if a hat is allowed to execute a list of actions.\r\n    /// @param _hat The hat to check with.\r\n    /// @param _actions The actions to check.\r\n    /// @dev Only a single hat means that a user holding multiple hats might need to split their actions into one batch per hat.\r\n    function hasAccess(\r\n        uint256 _hat,\r\n        IDAO.Action[] calldata _actions\r\n    ) external view returns (bool);\r\n\r\n    /// @notice Executes a list of actions as the DAO.\r\n    /// @param _hat The hat to use for validations the actions are allowed.\r\n    /// @param _actions The actions to execute.\r\n    /// @param _failureMap Which actions are allowed to fail without reverting the whole transaction.\r\n    function asDAO(\r\n        uint256 _hat,\r\n        IDAO.Action[] calldata _actions,\r\n        uint256 _failureMap\r\n    ) external returns (bytes[] memory, uint256);\r\n\r\n    /// @notice Grants a hat the permission to do any action.\r\n    /// @param _hat The hat that is granted the permission.\r\n    function grantFullAccess(uint256 _hat) external;\r\n\r\n    /// @notice Grants a hat the permission to call all functions of one smart contract.\r\n    /// @param _hat The hat that is granted the permission.\r\n    /// @param _zone The address of the smart contract.\r\n    function grantFullZoneAccess(uint256 _hat, address _zone) external;\r\n\r\n    /// @notice Grants a hat the permission to call one function of one smart contract.\r\n    /// @param _hat The hat that is granted the permission.\r\n    /// @param _zone The address of the smart contract.\r\n    /// @param _function The function of the smart contract.\r\n    function grantFullFunctionAccess(\r\n        uint256 _hat,\r\n        address _zone,\r\n        bytes4 _function\r\n    ) external;\r\n\r\n    /// @notice Revokes a hat the permission to do any action.\r\n    /// @param _hat The hat that is granted the permission.\r\n    function revokeFullAccess(uint256 _hat) external;\r\n\r\n    /// @notice Revokes a hat the permission to call all functions of one smart contract.\r\n    /// @param _hat The hat that is granted the permission.\r\n    /// @param _zone The address of the smart contract.\r\n    function revokeFullZoneAccess(uint256 _hat, address _zone) external;\r\n\r\n    /// @notice Revokes a hat the permission to call one function of one smart contract.\r\n    /// @param _hat The hat that is granted the permission.\r\n    /// @param _zone The address of the smart contract.\r\n    /// @param _function The function of the smart contract.\r\n    function revokeFullFunctionAccess(\r\n        uint256 _hat,\r\n        address _zone,\r\n        bytes4 _function\r\n    ) external;\r\n}\r\n"
    },
    "contracts/DAO/SharedAddress/SharedAddress.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport {PluginUUPSUpgradeable} from \"@aragon/osx/core/plugin/PluginUUPSUpgradeable.sol\";\r\nimport {IHats} from \"../../Deps/hats-protocol/Interfaces/IHats.sol\";\r\nimport {ISharedAddress, IDAO, GRANT_ACCESS_PERMISSION_ID, REVOKE_ACCESS_PERMISSION_ID} from \"./ISharedAddress.sol\";\r\n\r\ncontract SharedAddress is PluginUUPSUpgradeable, ISharedAddress {\r\n    uint256 private daoNonce;\r\n    IHats private hats; // Should work for any ERC-1155 collection though\r\n    mapping(uint256 => bool) private fullAccess;\r\n    mapping(address => mapping(uint256 => bool)) private fullZoneAccess;\r\n    mapping(uint256 => mapping(uint256 => bool)) private fullFunctionAccess;\r\n\r\n    modifier wearingHat(uint256 _hat) {\r\n        if (hats.balanceOf(msg.sender, _hat) == 0) {\r\n            revert NotWearingHat();\r\n        }\r\n        _;\r\n    }\r\n\r\n    /// @notice Initialize the TaskDisputes plugin.\r\n    /// @param _dao The dao where this plugin is installed.\r\n    /// @param _hats The deployment of Hats Protocol to use.\r\n    function initialize(IDAO _dao, IHats _hats) external initializer {\r\n        __PluginUUPSUpgradeable_init(_dao);\r\n        hats = _hats;\r\n    }\r\n\r\n    /// @inheritdoc PluginUUPSUpgradeable\r\n    function supportsInterface(\r\n        bytes4 _interfaceId\r\n    ) public view virtual override returns (bool) {\r\n        return\r\n            _interfaceId == type(ISharedAddress).interfaceId ||\r\n            super.supportsInterface(_interfaceId);\r\n    }\r\n\r\n    /// @inheritdoc ISharedAddress\r\n    function hasAccess(\r\n        uint256 _hat,\r\n        IDAO.Action[] calldata _actions\r\n    ) public view returns (bool) {\r\n        if (!fullAccess[_hat]) {\r\n            for (uint i; i < _actions.length; ) {\r\n                if (!_hasAccess(_hat, _actions[i])) {\r\n                    return false;\r\n                }\r\n\r\n                unchecked {\r\n                    ++i;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /// @inheritdoc ISharedAddress\r\n    function asDAO(\r\n        uint256 _hat,\r\n        IDAO.Action[] calldata _actions,\r\n        uint256 _failureMap\r\n    )\r\n        external\r\n        wearingHat(_hat)\r\n        returns (bytes[] memory returnValueBytes, uint256 failureMap)\r\n    {\r\n        if (!hasAccess(_hat, _actions)) {\r\n            revert AccessDenied();\r\n        }\r\n\r\n        (returnValueBytes, failureMap) = dao().execute(\r\n            bytes32(daoNonce),\r\n            _actions,\r\n            _failureMap\r\n        );\r\n        emit Execution(daoNonce, msg.sender, _hat, _actions);\r\n        ++daoNonce;\r\n    }\r\n\r\n    /// @inheritdoc ISharedAddress\r\n    function grantFullAccess(\r\n        uint256 _hat\r\n    ) external auth(GRANT_ACCESS_PERMISSION_ID) {\r\n        fullAccess[_hat] = true;\r\n        emit FullAccessGranted(_hat);\r\n    }\r\n\r\n    /// @inheritdoc ISharedAddress\r\n    function grantFullZoneAccess(\r\n        uint256 _hat,\r\n        address _zone\r\n    ) external auth(GRANT_ACCESS_PERMISSION_ID) {\r\n        fullZoneAccess[_zone][_hat] = true;\r\n        emit FullZoneAccessGranted(_hat, _zone);\r\n    }\r\n\r\n    /// @inheritdoc ISharedAddress\r\n    function grantFullFunctionAccess(\r\n        uint256 _hat,\r\n        address _zone,\r\n        bytes4 _function\r\n    ) external auth(GRANT_ACCESS_PERMISSION_ID) {\r\n        fullFunctionAccess[_functionId(_zone, _function)][_hat] = true;\r\n        emit FullFunctionAccessGranted(_hat, _zone, _function);\r\n    }\r\n\r\n    /// @inheritdoc ISharedAddress\r\n    function revokeFullAccess(\r\n        uint256 _hat\r\n    ) external auth(REVOKE_ACCESS_PERMISSION_ID) {\r\n        fullAccess[_hat] = false;\r\n        emit FullAccessRevoked(_hat);\r\n    }\r\n\r\n    /// @inheritdoc ISharedAddress\r\n    function revokeFullZoneAccess(\r\n        uint256 _hat,\r\n        address _zone\r\n    ) external auth(REVOKE_ACCESS_PERMISSION_ID) {\r\n        fullZoneAccess[_zone][_hat] = false;\r\n        emit FullZoneAccessRevoked(_hat, _zone);\r\n    }\r\n\r\n    /// @inheritdoc ISharedAddress\r\n    function revokeFullFunctionAccess(\r\n        uint256 _hat,\r\n        address _zone,\r\n        bytes4 _function\r\n    ) external auth(REVOKE_ACCESS_PERMISSION_ID) {\r\n        fullFunctionAccess[_functionId(_zone, _function)][_hat] = false;\r\n        emit FullFunctionAccessRevoked(_hat, _zone, _function);\r\n    }\r\n\r\n    function _hasAccess(\r\n        uint256 _hat,\r\n        IDAO.Action calldata _action\r\n    ) internal view returns (bool) {\r\n        return\r\n            fullZoneAccess[_action.to][_hat] ||\r\n            fullFunctionAccess[_functionId(_action.to, bytes4(_action.data))][\r\n                _hat\r\n            ];\r\n    }\r\n\r\n    // address + function selector\r\n    function _functionId(\r\n        address _zone,\r\n        bytes4 _function\r\n    ) internal pure returns (uint256) {\r\n        return (uint160(bytes20(_zone)) << 32) + uint32(_function);\r\n    }\r\n\r\n    /// @dev This empty reserved space is put in place to allow future versions to add new\r\n    /// variables without shifting down storage in the inheritance chain.\r\n    /// https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\r\n    uint256[50] private __gap;\r\n}\r\n"
    },
    "contracts/DAO/TaskDisputes/ITaskDisputes.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport {ITasks} from \"../../Tasks/ITasks.sol\";\r\nimport {IPluginProposals} from \"../TokenListGovernance/IPluginProposals.sol\";\r\n\r\nbytes32 constant UPDATE_ADDRESSES_PERMISSION_ID = keccak256(\r\n    \"UPDATE_ADDRESSES_PERMISSION\"\r\n);\r\n\r\nbytes32 constant UPDATE_DISPUTE_COST_PERMISSION_ID = keccak256(\r\n    \"UPDATE_DISPUTE_COST_PERMISSION\"\r\n);\r\n\r\ninterface ITaskDisputes {\r\n    error Underpaying();\r\n    error TransferToDAOError();\r\n\r\n    /// @notice The minimum amount of native currency that has to be attached to create a dispute.\r\n    function getDisputeCost() external view returns (uint256);\r\n\r\n    /// @notice The Tasks contract where tasks are created.\r\n    function getTasksContract() external view returns (ITasks);\r\n\r\n    /// @notice The governance plugin (instance) contract where proposals are created.\r\n    function getGovernanceContract() external view returns (IPluginProposals);\r\n\r\n    /// @notice Updates the dispute cost.\r\n    /// @param _disputeCost The new dispute cost.\r\n    function updateDisputeCost(uint256 _disputeCost) external;\r\n\r\n    /// @notice Updates the tasks contract address.\r\n    /// @param _tasks The new Tasks contract address.\r\n    function updateTasksContract(ITasks _tasks) external;\r\n\r\n    /// @notice Updates the governance plugin contract address.\r\n    /// @param _governancePlugin The new governance plugin contract address.\r\n    function updateGovernanceContract(\r\n        IPluginProposals _governancePlugin\r\n    ) external;\r\n\r\n    /// @notice Create a dispute for a task\r\n    /// @param _metadata Metadata of the proposal.\r\n    /// @param _startDate Start date of the proposal.\r\n    /// @param _endDate End date of the proposal.\r\n    /// @param _taskId The task wanting to complete by dispute.\r\n    /// @param _partialReward Complete with how much of the reward.\r\n    /// @param _partialNativeReward Complete with how much of the native reward.\r\n    function createDispute(\r\n        bytes calldata _metadata,\r\n        uint64 _startDate,\r\n        uint64 _endDate,\r\n        uint256 _taskId,\r\n        uint88[] calldata _partialReward,\r\n        uint96[] calldata _partialNativeReward\r\n    ) external payable;\r\n}\r\n"
    },
    "contracts/DAO/TaskDisputes/TaskDisputes.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport {PluginUUPSUpgradeable, IDAO} from \"@aragon/osx/core/plugin/PluginUUPSUpgradeable.sol\";\r\n\r\nimport {ITaskDisputes, ITasks, IPluginProposals, UPDATE_ADDRESSES_PERMISSION_ID, UPDATE_DISPUTE_COST_PERMISSION_ID} from \"./ITaskDisputes.sol\";\r\n\r\ncontract TaskDisputes is PluginUUPSUpgradeable, ITaskDisputes {\r\n    ITasks private tasks;\r\n    IPluginProposals private governancePlugin;\r\n    uint256 private disputeCost;\r\n\r\n    /// @notice Initialize the TaskDisputes plugin.\r\n    /// @param _dao The dao where this plugin is installed.\r\n    /// @param _tasks The tasks contract to create tasks.\r\n    /// @param _governancePlugin The governance plugin contract to create proposals.\r\n    function initialize(\r\n        IDAO _dao,\r\n        ITasks _tasks,\r\n        IPluginProposals _governancePlugin,\r\n        uint256 _disputeCost\r\n    ) external initializer {\r\n        __PluginUUPSUpgradeable_init(_dao);\r\n        tasks = _tasks;\r\n        governancePlugin = _governancePlugin;\r\n        disputeCost = _disputeCost;\r\n    }\r\n\r\n    /// @inheritdoc PluginUUPSUpgradeable\r\n    function supportsInterface(\r\n        bytes4 _interfaceId\r\n    ) public view virtual override returns (bool) {\r\n        return\r\n            _interfaceId == type(ITaskDisputes).interfaceId ||\r\n            super.supportsInterface(_interfaceId);\r\n    }\r\n\r\n    /// @inheritdoc ITaskDisputes\r\n    function getDisputeCost() external view returns (uint256) {\r\n        return disputeCost;\r\n    }\r\n\r\n    /// @inheritdoc ITaskDisputes\r\n    function getTasksContract() external view returns (ITasks) {\r\n        return tasks;\r\n    }\r\n\r\n    /// @inheritdoc ITaskDisputes\r\n    function getGovernanceContract() external view returns (IPluginProposals) {\r\n        return governancePlugin;\r\n    }\r\n\r\n    /// @inheritdoc ITaskDisputes\r\n    function updateDisputeCost(\r\n        uint256 _disputeCost\r\n    ) external auth(UPDATE_DISPUTE_COST_PERMISSION_ID) {\r\n        disputeCost = _disputeCost;\r\n    }\r\n\r\n    /// @inheritdoc ITaskDisputes\r\n    function updateTasksContract(\r\n        ITasks _tasks\r\n    ) external auth(UPDATE_ADDRESSES_PERMISSION_ID) {\r\n        tasks = _tasks;\r\n    }\r\n\r\n    /// @inheritdoc ITaskDisputes\r\n    function updateGovernanceContract(\r\n        IPluginProposals _governancePlugin\r\n    ) external auth(UPDATE_ADDRESSES_PERMISSION_ID) {\r\n        governancePlugin = _governancePlugin;\r\n    }\r\n\r\n    /// @inheritdoc ITaskDisputes\r\n    function createDispute(\r\n        bytes calldata _metadata,\r\n        uint64 _startDate,\r\n        uint64 _endDate,\r\n        uint256 _taskId,\r\n        uint88[] calldata _partialReward,\r\n        uint96[] calldata _partialNativeReward\r\n    ) external payable {\r\n        // Dispute cost is required to make a dispute proposal. It is sent to the DAO.\r\n        if (msg.value < disputeCost) {\r\n            revert Underpaying();\r\n        }\r\n\r\n        // Normal address.transfer does not work with gas estimation\r\n        (bool succes, ) = address(dao()).call{value: msg.value}(\"\");\r\n        if (!succes) {\r\n            revert TransferToDAOError();\r\n        }\r\n\r\n        IDAO.Action[] memory actions = new IDAO.Action[](1);\r\n        {\r\n            bytes memory callData = abi.encodeWithSelector(\r\n                tasks.completeByDispute.selector,\r\n                _taskId,\r\n                _partialReward,\r\n                _partialNativeReward\r\n            );\r\n            actions[0] = IDAO.Action(address(tasks), 0, callData);\r\n        }\r\n\r\n        governancePlugin.createPluginProposal(\r\n            _metadata,\r\n            actions,\r\n            0,\r\n            _startDate,\r\n            _endDate\r\n        );\r\n    }\r\n\r\n    /// @dev This empty reserved space is put in place to allow future versions to add new\r\n    /// variables without shifting down storage in the inheritance chain.\r\n    /// https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\r\n    uint256[50] private __gap;\r\n}\r\n"
    },
    "contracts/DAO/TaskDrafts/ITaskDrafts.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport {ITasks} from \"../../Tasks/ITasks.sol\";\r\nimport {IPluginProposals} from \"../TokenListGovernance/IPluginProposals.sol\";\r\n\r\nbytes32 constant UPDATE_ADDRESSES_PERMISSION_ID = keccak256(\r\n    \"UPDATE_ADDRESSES_PERMISSION\"\r\n);\r\n\r\ninterface ITaskDrafts {\r\n    event TaskDraftCreated(\r\n        uint256 proposalId,\r\n        bytes metadata,\r\n        uint64 startDate,\r\n        uint64 endDate,\r\n        CreateTaskInfo taskInfo\r\n    );\r\n\r\n    struct CreateTaskInfo {\r\n        string metadata;\r\n        uint64 deadline;\r\n        ITasks.ERC20Transfer[] budget;\r\n        address manager;\r\n        ITasks.PreapprovedApplication[] preapproved;\r\n    }\r\n\r\n    /// @notice The Tasks contract where tasks are created.\r\n    function getTasksContract() external view returns (ITasks);\r\n\r\n    /// @notice The governance plugin (instance) contract where proposals are created.\r\n    function getGovernanceContract() external view returns (IPluginProposals);\r\n\r\n    /// @notice Updates the tasks contract address.\r\n    /// @param _tasks The new Tasks contract address.\r\n    function updateTasksContract(ITasks _tasks) external;\r\n\r\n    /// @notice Updates the governance plugin contract address.\r\n    /// @param _governancePlugin The new governance plugin contract address.\r\n    function updateGovernanceContract(\r\n        IPluginProposals _governancePlugin\r\n    ) external;\r\n\r\n    /// @notice Create a proposal to create a task.\r\n    /// @param _metadata The metadata of the proposal.\r\n    /// @param _startDate The start date of the proposal.\r\n    /// @param _endDate The end date of the proposal.\r\n    /// @param _taskInfo The task to be created if the proposal passes.\r\n    function createDraftTask(\r\n        bytes calldata _metadata,\r\n        uint64 _startDate,\r\n        uint64 _endDate,\r\n        CreateTaskInfo calldata _taskInfo\r\n    ) external;\r\n}\r\n"
    },
    "contracts/DAO/TaskDrafts/TaskDrafts.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\r\nimport {PluginUUPSUpgradeable, IDAO} from \"@aragon/osx/core/plugin/PluginUUPSUpgradeable.sol\";\r\n\r\nimport {ITaskDrafts, ITasks, IPluginProposals, UPDATE_ADDRESSES_PERMISSION_ID} from \"./ITaskDrafts.sol\";\r\n\r\ncontract TaskDrafts is Initializable, PluginUUPSUpgradeable, ITaskDrafts {\r\n    ITasks private tasks;\r\n    IPluginProposals private governancePlugin;\r\n\r\n    /// @notice Initialize the TaskDrafts plugin.\r\n    /// @param _dao The dao where this plugin is installed.\r\n    /// @param _tasks The tasks contract to create tasks.\r\n    /// @param _governancePlugin The governance plugin contract to create proposals.\r\n    function initialize(\r\n        IDAO _dao,\r\n        ITasks _tasks,\r\n        IPluginProposals _governancePlugin\r\n    ) external initializer {\r\n        __PluginUUPSUpgradeable_init(_dao);\r\n        tasks = _tasks;\r\n        governancePlugin = _governancePlugin;\r\n    }\r\n\r\n    /// @inheritdoc PluginUUPSUpgradeable\r\n    function supportsInterface(\r\n        bytes4 _interfaceId\r\n    ) public view virtual override returns (bool) {\r\n        return\r\n            _interfaceId == type(ITaskDrafts).interfaceId ||\r\n            super.supportsInterface(_interfaceId);\r\n    }\r\n\r\n    /// @inheritdoc ITaskDrafts\r\n    function getTasksContract() external view returns (ITasks) {\r\n        return tasks;\r\n    }\r\n\r\n    /// @inheritdoc ITaskDrafts\r\n    function getGovernanceContract() external view returns (IPluginProposals) {\r\n        return governancePlugin;\r\n    }\r\n\r\n    /// @inheritdoc ITaskDrafts\r\n    function updateTasksContract(\r\n        ITasks _tasks\r\n    ) external auth(UPDATE_ADDRESSES_PERMISSION_ID) {\r\n        tasks = _tasks;\r\n    }\r\n\r\n    /// @inheritdoc ITaskDrafts\r\n    function updateGovernanceContract(\r\n        IPluginProposals _governancePlugin\r\n    ) external auth(UPDATE_ADDRESSES_PERMISSION_ID) {\r\n        governancePlugin = _governancePlugin;\r\n    }\r\n\r\n    /// @inheritdoc ITaskDrafts\r\n    function createDraftTask(\r\n        bytes calldata _metadata,\r\n        uint64 _startDate,\r\n        uint64 _endDate,\r\n        CreateTaskInfo calldata _taskInfo\r\n    ) external {\r\n        // Could also add approve ERC20's of budget here\r\n        // Currently the DAO should approve select ERC20's in advance (once) for unlimited spending\r\n\r\n        IDAO.Action[] memory actions = new IDAO.Action[](1);\r\n        {\r\n            bytes memory callData = abi.encodeWithSelector(\r\n                tasks.createTask.selector,\r\n                _taskInfo.metadata,\r\n                _taskInfo.deadline,\r\n                _taskInfo.budget,\r\n                _taskInfo.manager,\r\n                _taskInfo.preapproved\r\n            );\r\n            actions[0] = IDAO.Action(address(tasks), 0, callData);\r\n        }\r\n\r\n        uint256 _proposalId = governancePlugin.createPluginProposal(\r\n            _metadata,\r\n            actions,\r\n            0,\r\n            _startDate,\r\n            _endDate\r\n        );\r\n\r\n        emit TaskDraftCreated(\r\n            _proposalId,\r\n            _metadata,\r\n            _startDate,\r\n            _endDate,\r\n            _taskInfo\r\n        );\r\n    }\r\n\r\n    /// @dev This empty reserved space is put in place to allow future versions to add new\r\n    /// variables without shifting down storage in the inheritance chain.\r\n    /// https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\r\n    uint256[50] private __gap;\r\n}\r\n"
    },
    "contracts/DAO/TokenListGovernance/IPluginProposals.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport {IDAO} from \"@aragon/osx/core/dao/IDAO.sol\";\r\n\r\nbytes32 constant PLUGIN_PROPOSAL_PERMISSION_ID = keccak256(\r\n    \"PLUGIN_PROPOSAL_PERMISSION\"\r\n);\r\n\r\ninterface IPluginProposals {\r\n    /// @notice Allows other plugins to create proposals\r\n    /// @param _metadata The proposal metadata.\r\n    /// @param _actions The proposal actions.\r\n    /// @param _allowFailureMap The proposal failure map.\r\n    /// @param _startDate The proposal start date.\r\n    /// @param _endDate The proposal end date.\r\n    /// @return proposalId The id of the created proposal.\r\n    function createPluginProposal(\r\n        bytes calldata _metadata,\r\n        IDAO.Action[] calldata _actions,\r\n        uint256 _allowFailureMap,\r\n        uint64 _startDate,\r\n        uint64 _endDate\r\n    ) external returns (uint256 proposalId);\r\n}\r\n"
    },
    "contracts/DAO/TokenListGovernance/ITokenListGovernance.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface ITokenListGovernance {\r\n    /// @notice Adds new members to the token list.\r\n    /// @param _members The Members of members to be added.\r\n    /// @dev This function is used during the plugin initialization.\r\n    function addMembers(uint256[] calldata _members) external;\r\n\r\n    /// @notice Removes existing members from the token list.\r\n    /// @param _members The Members of the members to be removed.\r\n    function removeMembers(uint256[] calldata _members) external;\r\n}\r\n"
    },
    "contracts/DAO/TokenListGovernance/TokenList.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport {CheckpointsUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/CheckpointsUpgradeable.sol\";\r\n\r\nimport {_uncheckedAdd, _uncheckedSub} from \"@aragon/osx/utils/UncheckedMath.sol\";\r\n\r\n// Based on https://github.com/aragon/osx/blob/develop/packages/contracts/src/plugins/utils/Addresslist.sol\r\nabstract contract TokenList {\r\n    using CheckpointsUpgradeable for CheckpointsUpgradeable.History;\r\n\r\n    event TokensAdded(uint256[] tokens);\r\n    event TokensRemoved(uint256[] tokens);\r\n\r\n    /// @notice The mapping containing the checkpointed history of the token list.\r\n    mapping(uint256 => CheckpointsUpgradeable.History)\r\n        private _tokenlistCheckpoints;\r\n\r\n    /// @notice The checkpointed history of the length of the address list.\r\n    CheckpointsUpgradeable.History private _tokenlistLengthCheckpoints;\r\n\r\n    /// @notice Thrown when the token list update is invalid, which can be caused by the addition of an existing tokenId or removal of a non-existing tokenId.\r\n    /// @param tokenId The first invalid tokenId.\r\n    error InvalidTokenlistUpdate(uint256 tokenId);\r\n\r\n    /// @notice Checks if a tokenId is on the address list at a specific block number.\r\n    /// @param _tokenId The tokenId being checked.\r\n    /// @param _blockNumber The block number.\r\n    /// @return Whether the tokenId is listed at the specified block number.\r\n    function isListedAtBlock(\r\n        uint256 _tokenId,\r\n        uint256 _blockNumber\r\n    ) public view virtual returns (bool) {\r\n        return _tokenlistCheckpoints[_tokenId].getAtBlock(_blockNumber) == 1;\r\n    }\r\n\r\n    /// @notice Checks if a tokenId is currently on the address list.\r\n    /// @param _tokenId The tokenId being checked.\r\n    /// @return Whether the tokenId is currently listed.\r\n    function isListed(uint256 _tokenId) public view virtual returns (bool) {\r\n        return _tokenlistCheckpoints[_tokenId].latest() == 1;\r\n    }\r\n\r\n    /// @notice Returns the length of the token list at a specific block number.\r\n    /// @param _blockNumber The specific block to get the count from. If `0`, then the latest checkpoint value is returned.\r\n    /// @return The token list length at the specified block number.\r\n    function tokenlistLengthAtBlock(\r\n        uint256 _blockNumber\r\n    ) public view virtual returns (uint256) {\r\n        return _tokenlistLengthCheckpoints.getAtBlock(_blockNumber);\r\n    }\r\n\r\n    /// @notice Returns the current length of the token list.\r\n    /// @return The current token list length.\r\n    function tokenlistLength() public view virtual returns (uint256) {\r\n        return _tokenlistLengthCheckpoints.latest();\r\n    }\r\n\r\n    /// @notice Internal function to add new tokens to the token list.\r\n    /// @param _newTokens The new tokens to be added.\r\n    function _addTokens(uint256[] calldata _newTokens) internal virtual {\r\n        for (uint256 i; i < _newTokens.length; ) {\r\n            if (isListed(_newTokens[i])) {\r\n                revert InvalidTokenlistUpdate(_newTokens[i]);\r\n            }\r\n\r\n            // Mark the address as listed\r\n            _tokenlistCheckpoints[_newTokens[i]].push(1);\r\n\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n        _tokenlistLengthCheckpoints.push(_uncheckedAdd, _newTokens.length);\r\n\r\n        emit TokensAdded(_newTokens);\r\n    }\r\n\r\n    /// @notice Internal function to remove existing tokens from the token list.\r\n    /// @param _exitingTokens The existing tokens to be removed.\r\n    function _removeTokens(uint256[] calldata _exitingTokens) internal virtual {\r\n        for (uint256 i; i < _exitingTokens.length; ) {\r\n            if (!isListed(_exitingTokens[i])) {\r\n                revert InvalidTokenlistUpdate(_exitingTokens[i]);\r\n            }\r\n\r\n            // Mark the address as not listed\r\n            _tokenlistCheckpoints[_exitingTokens[i]].push(0);\r\n\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n        _tokenlistLengthCheckpoints.push(_uncheckedSub, _exitingTokens.length);\r\n\r\n        emit TokensRemoved(_exitingTokens);\r\n    }\r\n\r\n    /// @dev This empty reserved space is put in place to allow future versions to add new\r\n    /// variables without shifting down storage in the inheritance chain.\r\n    /// https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\r\n    uint256[50] private __gap;\r\n}\r\n"
    },
    "contracts/DAO/TokenListGovernance/TokenListGovernance.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport {SafeCastUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\r\nimport {RATIO_BASE, _applyRatioCeiled} from \"@aragon/osx/plugins/utils/Ratio.sol\";\r\nimport {TokenList} from \"./TokenList.sol\";\r\n\r\nimport {TokenMajorityVotingBase, IDAO, IERC721} from \"../TokenMajorityVoting/TokenMajorityVotingBase.sol\";\r\nimport {ITokenMembership} from \"../TokenMembership/ITokenMembership.sol\";\r\nimport {ITokenListGovernance} from \"./ITokenListGovernance.sol\";\r\nimport {IPluginProposals, PLUGIN_PROPOSAL_PERMISSION_ID} from \"./IPluginProposals.sol\";\r\n\r\n// Based on https://github.com/aragon/osx/blob/develop/packages/contracts/src/plugins/governance/majority-voting/addresslist/AddresslistVoting.sol\r\ncontract TokenListGovernance is\r\n    TokenMajorityVotingBase,\r\n    TokenList,\r\n    ITokenMembership,\r\n    ITokenListGovernance,\r\n    IPluginProposals\r\n{\r\n    using SafeCastUpgradeable for uint256;\r\n\r\n    /// @notice The ID of the permission required to call the `addMembers` and `removeMembers` functions.\r\n    bytes32 public constant UPDATE_MEMBERS_PERMISSION_ID =\r\n        keccak256(\"UPDATE_MEMBERS_PERMISSION\");\r\n\r\n    /// @notice Initializes the component.\r\n    /// @dev This method is required to support [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822).\r\n    /// @param _dao The IDAO interface of the associated DAO.\r\n    /// @param _votingSettings The voting settings.\r\n    /// @param _tokenCollection The ERC721 contract that defines who has what token.\r\n    /// @param _members Initial members of the DAO.\r\n    function initialize(\r\n        IDAO _dao,\r\n        VotingSettings calldata _votingSettings,\r\n        IERC721 _tokenCollection,\r\n        uint256[] calldata _members\r\n    ) external initializer {\r\n        __TokenMajorityVotingBase_init(_dao, _votingSettings, _tokenCollection);\r\n\r\n        _addTokens(_members);\r\n    }\r\n\r\n    /// @notice Checks if this or the parent contract supports an interface by its ID.\r\n    /// @param _interfaceId The ID of the interface.\r\n    /// @return Returns `true` if the interface is supported.\r\n    function supportsInterface(\r\n        bytes4 _interfaceId\r\n    ) public view virtual override returns (bool) {\r\n        return\r\n            _interfaceId == type(ITokenListGovernance).interfaceId ||\r\n            super.supportsInterface(_interfaceId);\r\n    }\r\n\r\n    /// @inheritdoc ITokenListGovernance\r\n    function addMembers(\r\n        uint256[] calldata _members\r\n    ) external auth(UPDATE_MEMBERS_PERMISSION_ID) {\r\n        _addTokens(_members);\r\n    }\r\n\r\n    /// @inheritdoc ITokenListGovernance\r\n    function removeMembers(\r\n        uint256[] calldata _members\r\n    ) external auth(UPDATE_MEMBERS_PERMISSION_ID) {\r\n        _removeTokens(_members);\r\n    }\r\n\r\n    /// @inheritdoc TokenMajorityVotingBase\r\n    function totalVotingPower(\r\n        uint256 _blockNumber\r\n    ) public view override returns (uint256) {\r\n        return tokenlistLengthAtBlock(_blockNumber);\r\n    }\r\n\r\n    /// @inheritdoc IPluginProposals\r\n    function createPluginProposal(\r\n        bytes calldata _metadata,\r\n        IDAO.Action[] calldata _actions,\r\n        uint256 _allowFailureMap,\r\n        uint64 _startDate,\r\n        uint64 _endDate\r\n    )\r\n        external\r\n        auth(PLUGIN_PROPOSAL_PERMISSION_ID)\r\n        returns (uint256 proposalId)\r\n    {\r\n        proposalId = _createProposalBase(\r\n            _metadata,\r\n            _actions,\r\n            _allowFailureMap,\r\n            _startDate,\r\n            _endDate\r\n        );\r\n    }\r\n\r\n    /// @inheritdoc TokenMajorityVotingBase\r\n    function createProposal(\r\n        bytes calldata _metadata,\r\n        IDAO.Action[] calldata _actions,\r\n        uint256 _allowFailureMap,\r\n        uint64 _startDate,\r\n        uint64 _endDate,\r\n        VoteOption _voteOption,\r\n        bool _tryEarlyExecution,\r\n        uint256 _tokenId\r\n    ) external override returns (uint256 proposalId) {\r\n        if (tokenCollection.ownerOf(_tokenId) != _msgSender()) {\r\n            revert TokenNotOwnedBySender(_tokenId, _msgSender());\r\n        }\r\n\r\n        if (minProposerVotingPower() != 0 && !isListed(_tokenId)) {\r\n            revert ProposalCreationForbidden(_tokenId);\r\n        }\r\n\r\n        proposalId = _createProposalBase(\r\n            _metadata,\r\n            _actions,\r\n            _allowFailureMap,\r\n            _startDate,\r\n            _endDate\r\n        );\r\n\r\n        if (_voteOption != VoteOption.None) {\r\n            vote(proposalId, _voteOption, _tryEarlyExecution, _tokenId);\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc ITokenMembership\r\n    function isMember(uint256 _account) external view override returns (bool) {\r\n        return isListed(_account);\r\n    }\r\n\r\n    function _createProposalBase(\r\n        bytes calldata _metadata,\r\n        IDAO.Action[] calldata _actions,\r\n        uint256 _allowFailureMap,\r\n        uint64 _startDate,\r\n        uint64 _endDate\r\n    ) internal returns (uint256 proposalId) {\r\n        uint64 snapshotBlock;\r\n        unchecked {\r\n            snapshotBlock = block.number.toUint64() - 1; // The snapshot block must be mined already to protect the transaction against backrunning transactions causing census changes.\r\n        }\r\n\r\n        (_startDate, _endDate) = _validateProposalDates(_startDate, _endDate);\r\n\r\n        proposalId = _createProposal({\r\n            _creator: _msgSender(),\r\n            _metadata: _metadata,\r\n            _startDate: _startDate,\r\n            _endDate: _endDate,\r\n            _actions: _actions,\r\n            _allowFailureMap: _allowFailureMap\r\n        });\r\n\r\n        // Store proposal related information\r\n        Proposal storage proposal_ = proposals[proposalId];\r\n\r\n        proposal_.parameters.startDate = _startDate;\r\n        proposal_.parameters.endDate = _endDate;\r\n        proposal_.parameters.snapshotBlock = snapshotBlock;\r\n        proposal_.parameters.votingMode = votingMode();\r\n        proposal_.parameters.supportThreshold = supportThreshold();\r\n        proposal_.parameters.minVotingPower = _applyRatioCeiled(\r\n            totalVotingPower(snapshotBlock),\r\n            minParticipation()\r\n        );\r\n\r\n        // Reduce costs\r\n        if (_allowFailureMap != 0) {\r\n            proposal_.allowFailureMap = _allowFailureMap;\r\n        }\r\n\r\n        for (uint256 i; i < _actions.length; ) {\r\n            proposal_.actions.push(_actions[i]);\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc TokenMajorityVotingBase\r\n    function _vote(\r\n        uint256 _proposalId,\r\n        VoteOption _voteOption,\r\n        uint256 _voter,\r\n        bool _tryEarlyExecution\r\n    ) internal override {\r\n        Proposal storage proposal_ = proposals[_proposalId];\r\n\r\n        VoteOption state = proposal_.voters[_voter];\r\n\r\n        // Remove the previous vote.\r\n        if (state == VoteOption.Yes) {\r\n            proposal_.tally.yes = proposal_.tally.yes - 1;\r\n        } else if (state == VoteOption.No) {\r\n            proposal_.tally.no = proposal_.tally.no - 1;\r\n        } else if (state == VoteOption.Abstain) {\r\n            proposal_.tally.abstain = proposal_.tally.abstain - 1;\r\n        }\r\n\r\n        // Store the updated/new vote for the voter.\r\n        if (_voteOption == VoteOption.Yes) {\r\n            proposal_.tally.yes = proposal_.tally.yes + 1;\r\n        } else if (_voteOption == VoteOption.No) {\r\n            proposal_.tally.no = proposal_.tally.no + 1;\r\n        } else if (_voteOption == VoteOption.Abstain) {\r\n            proposal_.tally.abstain = proposal_.tally.abstain + 1;\r\n        }\r\n\r\n        proposal_.voters[_voter] = _voteOption;\r\n\r\n        emit VoteCast({\r\n            proposalId: _proposalId,\r\n            voter: _voter,\r\n            voteOption: _voteOption,\r\n            votingPower: 1\r\n        });\r\n\r\n        if (_tryEarlyExecution && _canExecute(_proposalId)) {\r\n            _execute(_proposalId);\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc TokenMajorityVotingBase\r\n    function _canVote(\r\n        uint256 _proposalId,\r\n        uint256 _account,\r\n        VoteOption _voteOption\r\n    ) internal view override returns (bool) {\r\n        Proposal storage proposal_ = proposals[_proposalId];\r\n\r\n        // The proposal vote hasn't started or has already ended.\r\n        if (!_isProposalOpen(proposal_)) {\r\n            return false;\r\n        }\r\n\r\n        // The voter votes `None` which is not allowed.\r\n        if (_voteOption == VoteOption.None) {\r\n            return false;\r\n        }\r\n\r\n        // The voter has no voting power.\r\n        if (!isListedAtBlock(_account, proposal_.parameters.snapshotBlock)) {\r\n            return false;\r\n        }\r\n\r\n        // The voter has already voted but vote replacement is not allowed.\r\n        if (\r\n            proposal_.voters[_account] != VoteOption.None &&\r\n            proposal_.parameters.votingMode != VotingMode.VoteReplacement\r\n        ) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @dev This empty reserved space is put in place to allow future versions to add new\r\n    /// variables without shifting down storage in the inheritance chain.\r\n    /// https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\r\n    uint256[50] private __gap;\r\n}\r\n"
    },
    "contracts/DAO/TokenMajorityVoting/ITokenMajorityVoting.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport {IDAO} from \"@aragon/osx/core/dao/IDAO.sol\";\r\n\r\ninterface ITokenMajorityVoting {\r\n    /// @notice Vote options that a voter can chose from.\r\n    /// @param None The default option state of a voter indicating the absence from the vote. This option neither influences support nor participation.\r\n    /// @param Abstain This option does not influence the support but counts towards participation.\r\n    /// @param Yes This option increases the support and counts towards participation.\r\n    /// @param No This option decreases the support and counts towards participation.\r\n    enum VoteOption {\r\n        None,\r\n        Abstain,\r\n        Yes,\r\n        No\r\n    }\r\n\r\n    /// @notice Emitted when a vote is cast by a voter.\r\n    /// @param proposalId The ID of the proposal.\r\n    /// @param voter The voter casting the vote.\r\n    /// @param voteOption The casted vote option.\r\n    /// @param votingPower The voting power behind this vote.\r\n    event VoteCast(\r\n        uint256 indexed proposalId,\r\n        uint256 indexed voter,\r\n        VoteOption voteOption,\r\n        uint256 votingPower\r\n    );\r\n\r\n    /// @notice Returns the support threshold parameter stored in the voting settings.\r\n    /// @return The support threshold parameter.\r\n    function supportThreshold() external view returns (uint32);\r\n\r\n    /// @notice Returns the minimum participation parameter stored in the voting settings.\r\n    /// @return The minimum participation parameter.\r\n    function minParticipation() external view returns (uint32);\r\n\r\n    /// @notice Checks if the support value defined as $$\\texttt{support} = \\frac{N_\\text{yes}}{N_\\text{yes}+N_\\text{no}}$$ for a proposal vote is greater than the support threshold.\r\n    /// @param _proposalId The ID of the proposal.\r\n    /// @return Returns `true` if the  support is greater than the support threshold and `false` otherwise.\r\n    function isSupportThresholdReached(\r\n        uint256 _proposalId\r\n    ) external view returns (bool);\r\n\r\n    /// @notice Checks if the worst-case support value defined as $$\\texttt{worstCaseSupport} = \\frac{N_\\text{yes}}{ N_\\text{total}-N_\\text{abstain}}$$ for a proposal vote is greater than the support threshold.\r\n    /// @param _proposalId The ID of the proposal.\r\n    /// @return Returns `true` if the worst-case support is greater than the support threshold and `false` otherwise.\r\n    function isSupportThresholdReachedEarly(\r\n        uint256 _proposalId\r\n    ) external view returns (bool);\r\n\r\n    /// @notice Checks if the participation value defined as $$\\texttt{participation} = \\frac{N_\\text{yes}+N_\\text{no}+N_\\text{abstain}}{N_\\text{total}}$$ for a proposal vote is greater or equal than the minimum participation value.\r\n    /// @param _proposalId The ID of the proposal.\r\n    /// @return Returns `true` if the participation is greater than the minimum participation and `false` otherwise.\r\n    function isMinParticipationReached(\r\n        uint256 _proposalId\r\n    ) external view returns (bool);\r\n\r\n    /// @notice Checks if an account can participate on a proposal vote. This can be because the vote\r\n    /// - has not started,\r\n    /// - has ended,\r\n    /// - was executed, or\r\n    /// - the voter doesn't have voting powers.\r\n    /// @param _proposalId The proposal Id.\r\n    /// @param _account The account tokenId to be checked.\r\n    /// @param  _voteOption Whether the voter abstains, supports or opposes the proposal.\r\n    /// @return Returns true if the account is allowed to vote.\r\n    /// @dev The function assumes the queried proposal exists.\r\n    function canVote(\r\n        uint256 _proposalId,\r\n        uint256 _account,\r\n        VoteOption _voteOption\r\n    ) external view returns (bool);\r\n\r\n    /// @notice Checks if a proposal can be executed.\r\n    /// @param _proposalId The ID of the proposal to be checked.\r\n    /// @return True if the proposal can be executed, false otherwise.\r\n    function canExecute(uint256 _proposalId) external view returns (bool);\r\n\r\n    /// @notice Votes for a vote option and, optionally, executes the proposal.\r\n    /// @dev `_voteOption`, 1 -> abstain, 2 -> yes, 3 -> no\r\n    /// @param _proposalId The ID of the proposal.\r\n    /// @param _voteOption The chosen vote option.\r\n    /// @param _tryEarlyExecution If `true`,  early execution is tried after the vote cast. The call does not revert if early execution is not possible.\r\n    /// @param _tokenId TokenId to use for this vote.\r\n    function vote(\r\n        uint256 _proposalId,\r\n        VoteOption _voteOption,\r\n        bool _tryEarlyExecution,\r\n        uint256 _tokenId\r\n    ) external;\r\n\r\n    /// @notice Executes a proposal.\r\n    /// @param _proposalId The ID of the proposal to be executed.\r\n    function execute(uint256 _proposalId) external;\r\n\r\n    /// @notice Returns whether the account has voted for the proposal.  Note, that this does not check if the account has voting power.\r\n    /// @param _proposalId The ID of the proposal.\r\n    /// @param _account The account tokenId to be checked.\r\n    /// @return The vote option cast by a voter for a certain proposal.\r\n    function getVoteOption(\r\n        uint256 _proposalId,\r\n        uint256 _account\r\n    ) external view returns (VoteOption);\r\n}\r\n"
    },
    "contracts/DAO/TokenMajorityVoting/TokenMajorityVotingBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport {ERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\r\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\r\nimport {SafeCastUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\r\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\r\n\r\nimport {IProposal} from \"@aragon/osx/core/plugin/proposal/IProposal.sol\";\r\nimport {ProposalUpgradeable} from \"@aragon/osx/core/plugin/proposal/ProposalUpgradeable.sol\";\r\nimport {PluginUUPSUpgradeable} from \"@aragon/osx/core/plugin/PluginUUPSUpgradeable.sol\";\r\nimport {IDAO} from \"@aragon/osx/core/dao/IDAO.sol\";\r\nimport {RATIO_BASE, RatioOutOfBounds} from \"@aragon/osx/plugins/utils/Ratio.sol\";\r\nimport {ITokenMajorityVoting} from \"./ITokenMajorityVoting.sol\";\r\n\r\n// Based on packages/contracts/src/plugins/governance/majority-voting/MajorityVotingBase.sol\r\nabstract contract TokenMajorityVotingBase is\r\n    ITokenMajorityVoting,\r\n    Initializable,\r\n    ERC165Upgradeable,\r\n    PluginUUPSUpgradeable,\r\n    ProposalUpgradeable\r\n{\r\n    using SafeCastUpgradeable for uint256;\r\n\r\n    /// @notice The different voting modes available.\r\n    /// @param Standard In standard mode, early execution and vote replacement are disabled.\r\n    /// @param EarlyExecution In early execution mode, a proposal can be executed early before the end date if the vote outcome cannot mathematically change by more voters voting.\r\n    /// @param VoteReplacement In vote replacement mode, voters can change their vote multiple times and only the latest vote option is tallied.\r\n    enum VotingMode {\r\n        Standard,\r\n        EarlyExecution,\r\n        VoteReplacement\r\n    }\r\n\r\n    /// @notice A container for the majority voting settings that will be applied as parameters on proposal creation.\r\n    /// @param votingMode A parameter to select the vote mode. In standard mode (0), early execution and vote replacement are disabled. In early execution mode (1), a proposal can be executed early before the end date if the vote outcome cannot mathematically change by more voters voting. In vote replacement mode (2), voters can change their vote multiple times and only the latest vote option is tallied.\r\n    /// @param supportThreshold The support threshold value. Its value has to be in the interval [0, 10^6] defined by `RATIO_BASE = 10**6`.\r\n    /// @param minParticipation The minimum participation value. Its value has to be in the interval [0, 10^6] defined by `RATIO_BASE = 10**6`.\r\n    /// @param minDuration The minimum duration of the proposal vote in seconds.\r\n    /// @param minProposerVotingPower The minimum voting power required to create a proposal.\r\n    struct VotingSettings {\r\n        VotingMode votingMode;\r\n        uint32 supportThreshold;\r\n        uint32 minParticipation;\r\n        uint64 minDuration;\r\n        uint256 minProposerVotingPower;\r\n    }\r\n\r\n    /// @notice A container for proposal-related information.\r\n    /// @param executed Whether the proposal is executed or not.\r\n    /// @param parameters The proposal parameters at the time of the proposal creation.\r\n    /// @param tally The vote tally of the proposal.\r\n    /// @param voters The votes casted by the voters.\r\n    /// @param actions The actions to be executed when the proposal passes.\r\n    /// @param allowFailureMap A bitmap allowing the proposal to succeed, even if individual actions might revert. If the bit at index `i` is 1, the proposal succeeds even if the `i`th action reverts. A failure map value of 0 requires every action to not revert.\r\n    struct Proposal {\r\n        bool executed;\r\n        ProposalParameters parameters;\r\n        Tally tally;\r\n        mapping(uint256 => ITokenMajorityVoting.VoteOption) voters;\r\n        IDAO.Action[] actions;\r\n        uint256 allowFailureMap;\r\n    }\r\n\r\n    /// @notice A container for the proposal parameters at the time of proposal creation.\r\n    /// @param votingMode A parameter to select the vote mode.\r\n    /// @param supportThreshold The support threshold value. The value has to be in the interval [0, 10^6] defined by `RATIO_BASE = 10**6`.\r\n    /// @param startDate The start date of the proposal vote.\r\n    /// @param endDate The end date of the proposal vote.\r\n    /// @param snapshotBlock The number of the block prior to the proposal creation.\r\n    /// @param minVotingPower The minimum voting power needed.\r\n    struct ProposalParameters {\r\n        VotingMode votingMode;\r\n        uint32 supportThreshold;\r\n        uint64 startDate;\r\n        uint64 endDate;\r\n        uint64 snapshotBlock;\r\n        uint256 minVotingPower;\r\n    }\r\n\r\n    /// @notice A container for the proposal vote tally.\r\n    /// @param abstain The number of abstain votes casted.\r\n    /// @param yes The number of yes votes casted.\r\n    /// @param no The number of no votes casted.\r\n    struct Tally {\r\n        uint256 abstain;\r\n        uint256 yes;\r\n        uint256 no;\r\n    }\r\n\r\n    /// @notice The [ERC-165](https://eips.ethereum.org/EIPS/eip-165) interface ID of the contract.\r\n    bytes4 internal constant MAJORITY_VOTING_BASE_INTERFACE_ID =\r\n        this.minDuration.selector ^\r\n            this.minProposerVotingPower.selector ^\r\n            this.votingMode.selector ^\r\n            this.totalVotingPower.selector ^\r\n            this.getProposal.selector ^\r\n            this.updateVotingSettings.selector ^\r\n            this.createProposal.selector;\r\n\r\n    /// @notice The ID of the permission required to call the `updateVotingSettings` function.\r\n    bytes32 public constant UPDATE_VOTING_SETTINGS_PERMISSION_ID =\r\n        keccak256(\"UPDATE_VOTING_SETTINGS_PERMISSION\");\r\n\r\n    /// @notice A mapping between proposal IDs and proposal information.\r\n    mapping(uint256 => Proposal) internal proposals;\r\n\r\n    /// @notice The struct storing the voting settings.\r\n    VotingSettings private votingSettings;\r\n\r\n    /// @notice the NFT collections the tokens belong to.\r\n    IERC721 internal tokenCollection;\r\n\r\n    /// @notice Thrown if a date is out of bounds.\r\n    /// @param limit The limit value.\r\n    /// @param actual The actual value.\r\n    error DateOutOfBounds(uint64 limit, uint64 actual);\r\n\r\n    /// @notice Thrown if the minimal duration value is out of bounds (less than one hour or greater than 1 year).\r\n    /// @param limit The limit value.\r\n    /// @param actual The actual value.\r\n    error MinDurationOutOfBounds(uint64 limit, uint64 actual);\r\n\r\n    /// @notice Thrown when a sender is not allowed to create a proposal.\r\n    /// @param sender The sender tokenId.\r\n    error ProposalCreationForbidden(uint256 sender);\r\n\r\n    /// @notice Thrown if an account is not allowed to cast a vote. This can be because the vote\r\n    /// - has not started,\r\n    /// - has ended,\r\n    /// - was executed, or\r\n    /// - the account doesn't have voting powers.\r\n    /// @param proposalId The ID of the proposal.\r\n    /// @param account The tokenId of the _account.\r\n    /// @param voteOption The chosen vote option.\r\n    error VoteCastForbidden(\r\n        uint256 proposalId,\r\n        uint256 account,\r\n        VoteOption voteOption\r\n    );\r\n\r\n    /// @notice Thrown if the proposal execution is forbidden.\r\n    /// @param proposalId The ID of the proposal.\r\n    error ProposalExecutionForbidden(uint256 proposalId);\r\n\r\n    /// @notice Thrown if the given tokenId is not owned by the sender.\r\n    /// @param tokenId The ID of the token.\r\n    /// @param sender The address that made the call.\r\n    error TokenNotOwnedBySender(uint256 tokenId, address sender);\r\n\r\n    /// @notice Emitted when the voting settings are updated.\r\n    /// @param votingMode A parameter to select the vote mode.\r\n    /// @param supportThreshold The support threshold value.\r\n    /// @param minParticipation The minimum participation value.\r\n    /// @param minDuration The minimum duration of the proposal vote in seconds.\r\n    /// @param minProposerVotingPower The minimum voting power required to create a proposal.\r\n    event VotingSettingsUpdated(\r\n        VotingMode votingMode,\r\n        uint32 supportThreshold,\r\n        uint32 minParticipation,\r\n        uint64 minDuration,\r\n        uint256 minProposerVotingPower\r\n    );\r\n\r\n    /// @notice Initializes the component to be used by inheriting contracts.\r\n    /// @dev This method is required to support [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822).\r\n    /// @param _dao The IDAO interface of the associated DAO.\r\n    /// @param _votingSettings The voting settings.\r\n    function __TokenMajorityVotingBase_init(\r\n        IDAO _dao,\r\n        VotingSettings calldata _votingSettings,\r\n        IERC721 _tokenCollection\r\n    ) internal onlyInitializing {\r\n        __PluginUUPSUpgradeable_init(_dao);\r\n        _updateVotingSettings(_votingSettings);\r\n\r\n        tokenCollection = _tokenCollection;\r\n    }\r\n\r\n    /// @notice Checks if this or the parent contract supports an interface by its ID.\r\n    /// @param _interfaceId The ID of the interface.\r\n    /// @return Returns `true` if the interface is supported.\r\n    function supportsInterface(\r\n        bytes4 _interfaceId\r\n    )\r\n        public\r\n        view\r\n        virtual\r\n        override(ERC165Upgradeable, PluginUUPSUpgradeable, ProposalUpgradeable)\r\n        returns (bool)\r\n    {\r\n        return\r\n            _interfaceId == MAJORITY_VOTING_BASE_INTERFACE_ID ||\r\n            _interfaceId == type(ITokenMajorityVoting).interfaceId ||\r\n            super.supportsInterface(_interfaceId);\r\n    }\r\n\r\n    /// @inheritdoc ITokenMajorityVoting\r\n    function vote(\r\n        uint256 _proposalId,\r\n        VoteOption _voteOption,\r\n        bool _tryEarlyExecution,\r\n        uint256 _tokenId\r\n    ) public virtual {\r\n        if (tokenCollection.ownerOf(_tokenId) != _msgSender()) {\r\n            revert TokenNotOwnedBySender(_tokenId, _msgSender());\r\n        }\r\n\r\n        if (!_canVote(_proposalId, _tokenId, _voteOption)) {\r\n            revert VoteCastForbidden({\r\n                proposalId: _proposalId,\r\n                account: _tokenId,\r\n                voteOption: _voteOption\r\n            });\r\n        }\r\n        _vote(_proposalId, _voteOption, _tokenId, _tryEarlyExecution);\r\n    }\r\n\r\n    /// @inheritdoc ITokenMajorityVoting\r\n    function execute(uint256 _proposalId) public virtual {\r\n        if (!_canExecute(_proposalId)) {\r\n            revert ProposalExecutionForbidden(_proposalId);\r\n        }\r\n        _execute(_proposalId);\r\n    }\r\n\r\n    /// @inheritdoc ITokenMajorityVoting\r\n    function getVoteOption(\r\n        uint256 _proposalId,\r\n        uint256 _account\r\n    ) public view virtual returns (VoteOption) {\r\n        return proposals[_proposalId].voters[_account];\r\n    }\r\n\r\n    /// @inheritdoc ITokenMajorityVoting\r\n    function canVote(\r\n        uint256 _proposalId,\r\n        uint256 _account,\r\n        VoteOption _voteOption\r\n    ) public view virtual returns (bool) {\r\n        return _canVote(_proposalId, _account, _voteOption);\r\n    }\r\n\r\n    /// @inheritdoc ITokenMajorityVoting\r\n    function canExecute(\r\n        uint256 _proposalId\r\n    ) public view virtual returns (bool) {\r\n        return _canExecute(_proposalId);\r\n    }\r\n\r\n    /// @inheritdoc ITokenMajorityVoting\r\n    function isSupportThresholdReached(\r\n        uint256 _proposalId\r\n    ) public view virtual returns (bool) {\r\n        Proposal storage proposal_ = proposals[_proposalId];\r\n\r\n        // The code below implements the formula of the support criterion explained in the top of this file.\r\n        // `(1 - supportThreshold) * N_yes > supportThreshold *  N_no`\r\n        return\r\n            (RATIO_BASE - proposal_.parameters.supportThreshold) *\r\n                proposal_.tally.yes >\r\n            proposal_.parameters.supportThreshold * proposal_.tally.no;\r\n    }\r\n\r\n    /// @inheritdoc ITokenMajorityVoting\r\n    function isSupportThresholdReachedEarly(\r\n        uint256 _proposalId\r\n    ) public view virtual returns (bool) {\r\n        Proposal storage proposal_ = proposals[_proposalId];\r\n\r\n        uint256 noVotesWorstCase = totalVotingPower(\r\n            proposal_.parameters.snapshotBlock\r\n        ) -\r\n            proposal_.tally.yes -\r\n            proposal_.tally.abstain;\r\n\r\n        // The code below implements the formula of the early execution support criterion explained in the top of this file.\r\n        // `(1 - supportThreshold) * N_yes > supportThreshold *  N_no,worst-case`\r\n        return\r\n            (RATIO_BASE - proposal_.parameters.supportThreshold) *\r\n                proposal_.tally.yes >\r\n            proposal_.parameters.supportThreshold * noVotesWorstCase;\r\n    }\r\n\r\n    /// @inheritdoc ITokenMajorityVoting\r\n    function isMinParticipationReached(\r\n        uint256 _proposalId\r\n    ) public view virtual returns (bool) {\r\n        Proposal storage proposal_ = proposals[_proposalId];\r\n\r\n        // The code below implements the formula of the participation criterion explained in the top of this file.\r\n        // `N_yes + N_no + N_abstain >= minVotingPower = minParticipation * N_total`\r\n        return\r\n            proposal_.tally.yes +\r\n                proposal_.tally.no +\r\n                proposal_.tally.abstain >=\r\n            proposal_.parameters.minVotingPower;\r\n    }\r\n\r\n    /// @inheritdoc ITokenMajorityVoting\r\n    function supportThreshold() public view virtual returns (uint32) {\r\n        return votingSettings.supportThreshold;\r\n    }\r\n\r\n    /// @inheritdoc ITokenMajorityVoting\r\n    function minParticipation() public view virtual returns (uint32) {\r\n        return votingSettings.minParticipation;\r\n    }\r\n\r\n    /// @notice Returns the minimum duration parameter stored in the voting settings.\r\n    /// @return The minimum duration parameter.\r\n    function minDuration() public view virtual returns (uint64) {\r\n        return votingSettings.minDuration;\r\n    }\r\n\r\n    /// @notice Returns the minimum voting power required to create a proposal stored in the voting settings.\r\n    /// @return The minimum voting power required to create a proposal.\r\n    function minProposerVotingPower() public view virtual returns (uint256) {\r\n        return votingSettings.minProposerVotingPower;\r\n    }\r\n\r\n    /// @notice Returns the vote mode stored in the voting settings.\r\n    /// @return The vote mode parameter.\r\n    function votingMode() public view virtual returns (VotingMode) {\r\n        return votingSettings.votingMode;\r\n    }\r\n\r\n    /// @notice Returns the total voting power checkpointed for a specific block number.\r\n    /// @param _blockNumber The block number.\r\n    /// @return The total voting power.\r\n    function totalVotingPower(\r\n        uint256 _blockNumber\r\n    ) public view virtual returns (uint256);\r\n\r\n    /// @notice Returns all information for a proposal vote by its ID.\r\n    /// @param _proposalId The ID of the proposal.\r\n    /// @return open Whether the proposal is open or not.\r\n    /// @return executed Whether the proposal is executed or not.\r\n    /// @return parameters The parameters of the proposal vote.\r\n    /// @return tally The current tally of the proposal vote.\r\n    /// @return actions The actions to be executed in the associated DAO after the proposal has passed.\r\n    /// @return allowFailureMap The bit map representations of which actions are allowed to revert so tx still succeeds.\r\n    function getProposal(\r\n        uint256 _proposalId\r\n    )\r\n        public\r\n        view\r\n        virtual\r\n        returns (\r\n            bool open,\r\n            bool executed,\r\n            ProposalParameters memory parameters,\r\n            Tally memory tally,\r\n            IDAO.Action[] memory actions,\r\n            uint256 allowFailureMap\r\n        )\r\n    {\r\n        Proposal storage proposal_ = proposals[_proposalId];\r\n\r\n        open = _isProposalOpen(proposal_);\r\n        executed = proposal_.executed;\r\n        parameters = proposal_.parameters;\r\n        tally = proposal_.tally;\r\n        actions = proposal_.actions;\r\n        allowFailureMap = proposal_.allowFailureMap;\r\n    }\r\n\r\n    /// @notice Updates the voting settings.\r\n    /// @param _votingSettings The new voting settings.\r\n    function updateVotingSettings(\r\n        VotingSettings calldata _votingSettings\r\n    ) external virtual auth(UPDATE_VOTING_SETTINGS_PERMISSION_ID) {\r\n        _updateVotingSettings(_votingSettings);\r\n    }\r\n\r\n    /// @notice Creates a new majority voting proposal.\r\n    /// @param _metadata The metadata of the proposal.\r\n    /// @param _actions The actions that will be executed after the proposal passes.\r\n    /// @param _allowFailureMap Allows proposal to succeed even if an action reverts. Uses bitmap representation. If the bit at index `x` is 1, the tx succeeds even if the action at `x` failed. Passing 0 will be treated as atomic execution.\r\n    /// @param _startDate The start date of the proposal vote. If 0, the current timestamp is used and the vote starts immediately.\r\n    /// @param _endDate The end date of the proposal vote. If 0, `_startDate + minDuration` is used.\r\n    /// @param _voteOption The chosen vote option to be casted on proposal creation.\r\n    /// @param _tryEarlyExecution If `true`,  early execution is tried after the vote cast. The call does not revert if early execution is not possible.\r\n    /// @return proposalId The ID of the proposal.\r\n    function createProposal(\r\n        bytes calldata _metadata,\r\n        IDAO.Action[] calldata _actions,\r\n        uint256 _allowFailureMap,\r\n        uint64 _startDate,\r\n        uint64 _endDate,\r\n        VoteOption _voteOption,\r\n        bool _tryEarlyExecution,\r\n        uint256 _tokenId\r\n    ) external virtual returns (uint256 proposalId);\r\n\r\n    /// @notice Internal function to cast a vote. It assumes the queried vote exists.\r\n    /// @param _proposalId The ID of the proposal.\r\n    /// @param _voteOption The chosen vote option to be casted on the proposal vote.\r\n    /// @param _voter The ID of the token that is voting.\r\n    /// @param _tryEarlyExecution If `true`,  early execution is tried after the vote cast. The call does not revert if early execution is not possible.\r\n    function _vote(\r\n        uint256 _proposalId,\r\n        VoteOption _voteOption,\r\n        uint256 _voter,\r\n        bool _tryEarlyExecution\r\n    ) internal virtual;\r\n\r\n    /// @notice Internal function to execute a vote. It assumes the queried proposal exists.\r\n    /// @param _proposalId The ID of the proposal.\r\n    function _execute(uint256 _proposalId) internal virtual {\r\n        proposals[_proposalId].executed = true;\r\n\r\n        _executeProposal(\r\n            dao(),\r\n            _proposalId,\r\n            proposals[_proposalId].actions,\r\n            proposals[_proposalId].allowFailureMap\r\n        );\r\n    }\r\n\r\n    /// @notice Internal function to check if a voter can vote. It assumes the queried proposal exists.\r\n    /// @param _proposalId The ID of the proposal.\r\n    /// @param _voter The address of the voter to check.\r\n    /// @param  _voteOption Whether the voter abstains, supports or opposes the proposal.\r\n    /// @return Returns `true` if the given voter can vote on a certain proposal and `false` otherwise.\r\n    function _canVote(\r\n        uint256 _proposalId,\r\n        uint256 _voter,\r\n        VoteOption _voteOption\r\n    ) internal view virtual returns (bool);\r\n\r\n    /// @notice Internal function to check if a proposal can be executed. It assumes the queried proposal exists.\r\n    /// @param _proposalId The ID of the proposal.\r\n    /// @return True if the proposal can be executed, false otherwise.\r\n    /// @dev Threshold and minimal values are compared with `>` and `>=` comparators, respectively.\r\n    function _canExecute(\r\n        uint256 _proposalId\r\n    ) internal view virtual returns (bool) {\r\n        Proposal storage proposal_ = proposals[_proposalId];\r\n\r\n        // Verify that the vote has not been executed already.\r\n        if (proposal_.executed) {\r\n            return false;\r\n        }\r\n\r\n        if (_isProposalOpen(proposal_)) {\r\n            // Early execution\r\n            if (proposal_.parameters.votingMode != VotingMode.EarlyExecution) {\r\n                return false;\r\n            }\r\n            if (!isSupportThresholdReachedEarly(_proposalId)) {\r\n                return false;\r\n            }\r\n        } else {\r\n            // Normal execution\r\n            if (!isSupportThresholdReached(_proposalId)) {\r\n                return false;\r\n            }\r\n        }\r\n        if (!isMinParticipationReached(_proposalId)) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @notice Internal function to check if a proposal vote is still open.\r\n    /// @param proposal_ The proposal struct.\r\n    /// @return True if the proposal vote is open, false otherwise.\r\n    function _isProposalOpen(\r\n        Proposal storage proposal_\r\n    ) internal view virtual returns (bool) {\r\n        uint64 currentTime = block.timestamp.toUint64();\r\n\r\n        return\r\n            proposal_.parameters.startDate <= currentTime &&\r\n            currentTime < proposal_.parameters.endDate &&\r\n            !proposal_.executed;\r\n    }\r\n\r\n    /// @notice Internal function to update the plugin-wide proposal vote settings.\r\n    /// @param _votingSettings The voting settings to be validated and updated.\r\n    function _updateVotingSettings(\r\n        VotingSettings calldata _votingSettings\r\n    ) internal virtual {\r\n        // Require the support threshold value to be in the interval [0, 10^6-1], because `>` comparision is used in the support criterion and >100% could never be reached.\r\n        if (_votingSettings.supportThreshold > RATIO_BASE - 1) {\r\n            revert RatioOutOfBounds({\r\n                limit: RATIO_BASE - 1,\r\n                actual: _votingSettings.supportThreshold\r\n            });\r\n        }\r\n\r\n        // Require the minimum participation value to be in the interval [0, 10^6], because `>=` comparision is used in the participation criterion.\r\n        if (_votingSettings.minParticipation > RATIO_BASE) {\r\n            revert RatioOutOfBounds({\r\n                limit: RATIO_BASE,\r\n                actual: _votingSettings.minParticipation\r\n            });\r\n        }\r\n\r\n        if (_votingSettings.minDuration < 60 minutes) {\r\n            revert MinDurationOutOfBounds({\r\n                limit: 60 minutes,\r\n                actual: _votingSettings.minDuration\r\n            });\r\n        }\r\n\r\n        if (_votingSettings.minDuration > 365 days) {\r\n            revert MinDurationOutOfBounds({\r\n                limit: 365 days,\r\n                actual: _votingSettings.minDuration\r\n            });\r\n        }\r\n\r\n        votingSettings = _votingSettings;\r\n\r\n        emit VotingSettingsUpdated({\r\n            votingMode: _votingSettings.votingMode,\r\n            supportThreshold: _votingSettings.supportThreshold,\r\n            minParticipation: _votingSettings.minParticipation,\r\n            minDuration: _votingSettings.minDuration,\r\n            minProposerVotingPower: _votingSettings.minProposerVotingPower\r\n        });\r\n    }\r\n\r\n    /// @notice Validates and returns the proposal vote dates.\r\n    /// @param _start The start date of the proposal vote. If 0, the current timestamp is used and the vote starts immediately.\r\n    /// @param _end The end date of the proposal vote. If 0, `_start + minDuration` is used.\r\n    /// @return startDate The validated start date of the proposal vote.\r\n    /// @return endDate The validated end date of the proposal vote.\r\n    function _validateProposalDates(\r\n        uint64 _start,\r\n        uint64 _end\r\n    ) internal view virtual returns (uint64 startDate, uint64 endDate) {\r\n        uint64 currentTimestamp = block.timestamp.toUint64();\r\n\r\n        if (_start == 0) {\r\n            startDate = currentTimestamp;\r\n        } else {\r\n            startDate = _start;\r\n\r\n            if (startDate < currentTimestamp) {\r\n                revert DateOutOfBounds({\r\n                    limit: currentTimestamp,\r\n                    actual: startDate\r\n                });\r\n            }\r\n        }\r\n\r\n        uint64 earliestEndDate = startDate + votingSettings.minDuration; // Since `minDuration` is limited to 1 year, `startDate + minDuration` can only overflow if the `startDate` is after `type(uint64).max - minDuration`. In this case, the proposal creation will revert and another date can be picked.\r\n\r\n        if (_end == 0) {\r\n            endDate = earliestEndDate;\r\n        } else {\r\n            endDate = _end;\r\n\r\n            if (endDate < earliestEndDate) {\r\n                revert DateOutOfBounds({\r\n                    limit: earliestEndDate,\r\n                    actual: endDate\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice This empty reserved space is put in place to allow future versions to add new variables without shifting down storage in the inheritance chain (see [OpenZeppelin's guide about storage gaps](https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps)).\r\n    uint256[50] private __gap;\r\n}\r\n"
    },
    "contracts/DAO/TokenMembership/ITokenMembership.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface ITokenMembership {\r\n    /// @notice Emitted when members are added to the DAO plugin.\r\n    /// @param members The list of new members being added.\r\n    event MembersAdded(uint256[] members);\r\n\r\n    /// @notice Emitted when members are removed from the DAO plugin.\r\n    /// @param members The list of existing members being removed.\r\n    event MembersRemoved(uint256[] members);\r\n\r\n    /// @notice Emitted to announce the membership being defined by a contract.\r\n    /// @param definingContract The contract defining the membership.\r\n    event MembershipContractAnnounced(address indexed definingContract);\r\n\r\n    /// @notice Checks if an account is a member of the DAO.\r\n    /// @param _account The tokenId of the account to be checked.\r\n    /// @return Whether the account is a member or not.\r\n    /// @dev This function must be implemented in the plugin contract that introduces the members to the DAO.\r\n    function isMember(uint256 _account) external view returns (bool);\r\n}\r\n"
    },
    "contracts/Deps/DepsEns.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport {ENSRegistry} from \"@ensdomains/ens-contracts/contracts/registry/ENSRegistry.sol\";\r\nimport {FIFSRegistrar} from \"@ensdomains/ens-contracts/contracts/registry/FIFSRegistrar.sol\";\r\nimport {PublicResolver} from \"@ensdomains/ens-contracts/contracts/resolvers/PublicResolver.sol\";\r\n"
    },
    "contracts/Deps/hats-protocol/Hats.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n// Copyright (C) 2023 Haberdasher Labs\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity >=0.8.13;\n\nimport {ERC1155} from \"./lib/ERC1155/ERC1155.sol\";\n// import { console2 } from \"forge-std/Test.sol\"; //remove after testing\nimport \"./Interfaces/IHats.sol\";\nimport \"./HatsIdUtilities.sol\";\nimport \"./Interfaces/IHatsToggle.sol\";\nimport \"./Interfaces/IHatsEligibility.sol\";\nimport \"./lib/solbase/utils/Base64.sol\";\nimport \"./lib/solbase/utils/LibString.sol\";\nimport \"./lib/solady/utils/Multicallable.sol\";\n\n/// @title Hats Protocol v1\n/// @notice Hats are DAO-native, revocable, and programmable roles that are represented as non-transferable ERC-1155-similar tokens for composability\n/// @dev This is a multi-tenant contract that can manage all hats for a given chain. While it fully implements the ERC1155 interface, it does not fully comply with the ERC1155 standard.\n/// @author Haberdasher Labs\ncontract Hats is IHats, ERC1155, Multicallable, HatsIdUtilities {\n    /// @notice This contract's version is labeled v1. Previous versions labeled similarly as v1 and v1.0 are deprecated,\n    ///         and should be treated as beta deployments.\n\n    /*//////////////////////////////////////////////////////////////\n                              HATS DATA MODELS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice A Hat object containing the hat's properties\n    /// @dev The members are packed to minimize storage costs\n    /// @custom:member eligibility Module that rules on wearer eligibiliy and standing\n    /// @custom:member maxSupply The max number of hats with this id that can exist\n    /// @custom:member supply The number of this hat that currently exist\n    /// @custom:member lastHatId Indexes how many different child hats an admin has\n    /// @custom:member toggle Module that sets the hat's status\n    /**\n     * @custom:member config Holds status and other settings, with this bitwise schema:\n     *\n     *  0th bit  | `active` status; can be altered by toggle\n     *  1        | `mutable` setting\n     *  2 - 95   | unassigned\n     */\n    /// @custom:member details Holds arbitrary metadata about the hat\n    /// @custom:member imageURI A uri pointing to an image for the hat\n    struct Hat {\n        // 1st storage slot\n        address eligibility; // ─┐ 20\n        uint32 maxSupply; //     │ 4\n        uint32 supply; //        │ 4\n        uint16 lastHatId; //    ─┘ 2\n        // 2nd slot\n        address toggle; //      ─┐ 20\n        uint96 config; //       ─┘ 12\n        // 3rd+ slot (optional)\n        string details;\n        string imageURI;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              HATS STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice The name of the contract, typically including the version\n    string public name;\n\n    /// @notice The first 4 bytes of the id of the last tophat created.\n    uint32 public lastTopHatId; // first tophat id starts at 1\n\n    /// @notice The fallback image URI for hat tokens with no `imageURI` specified in their branch\n    string public baseImageURI;\n\n    /// @dev Internal mapping of hats to hat ids. See HatsIdUtilities.sol for more info on how hat ids work\n    mapping(uint256 => Hat) internal _hats; // key: hatId => value: Hat struct\n\n    /// @notice Mapping of wearers in bad standing for certain hats\n    /// @dev Used by external contracts to trigger penalties for wearers in bad standing\n    ///      hatId => wearer => !standing\n    mapping(uint256 => mapping(address => bool)) public badStandings;\n\n    /*//////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice All arguments are immutable; they can only be set once during construction\n    /// @param _name The name of this contract, typically including the version\n    /// @param _baseImageURI The fallback image URI\n    constructor(string memory _name, string memory _baseImageURI) {\n        name = _name;\n        baseImageURI = _baseImageURI;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              HATS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Creates and mints a Hat that is its own admin, i.e. a \"topHat\"\n    /// @dev A topHat has no eligibility and no toggle\n    /// @param _target The address to which the newly created topHat is minted\n    /// @param _details A description of the Hat [optional]. Should not be larger than 7000 bytes\n    ///                 (enforced in changeHatDetails)\n    /// @param _imageURI The image uri for this top hat and the fallback for its\n    ///                  downstream hats [optional]. Should not be large than 7000 bytes\n    ///                  (enforced in changeHatImageURI)\n    /// @return topHatId The id of the newly created topHat\n    function mintTopHat(\n        address _target,\n        string calldata _details,\n        string calldata _imageURI\n    ) public returns (uint256 topHatId) {\n        // create hat\n\n        topHatId = uint256(++lastTopHatId) << 224;\n\n        _createHat(\n            topHatId,\n            _details, // details\n            1, // maxSupply = 1\n            address(0), // there is no eligibility\n            address(0), // it has no toggle\n            false, // its immutable\n            _imageURI\n        );\n\n        _mintHat(_target, topHatId);\n    }\n\n    /// @notice Creates a new hat. The msg.sender must wear the `_admin` hat.\n    /// @dev Initializes a new Hat struct, but does not mint any tokens.\n    /// @param _details A description of the Hat. Should not be larger than 7000 bytes (enforced in changeHatDetails)\n    /// @param _maxSupply The total instances of the Hat that can be worn at once\n    /// @param _admin The id of the Hat that will control who wears the newly created hat\n    /// @param _eligibility The address that can report on the Hat wearer's status\n    /// @param _toggle The address that can deactivate the Hat\n    /// @param _mutable Whether the hat's properties are changeable after creation\n    /// @param _imageURI The image uri for this hat and the fallback for its\n    ///                  downstream hats [optional]. Should not be larger than 7000 bytes (enforced in changeHatImageURI)\n    /// @return newHatId The id of the newly created Hat\n    function createHat(\n        uint256 _admin,\n        string calldata _details,\n        uint32 _maxSupply,\n        address _eligibility,\n        address _toggle,\n        bool _mutable,\n        string calldata _imageURI\n    ) public returns (uint256 newHatId) {\n        if (uint16(_admin) > 0) {\n            revert MaxLevelsReached();\n        }\n\n        if (_eligibility == address(0)) revert ZeroAddress();\n        if (_toggle == address(0)) revert ZeroAddress();\n        // check that the admin id is valid, ie does not contain empty levels between filled levels\n        if (!isValidHatId(_admin)) revert InvalidHatId();\n        // construct the next hat id\n        newHatId = getNextId(_admin);\n        // to create a hat, you must be wearing one of its admin hats\n        _checkAdmin(newHatId);\n        // create the new hat\n        _createHat(\n            newHatId,\n            _details,\n            _maxSupply,\n            _eligibility,\n            _toggle,\n            _mutable,\n            _imageURI\n        );\n        // increment _admin.lastHatId\n        // use the overflow check to constrain to correct number of hats per level\n        ++_hats[_admin].lastHatId;\n    }\n\n    /// @notice Creates new hats in batch. The msg.sender must be an admin of each hat.\n    /// @dev This is a convenience function that loops through the arrays and calls `createHat`.\n    /// @param _admins Array of ids of admins for each hat to create\n    /// @param _details Array of details for each hat to create\n    /// @param _maxSupplies Array of supply caps for each hat to create\n    /// @param _eligibilityModules Array of eligibility module addresses for each hat to\n    /// create\n    /// @param _toggleModules Array of toggle module addresses for each hat to create\n    /// @param _mutables Array of mutable flags for each hat to create\n    /// @param _imageURIs Array of imageURIs for each hat to create\n    /// @return success True if all createHat calls succeeded\n    function batchCreateHats(\n        uint256[] calldata _admins,\n        string[] calldata _details,\n        uint32[] calldata _maxSupplies,\n        address[] memory _eligibilityModules,\n        address[] memory _toggleModules,\n        bool[] calldata _mutables,\n        string[] calldata _imageURIs\n    ) public returns (bool success) {\n        // check if array lengths are the same\n        uint256 length = _admins.length; // save an MLOAD\n\n        {\n            bool sameLengths = (length == _details.length && // details\n                length == _maxSupplies.length && // supplies\n                length == _eligibilityModules.length && // eligibility\n                length == _toggleModules.length && // toggle\n                length == _mutables.length && // mutable\n                length == _imageURIs.length); // imageURI\n            if (!sameLengths) revert BatchArrayLengthMismatch();\n        }\n\n        // loop through and create each hat\n        for (uint256 i = 0; i < length; ) {\n            createHat(\n                _admins[i],\n                _details[i],\n                _maxSupplies[i],\n                _eligibilityModules[i],\n                _toggleModules[i],\n                _mutables[i],\n                _imageURIs[i]\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        success = true;\n    }\n\n    /// @notice Gets the id of the next child hat of the hat `_admin`\n    /// @dev Does not incrememnt lastHatId\n    /// @param _admin The id of the hat to serve as the admin for the next child hat\n    /// @return nextId The new hat id\n    function getNextId(uint256 _admin) public view returns (uint256 nextId) {\n        uint16 nextHatId = _hats[_admin].lastHatId + 1;\n        nextId = buildHatId(_admin, nextHatId);\n    }\n\n    /// @notice Mints an ERC1155-similar token of the Hat to an eligible recipient, who then \"wears\" the hat\n    /// @dev The msg.sender must wear an admin Hat of `_hatId`, and the recipient must be eligible to wear `_hatId`\n    /// @param _hatId The id of the Hat to mint\n    /// @param _wearer The address to which the Hat is minted\n    /// @return success Whether the mint succeeded\n    function mintHat(\n        uint256 _hatId,\n        address _wearer\n    ) public returns (bool success) {\n        Hat storage hat = _hats[_hatId];\n        if (hat.maxSupply == 0) revert HatDoesNotExist(_hatId);\n        // only eligible wearers can receive minted hats\n        if (!isEligible(_wearer, _hatId)) revert NotEligible();\n        // only active hats can be minted\n        if (!_isActive(hat, _hatId)) revert HatNotActive();\n        // only the wearer of one of a hat's admins can mint it\n        _checkAdmin(_hatId);\n        // hat supply cannot exceed maxSupply\n        if (hat.supply >= hat.maxSupply) revert AllHatsWorn(_hatId);\n        // wearers cannot wear the same hat more than once\n        if (_staticBalanceOf(_wearer, _hatId) > 0)\n            revert AlreadyWearingHat(_wearer, _hatId);\n        // if we've made it through all the checks, mint the hat\n        _mintHat(_wearer, _hatId);\n\n        success = true;\n    }\n\n    /// @notice Mints new hats in batch. The msg.sender must be an admin of each hat.\n    /// @dev This is a convenience function that loops through the arrays and calls `mintHat`.\n    /// @param _hatIds Array of ids of hats to mint\n    /// @param _wearers Array of addresses to which the hats will be minted\n    /// @return success True if all mintHat calls succeeded\n    function batchMintHats(\n        uint256[] calldata _hatIds,\n        address[] calldata _wearers\n    ) public returns (bool success) {\n        uint256 length = _hatIds.length;\n        if (length != _wearers.length) revert BatchArrayLengthMismatch();\n\n        for (uint256 i = 0; i < length; ) {\n            mintHat(_hatIds[i], _wearers[i]);\n            unchecked {\n                ++i;\n            }\n        }\n\n        success = true;\n    }\n\n    /// @notice Toggles a Hat's status from active to deactive, or vice versa\n    /// @dev The msg.sender must be set as the hat's toggle\n    /// @param _hatId The id of the Hat for which to adjust status\n    /// @param _newStatus The new status to set\n    /// @return toggled Whether the status was toggled\n    function setHatStatus(\n        uint256 _hatId,\n        bool _newStatus\n    ) external returns (bool toggled) {\n        Hat storage hat = _hats[_hatId];\n\n        if (msg.sender != hat.toggle) {\n            revert NotHatsToggle();\n        }\n\n        toggled = _processHatStatus(_hatId, _newStatus);\n    }\n\n    /// @notice Checks a hat's toggle module and processes the returned status\n    /// @dev May change the hat's status in storage\n    /// @param _hatId The id of the Hat whose toggle we are checking\n    /// @return toggled Whether there was a new status\n    function checkHatStatus(uint256 _hatId) public returns (bool toggled) {\n        Hat storage hat = _hats[_hatId];\n\n        // attempt to retrieve the hat's status from the toggle module\n        (bool success, bool newStatus) = _pullHatStatus(hat, _hatId);\n\n        // if unsuccessful (ie toggle was humanistic), process the new status\n        if (!success) revert NotHatsToggle();\n\n        // if successful (ie toggle was mechanistic), process the new status\n        toggled = _processHatStatus(_hatId, newStatus);\n    }\n\n    function _pullHatStatus(\n        Hat storage _hat,\n        uint256 _hatId\n    ) internal view returns (bool success, bool newStatus) {\n        bytes memory data = abi.encodeWithSignature(\n            \"getHatStatus(uint256)\",\n            _hatId\n        );\n        bytes memory returndata;\n        (success, returndata) = _hat.toggle.staticcall(data);\n\n        /*\n         * if function call succeeds with data of length == 32, then we know the contract exists\n         * and has the getHatStatus function.\n         * But — since function selectors don't include return types — we still can't assume that the return data is a boolean,\n         * so we treat it as a uint so it will always safely decode without throwing.\n         */\n        if (success && returndata.length == 32) {\n            // check the returndata manually\n            uint256 uintReturndata = abi.decode(returndata, (uint256));\n            // false condition\n            if (uintReturndata == 0) {\n                newStatus = false;\n                // true condition\n            } else if (uintReturndata == 1) {\n                newStatus = true;\n            }\n            // invalid condition\n            else {\n                success = false;\n            }\n        } else {\n            success = false;\n        }\n    }\n\n    /// @notice Report from a hat's eligibility on the status of one of its wearers and, if `false`, revoke their hat\n    /// @dev Burns the wearer's hat, if revoked\n    /// @param _hatId The id of the hat\n    /// @param _wearer The address of the hat wearer whose status is being reported\n    /// @param _eligible Whether the wearer is eligible for the hat (will be revoked if\n    /// false)\n    /// @param _standing False if the wearer is no longer in good standing (and potentially should be penalized)\n    /// @return updated Whether the report succeeded\n    function setHatWearerStatus(\n        uint256 _hatId,\n        address _wearer,\n        bool _eligible,\n        bool _standing\n    ) external returns (bool updated) {\n        Hat storage hat = _hats[_hatId];\n\n        if (msg.sender != hat.eligibility) {\n            revert NotHatsEligibility();\n        }\n\n        updated = _processHatWearerStatus(\n            _hatId,\n            _wearer,\n            _eligible,\n            _standing\n        );\n    }\n\n    /// @notice Check a hat's eligibility for a report on the status of one of the hat's wearers and, if `false`, revoke their hat\n    /// @dev Burns the wearer's hat, if revoked\n    /// @param _hatId The id of the hat\n    /// @param _wearer The address of the Hat wearer whose status report is being requested\n    /// @return updated Whether the wearer's status was altered\n    function checkHatWearerStatus(\n        uint256 _hatId,\n        address _wearer\n    ) public returns (bool updated) {\n        bool eligible;\n        bool standing;\n\n        (bool success, bytes memory returndata) = _hats[_hatId]\n            .eligibility\n            .staticcall(\n                abi.encodeWithSignature(\n                    \"getWearerStatus(address,uint256)\",\n                    _wearer,\n                    _hatId\n                )\n            );\n\n        /*\n         * if function call succeeds with data of length == 64, then we know the contract exists\n         * and has the getWearerStatus function (which returns two words).\n         * But — since function selectors don't include return types — we still can't assume that the return data is two booleans,\n         * so we treat it as a uint so it will always safely decode without throwing.\n         */\n        if (success && returndata.length == 64) {\n            // check the returndata manually\n            (uint256 firstWord, uint256 secondWord) = abi.decode(\n                returndata,\n                (uint256, uint256)\n            );\n            // returndata is valid\n            if (firstWord < 2 && secondWord < 2) {\n                standing = (secondWord == 1) ? true : false;\n                // never eligible if in bad standing\n                eligible = (standing && firstWord == 1) ? true : false;\n            }\n            // returndata is invalid\n            else {\n                revert NotHatsEligibility();\n            }\n        } else {\n            revert NotHatsEligibility();\n        }\n\n        updated = _processHatWearerStatus(_hatId, _wearer, eligible, standing);\n    }\n\n    /// @notice Stop wearing a hat, aka \"renounce\" it\n    /// @dev Burns the msg.sender's hat\n    /// @param _hatId The id of the Hat being renounced\n    function renounceHat(uint256 _hatId) external {\n        if (_staticBalanceOf(msg.sender, _hatId) < 1) {\n            revert NotHatWearer();\n        }\n        // remove the hat\n        _burnHat(msg.sender, _hatId);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              HATS INTERNAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Internal call for creating a new hat\n    /// @dev Initializes a new Hat in storage, but does not mint any tokens\n    /// @param _id ID of the hat to be stored\n    /// @param _details A description of the hat\n    /// @param _maxSupply The total instances of the Hat that can be worn at once\n    /// @param _eligibility The address that can report on the Hat wearer's status\n    /// @param _toggle The address that can deactivate the hat [optional]\n    /// @param _mutable Whether the hat's properties are changeable after creation\n    /// @param _imageURI The image uri for this top hat and the fallback for its\n    ///                  downstream hats [optional]\n    function _createHat(\n        uint256 _id,\n        string calldata _details,\n        uint32 _maxSupply,\n        address _eligibility,\n        address _toggle,\n        bool _mutable,\n        string calldata _imageURI\n    ) internal {\n        /* \n          We write directly to storage instead of first building the Hat struct in memory.\n          This allows us to cheaply use the existing lastHatId value in case it was incremented by creating a hat while skipping admin levels.\n          (Resetting it to 0 would be bad since this hat's child hat(s) would overwrite the previously created hat(s) at that level.)\n        */\n        Hat storage hat = _hats[_id];\n        hat.details = _details;\n        hat.maxSupply = _maxSupply;\n        hat.eligibility = _eligibility;\n        hat.toggle = _toggle;\n        hat.imageURI = _imageURI;\n        // config is a concatenation of the status and mutability properties\n        hat.config = _mutable ? uint96(3 << 94) : uint96(1 << 95);\n\n        emit HatCreated(\n            _id,\n            _details,\n            _maxSupply,\n            _eligibility,\n            _toggle,\n            _mutable,\n            _imageURI\n        );\n    }\n\n    /// @notice Internal function to process hat status\n    /// @dev Updates a hat's status if different from current\n    /// @param _hatId The id of the Hat in quest\n    /// @param _newStatus The status to potentially change to\n    /// @return updated - Whether the status was updated\n    function _processHatStatus(\n        uint256 _hatId,\n        bool _newStatus\n    ) internal returns (bool updated) {\n        // optimize later\n        Hat storage hat = _hats[_hatId];\n\n        if (_newStatus != _getHatStatus(hat)) {\n            _setHatStatus(hat, _newStatus);\n            emit HatStatusChanged(_hatId, _newStatus);\n            updated = true;\n        }\n    }\n\n    /// @notice Internal call to process wearer status from the eligibility module\n    /// @dev Burns the wearer's Hat token if _eligible is false, and updates badStandings\n    /// state if necessary\n    /// @param _hatId The id of the Hat to revoke\n    /// @param _wearer The address of the wearer in question\n    /// @param _eligible Whether _wearer is eligible for the Hat (if false, this function\n    /// will revoke their Hat)\n    /// @param _standing Whether _wearer is in good standing (to be recorded in storage)\n    /// @return updated Whether the wearer standing was updated\n    function _processHatWearerStatus(\n        uint256 _hatId,\n        address _wearer,\n        bool _eligible,\n        bool _standing\n    ) internal returns (bool updated) {\n        // revoke/burn the hat if _wearer has a positive balance\n        if (_staticBalanceOf(_wearer, _hatId) > 0) {\n            // always ineligible if in bad standing\n            if (!_eligible || !_standing) {\n                _burnHat(_wearer, _hatId);\n            }\n        }\n\n        // record standing for use by other contracts\n        // note: here, standing and badStandings are opposite\n        // i.e. if standing (true = good standing)\n        // then badStandings[_hatId][wearer] will be false\n        // if they are different, then something has changed, and we need to update\n        // badStandings marker\n        if (_standing == badStandings[_hatId][_wearer]) {\n            badStandings[_hatId][_wearer] = !_standing;\n            updated = true;\n\n            emit WearerStandingChanged(_hatId, _wearer, _standing);\n        }\n    }\n\n    /// @notice Internal function to set a hat's status in storage\n    /// @dev Flips the 0th bit of _hat.config via bitwise operation\n    /// @param _hat The hat object\n    /// @param _status The status to set for the hat\n    function _setHatStatus(Hat storage _hat, bool _status) internal {\n        if (_status) {\n            _hat.config |= uint96(1 << 95);\n        } else {\n            _hat.config &= ~uint96(1 << 95);\n        }\n    }\n\n    /**\n     * @notice Internal function to retrieve an account's internal \"static\" balance directly from internal storage,\n     * @dev This function bypasses the dynamic `_isActive` and `_isEligible` checks\n     * @param _account The account to check\n     * @param _hatId The hat to check\n     * @return staticBalance The account's static of the hat, from internal storage\n     */\n    function _staticBalanceOf(\n        address _account,\n        uint256 _hatId\n    ) internal view returns (uint256 staticBalance) {\n        staticBalance = _balanceOf[_account][_hatId];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              HATS ADMIN FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Checks whether msg.sender is an admin of a hat, and reverts if not\n    function _checkAdmin(uint256 _hatId) internal view {\n        if (!isAdminOfHat(msg.sender, _hatId)) {\n            revert NotAdmin(msg.sender, _hatId);\n        }\n    }\n\n    /// @notice checks whether the msg.sender is either an admin or wearer or a hat, and reverts the appropriate error if not\n    function _checkAdminOrWearer(uint256 _hatId) internal view {\n        if (\n            !isAdminOfHat(msg.sender, _hatId) &&\n            !isWearerOfHat(msg.sender, _hatId)\n        ) {\n            revert NotAdminOrWearer();\n        }\n    }\n\n    /// @notice Transfers a hat from one wearer to another eligible wearer\n    /// @dev The hat must be mutable, and the transfer must be initiated by an admin\n    /// @param _hatId The hat in question\n    /// @param _from The current wearer\n    /// @param _to The new wearer\n    function transferHat(uint256 _hatId, address _from, address _to) public {\n        _checkAdmin(_hatId);\n        // cannot transfer immutable hats, except for tophats, which can always transfer themselves\n        if (!isTopHat(_hatId)) {\n            if (!_isMutable(_hats[_hatId])) revert Immutable();\n        }\n        // Checks storage instead of `isWearerOfHat` since admins may want to transfer revoked Hats to new wearers\n        if (_staticBalanceOf(_from, _hatId) < 1) revert NotHatWearer();\n        // Check if recipient is already wearing hat; also checks storage to maintain balance == 1 invariant\n        if (_staticBalanceOf(_to, _hatId) > 0)\n            revert AlreadyWearingHat(_to, _hatId);\n        // only eligible wearers can receive transferred hats\n        if (!isEligible(_to, _hatId)) revert NotEligible();\n        // only active hats can be transferred\n        if (!_isActive(_hats[_hatId], _hatId)) revert HatNotActive();\n        // we've made it passed all the checks, so adjust balances to execute the transfer\n        _balanceOf[_from][_hatId] = 0;\n        _balanceOf[_to][_hatId] = 1;\n        // emit the ERC1155 standard transfer event\n        emit TransferSingle(msg.sender, _from, _to, _hatId, 1);\n    }\n\n    /// @notice Set a mutable hat to immutable\n    /// @dev Sets the second bit of hat.config to 0\n    /// @param _hatId The id of the Hat to make immutable\n    function makeHatImmutable(uint256 _hatId) external {\n        _checkAdmin(_hatId);\n\n        Hat storage hat = _hats[_hatId];\n\n        if (!_isMutable(hat)) {\n            revert Immutable();\n        }\n\n        hat.config &= ~uint96(1 << 94);\n\n        emit HatMutabilityChanged(_hatId);\n    }\n\n    /// @notice Change a hat's details\n    /// @dev Hat must be mutable, except for tophats.\n    /// @param _hatId The id of the Hat to change\n    /// @param _newDetails The new details. Must not be larger than 7000 bytes.\n    function changeHatDetails(\n        uint256 _hatId,\n        string calldata _newDetails\n    ) external {\n        if (bytes(_newDetails).length > 7000) revert StringTooLong();\n\n        _checkAdmin(_hatId);\n\n        Hat storage hat = _hats[_hatId];\n\n        // a tophat can change its own details, but otherwise only mutable hat details can be changed\n        if (!isTopHat(_hatId)) {\n            if (!_isMutable(hat)) revert Immutable();\n        }\n\n        hat.details = _newDetails;\n\n        emit HatDetailsChanged(_hatId, _newDetails);\n    }\n\n    /// @notice Change a hat's details\n    /// @dev Hat must be mutable\n    /// @param _hatId The id of the Hat to change\n    /// @param _newEligibility The new eligibility module\n    function changeHatEligibility(\n        uint256 _hatId,\n        address _newEligibility\n    ) external {\n        if (_newEligibility == address(0)) revert ZeroAddress();\n\n        _checkAdmin(_hatId);\n        Hat storage hat = _hats[_hatId];\n\n        if (!_isMutable(hat)) {\n            revert Immutable();\n        }\n\n        hat.eligibility = _newEligibility;\n\n        emit HatEligibilityChanged(_hatId, _newEligibility);\n    }\n\n    /// @notice Change a hat's details\n    /// @dev Hat must be mutable\n    /// @param _hatId The id of the Hat to change\n    /// @param _newToggle The new toggle module\n    function changeHatToggle(uint256 _hatId, address _newToggle) external {\n        if (_newToggle == address(0)) revert ZeroAddress();\n\n        _checkAdmin(_hatId);\n        Hat storage hat = _hats[_hatId];\n\n        if (!_isMutable(hat)) {\n            revert Immutable();\n        }\n\n        // record hat status from old toggle before changing; ensures smooth transition to new toggle,\n        // especially in case of switching from mechanistic to humanistic toggle\n        // a) attempt to retrieve hat status from old toggle\n        (bool success, bool newStatus) = _pullHatStatus(hat, _hatId);\n        // b) if succeeded, (ie if old toggle was mechanistic), store the retrieved status\n        if (success) _processHatStatus(_hatId, newStatus);\n\n        // set the new toggle\n        hat.toggle = _newToggle;\n\n        emit HatToggleChanged(_hatId, _newToggle);\n    }\n\n    /// @notice Change a hat's details\n    /// @dev Hat must be mutable, except for tophats\n    /// @param _hatId The id of the Hat to change\n    /// @param _newImageURI The new imageURI. Must not be larger than 7000 bytes.\n    function changeHatImageURI(\n        uint256 _hatId,\n        string calldata _newImageURI\n    ) external {\n        if (bytes(_newImageURI).length > 7000) revert StringTooLong();\n\n        _checkAdmin(_hatId);\n        Hat storage hat = _hats[_hatId];\n\n        // a tophat can change its own imageURI, but otherwise only mutable hat imageURIs can be changed\n        if (!isTopHat(_hatId)) {\n            if (!_isMutable(hat)) revert Immutable();\n        }\n\n        hat.imageURI = _newImageURI;\n\n        emit HatImageURIChanged(_hatId, _newImageURI);\n    }\n\n    /// @notice Change a hat's details\n    /// @dev Hat must be mutable; new max supply cannot be less than current supply\n    /// @param _hatId The id of the Hat to change\n    /// @param _newMaxSupply The new max supply\n    function changeHatMaxSupply(uint256 _hatId, uint32 _newMaxSupply) external {\n        _checkAdmin(_hatId);\n        Hat storage hat = _hats[_hatId];\n\n        if (!_isMutable(hat)) {\n            revert Immutable();\n        }\n\n        if (_newMaxSupply < hat.supply) {\n            revert NewMaxSupplyTooLow();\n        }\n\n        if (_newMaxSupply != hat.maxSupply) {\n            hat.maxSupply = _newMaxSupply;\n            emit HatMaxSupplyChanged(_hatId, _newMaxSupply);\n        }\n    }\n\n    /// @notice Submits a request to link a Hat Tree under a parent tree. Requests can be\n    /// submitted by either...\n    ///     a) the wearer of a topHat, previous to any linkage, or\n    ///     b) the admin(s) of an already-linked topHat (aka tree root), where such a\n    ///        request is to move the tree root to another admin within the same parent\n    ///        tree\n    /// @dev A topHat can have at most 1 request at a time. Submitting a new request will\n    ///      replace the existing request.\n    /// @param _topHatDomain The domain of the topHat to link\n    /// @param _requestedAdminHat The hat that will administer the linked tree\n    function requestLinkTopHatToTree(\n        uint32 _topHatDomain,\n        uint256 _requestedAdminHat\n    ) external {\n        uint256 fullTopHatId = uint256(_topHatDomain) << 224; // (256 - TOPHAT_ADDRESS_SPACE);\n\n        // The wearer of an unlinked tophat is also the admin of same; once a tophat is linked, its wearer is no longer its admin\n        _checkAdmin(fullTopHatId);\n\n        linkedTreeRequests[_topHatDomain] = _requestedAdminHat;\n        emit TopHatLinkRequested(_topHatDomain, _requestedAdminHat);\n    }\n\n    /// @notice Approve a request to link a Tree under a parent tree, with options to add eligibility or toggle modules and change its metadata\n    /// @dev Requests can only be approved by wearer or an admin of the `_newAdminHat`, and there\n    ///      can only be one link per tree root at a given time.\n    /// @param _topHatDomain The 32 bit domain of the topHat to link\n    /// @param _newAdminHat The hat that will administer the linked tree\n    /// @param _eligibility Optional new eligibility module for the linked topHat\n    /// @param _toggle Optional new toggle module for the linked topHat\n    /// @param _details Optional new details for the linked topHat\n    /// @param _imageURI Optional new imageURI for the linked topHat\n    function approveLinkTopHatToTree(\n        uint32 _topHatDomain,\n        uint256 _newAdminHat,\n        address _eligibility,\n        address _toggle,\n        string calldata _details,\n        string calldata _imageURI\n    ) external {\n        // for everything but the last hat level, check the admin of `_newAdminHat`'s theoretical child hat, since either wearer or admin of `_newAdminHat` can approve\n        if (getHatLevel(_newAdminHat) < MAX_LEVELS) {\n            _checkAdmin(buildHatId(_newAdminHat, 1));\n        } else {\n            // the above buildHatId trick doesn't work for the last hat level, so we need to explicitly check both admin and wearer in this case\n            _checkAdminOrWearer(_newAdminHat);\n        }\n\n        // Linkages must be initiated by a request\n        if (_newAdminHat != linkedTreeRequests[_topHatDomain])\n            revert LinkageNotRequested();\n\n        // remove the request -- ensures all linkages are initialized by unique requests,\n        // except for relinks (see `relinkTopHatWithinTree`)\n        delete linkedTreeRequests[_topHatDomain];\n\n        // execute the link. Replaces existing link, if any.\n        _linkTopHatToTree(\n            _topHatDomain,\n            _newAdminHat,\n            _eligibility,\n            _toggle,\n            _details,\n            _imageURI\n        );\n    }\n\n    /**\n     * @notice Unlink a Tree from the parent tree\n     * @dev This can only be called by an admin of the tree root. Fails if the topHat to unlink has no non-zero wearer, which can occur if...\n     *     - It's wearer is in badStanding\n     *     - It has been revoked from its wearer (and possibly burned)˘\n     *     - It is not active (ie toggled off)\n     * @param _topHatDomain The 32 bit domain of the topHat to unlink\n     * @param _wearer The current wearer of the topHat to unlink\n     */\n    function unlinkTopHatFromTree(\n        uint32 _topHatDomain,\n        address _wearer\n    ) external {\n        uint256 fullTopHatId = uint256(_topHatDomain) << 224; // (256 - TOPHAT_ADDRESS_SPACE);\n        _checkAdmin(fullTopHatId);\n\n        // prevent unlinking if the topHat has no non-zero wearer\n        // since we cannot search the entire address space for a wearer, we require the caller to provide the wearer\n        if (_wearer == address(0) || !isWearerOfHat(_wearer, fullTopHatId))\n            revert HatsErrors.InvalidUnlink();\n\n        // execute the unlink\n        delete linkedTreeAdmins[_topHatDomain];\n        // remove the request — ensures all linkages are initialized by unique requests\n        delete linkedTreeRequests[_topHatDomain];\n\n        // reset eligibility and storage to defaults for unlinked top hats\n        Hat storage hat = _hats[fullTopHatId];\n        delete hat.eligibility;\n        delete hat.toggle;\n\n        emit TopHatLinked(_topHatDomain, 0);\n    }\n\n    /// @notice Move a tree root to a different position within the same parent tree,\n    ///         without a request. Valid destinations include within the same local tree as the origin,\n    ///         or to the local tree of the tippyTopHat. TippyTopHat wearers can bypass this restriction\n    ///         to relink to anywhere in its full tree.\n    /// @dev Caller must be both an admin tree root and admin or wearer of `_newAdminHat`.\n    /// @param _topHatDomain The 32 bit domain of the topHat to relink\n    /// @param _newAdminHat The new admin for the linked tree\n    /// @param _eligibility Optional new eligibility module for the linked topHat\n    /// @param _toggle Optional new toggle module for the linked topHat\n    /// @param _details Optional new details for the linked topHat\n    /// @param _imageURI Optional new imageURI for the linked topHat\n    function relinkTopHatWithinTree(\n        uint32 _topHatDomain,\n        uint256 _newAdminHat,\n        address _eligibility,\n        address _toggle,\n        string calldata _details,\n        string calldata _imageURI\n    ) external {\n        uint256 fullTopHatId = uint256(_topHatDomain) << 224; // (256 - TOPHAT_ADDRESS_SPACE);\n\n        // msg.sender being capable of both requesting and approving allows us to skip the request step\n        _checkAdmin(fullTopHatId); // \"requester\" must be admin\n\n        // \"approver\" can be wearer or admin\n        if (getHatLevel(_newAdminHat) < MAX_LEVELS) {\n            _checkAdmin(buildHatId(_newAdminHat, 1));\n        } else {\n            // the above buildHatId trick doesn't work for the last hat level, so we need to explicitly check both admin and wearer in this case\n            _checkAdminOrWearer(_newAdminHat);\n        }\n\n        // execute the new link, replacing the old link\n        _linkTopHatToTree(\n            _topHatDomain,\n            _newAdminHat,\n            _eligibility,\n            _toggle,\n            _details,\n            _imageURI\n        );\n    }\n\n    /// @notice Internal function to link a Tree under a parent Tree, with protection against circular linkages and relinking to a separate Tree,\n    ///         with options to add eligibility or toggle modules and change its metadata\n    /// @dev Linking `_topHatDomain` replaces any existing links\n    /// @param _topHatDomain The 32 bit domain of the topHat to link\n    /// @param _newAdminHat The new admin for the linked tree\n    /// @param _eligibility Optional new eligibility module for the linked topHat\n    /// @param _toggle Optional new toggle module for the linked topHat\n    /// @param _details Optional new details for the linked topHat\n    /// @param _imageURI Optional new imageURI for the linked topHat\n    function _linkTopHatToTree(\n        uint32 _topHatDomain,\n        uint256 _newAdminHat,\n        address _eligibility,\n        address _toggle,\n        string calldata _details,\n        string calldata _imageURI\n    ) internal {\n        if (!noCircularLinkage(_topHatDomain, _newAdminHat))\n            revert CircularLinkage();\n        {\n            uint256 linkedAdmin = linkedTreeAdmins[_topHatDomain];\n\n            // disallow relinking to separate tree\n            if (linkedAdmin > 0) {\n                uint256 tippyTopHat = uint256(\n                    getTippyTopHatDomain(_topHatDomain)\n                ) << 224;\n                if (!isWearerOfHat(msg.sender, tippyTopHat)) {\n                    uint256 destLocalTopHat = uint256(\n                        (_newAdminHat >> 224) << 224\n                    ); // (256 - TOPHAT_ADDRESS_SPACE);\n                    // for non-tippyTopHat wearers: destination local tophat must be either...\n                    // a) the same as origin local tophat, or\n                    // b) within the tippy top hat's local tree\n                    uint256 originLocalTopHat = (linkedAdmin >> 224) << 224; // (256 - TOPHAT_ADDRESS_SPACE);\n                    if (\n                        destLocalTopHat != originLocalTopHat &&\n                        destLocalTopHat != tippyTopHat\n                    ) {\n                        revert CrossTreeLinkage();\n                    }\n                    // for tippyTopHat weerers: destination must be within the same super tree\n                } else if (\n                    !sameTippyTopHatDomain(_topHatDomain, _newAdminHat)\n                ) {\n                    revert CrossTreeLinkage();\n                }\n            }\n        }\n\n        // update and log the linked topHat's modules and metadata, if any changes\n        uint256 topHatId = uint256(_topHatDomain) << 224;\n        Hat storage hat = _hats[topHatId];\n\n        if (_eligibility != address(0)) {\n            hat.eligibility = _eligibility;\n            emit HatEligibilityChanged(topHatId, _eligibility);\n        }\n        if (_toggle != address(0)) {\n            hat.toggle = _toggle;\n            emit HatToggleChanged(topHatId, _toggle);\n        }\n\n        uint256 length = bytes(_details).length;\n        if (length > 0) {\n            if (length > 7000) revert StringTooLong();\n            hat.details = _details;\n            emit HatDetailsChanged(topHatId, _details);\n        }\n\n        length = bytes(_imageURI).length;\n        if (length > 0) {\n            if (length > 7000) revert StringTooLong();\n            hat.imageURI = _imageURI;\n            emit HatImageURIChanged(topHatId, _imageURI);\n        }\n\n        // store the new linked admin\n        linkedTreeAdmins[_topHatDomain] = _newAdminHat;\n        emit TopHatLinked(_topHatDomain, _newAdminHat);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              HATS VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice View the properties of a given Hat\n    /// @param _hatId The id of the Hat\n    /// @return details The details of the Hat\n    /// @return maxSupply The max supply of tokens for this Hat\n    /// @return supply The number of current wearers of this Hat\n    /// @return eligibility The eligibility address for this Hat\n    /// @return toggle The toggle address for this Hat\n    /// @return imageURI The image URI used for this Hat\n    /// @return lastHatId The most recently created Hat with this Hat as admin; also the count of Hats with this Hat as admin\n    /// @return mutable_ Whether this hat's properties can be changed\n    /// @return active Whether the Hat is current active, as read from `_isActive`\n    function viewHat(\n        uint256 _hatId\n    )\n        public\n        view\n        returns (\n            string memory details,\n            uint32 maxSupply,\n            uint32 supply,\n            address eligibility,\n            address toggle,\n            string memory imageURI,\n            uint16 lastHatId,\n            bool mutable_,\n            bool active\n        )\n    {\n        Hat storage hat = _hats[_hatId];\n        details = hat.details;\n        maxSupply = hat.maxSupply;\n        supply = hat.supply;\n        eligibility = hat.eligibility;\n        toggle = hat.toggle;\n        imageURI = getImageURIForHat(_hatId);\n        lastHatId = hat.lastHatId;\n        mutable_ = _isMutable(hat);\n        active = _isActive(hat, _hatId);\n    }\n\n    /// @notice Checks whether a given address wears a given Hat\n    /// @dev Convenience function that wraps `balanceOf`\n    /// @param _user The address in question\n    /// @param _hatId The id of the Hat that the `_user` might wear\n    /// @return isWearer Whether the `_user` wears the Hat.\n    function isWearerOfHat(\n        address _user,\n        uint256 _hatId\n    ) public view returns (bool isWearer) {\n        isWearer = (balanceOf(_user, _hatId) > 0);\n    }\n\n    /// @notice Checks whether a given address serves as the admin of a given Hat\n    /// @dev Recursively checks if `_user` wears the admin Hat of the Hat in question. This is recursive since there may be a string of Hats as admins of Hats.\n    /// @param _user The address in question\n    /// @param _hatId The id of the Hat for which the `_user` might be the admin\n    /// @return isAdmin Whether the `_user` has admin rights for the Hat\n    function isAdminOfHat(\n        address _user,\n        uint256 _hatId\n    ) public view returns (bool isAdmin) {\n        uint256 linkedTreeAdmin;\n        uint32 adminLocalHatLevel;\n        if (isLocalTopHat(_hatId)) {\n            linkedTreeAdmin = linkedTreeAdmins[getTopHatDomain(_hatId)];\n            if (linkedTreeAdmin == 0) {\n                // tree is not linked\n                return isAdmin = isWearerOfHat(_user, _hatId);\n            } else {\n                // tree is linked\n                if (isWearerOfHat(_user, linkedTreeAdmin)) {\n                    return isAdmin = true;\n                }\n                // user wears the treeAdmin\n                else {\n                    adminLocalHatLevel = getLocalHatLevel(linkedTreeAdmin);\n                    _hatId = linkedTreeAdmin;\n                }\n            }\n        } else {\n            // if we get here, _hatId is not a tophat of any kind\n            // get the local tree level of _hatId's admin\n            adminLocalHatLevel = getLocalHatLevel(_hatId) - 1;\n        }\n\n        // search up _hatId's local address space for an admin hat that the _user wears\n        while (adminLocalHatLevel > 0) {\n            if (\n                isWearerOfHat(\n                    _user,\n                    getAdminAtLocalLevel(_hatId, adminLocalHatLevel)\n                )\n            ) {\n                return isAdmin = true;\n            }\n            // should not underflow given stopping condition > 0\n            unchecked {\n                --adminLocalHatLevel;\n            }\n        }\n\n        // if we get here, we've reached the top of _hatId's local tree, ie the local tophat\n        // check if the user wears the local tophat\n        if (isWearerOfHat(_user, getAdminAtLocalLevel(_hatId, 0)))\n            return isAdmin = true;\n\n        // if not, we check if it's linked to another tree\n        linkedTreeAdmin = linkedTreeAdmins[getTopHatDomain(_hatId)];\n        if (linkedTreeAdmin == 0) {\n            // tree is not linked\n            // we've already learned that user doesn't wear the local tophat, so there's nothing else to check; we return false\n            return isAdmin = false;\n        } else {\n            // tree is linked\n            // check if user is wearer of linkedTreeAdmin\n            if (isWearerOfHat(_user, linkedTreeAdmin)) return true;\n            // if not, recurse to traverse the parent tree for a hat that the user wears\n            isAdmin = isAdminOfHat(_user, linkedTreeAdmin);\n        }\n    }\n\n    /// @notice Checks the active status of a hat\n    /// @dev For internal use instead of `isActive` when passing Hat as param is preferable\n    /// @param _hat The Hat struct\n    /// @param _hatId The id of the hat\n    /// @return active The active status of the hat\n    function _isActive(\n        Hat storage _hat,\n        uint256 _hatId\n    ) internal view returns (bool active) {\n        (bool success, bytes memory returndata) = _hat.toggle.staticcall(\n            abi.encodeWithSignature(\"getHatStatus(uint256)\", _hatId)\n        );\n\n        /*\n         * if function call succeeds with data of length == 32, then we know the contract exists\n         * and has the getHatStatus function.\n         * But — since function selectors don't include return types — we still can't assume that the return data is a boolean,\n         * so we treat it as a uint so it will always safely decode without throwing.\n         */\n        if (success && returndata.length == 32) {\n            // check the returndata manually\n            uint256 uintReturndata = uint256(bytes32(returndata));\n            // false condition\n            if (uintReturndata == 0) {\n                active = false;\n                // true condition\n            } else if (uintReturndata == 1) {\n                active = true;\n            }\n            // invalid condition\n            else {\n                active = _getHatStatus(_hat);\n            }\n        } else {\n            active = _getHatStatus(_hat);\n        }\n    }\n\n    /// @notice Checks the active status of a hat\n    /// @param _hatId The id of the hat\n    /// @return active Whether the hat is active\n    function isActive(uint256 _hatId) external view returns (bool active) {\n        active = _isActive(_hats[_hatId], _hatId);\n    }\n\n    /// @notice Internal function to retrieve a hat's status from storage\n    /// @dev reads the 0th bit of the hat's config\n    /// @param _hat The hat object\n    /// @return status Whether the hat is active\n    function _getHatStatus(\n        Hat storage _hat\n    ) internal view returns (bool status) {\n        status = (_hat.config >> 95 != 0);\n    }\n\n    /// @notice Internal function to retrieve a hat's mutability setting\n    /// @dev reads the 1st bit of the hat's config\n    /// @param _hat The hat object\n    /// @return _mutable Whether the hat is mutable\n    function _isMutable(\n        Hat storage _hat\n    ) internal view returns (bool _mutable) {\n        _mutable = (_hat.config & uint96(1 << 94) != 0);\n    }\n\n    /// @notice Checks whether a wearer of a Hat is in good standing\n    /// @param _wearer The address of the Hat wearer\n    /// @param _hatId The id of the Hat\n    /// @return standing Whether the wearer is in good standing\n    function isInGoodStanding(\n        address _wearer,\n        uint256 _hatId\n    ) public view returns (bool standing) {\n        (bool success, bytes memory returndata) = _hats[_hatId]\n            .eligibility\n            .staticcall(\n                abi.encodeWithSignature(\n                    \"getWearerStatus(address,uint256)\",\n                    _wearer,\n                    _hatId\n                )\n            );\n\n        /*\n         * if function call succeeds with data of length == 64, then we know the contract exists\n         * and has the getWearerStatus function (which returns two words).\n         * But — since function selectors don't include return types — we still can't assume that the return data is two booleans,\n         * so we treat it as a uint so it will always safely decode without throwing.\n         */\n        if (success && returndata.length == 64) {\n            // check the returndata manually\n            (uint256 firstWord, uint256 secondWord) = abi.decode(\n                returndata,\n                (uint256, uint256)\n            );\n            // returndata is valid\n            if (firstWord < 2 && secondWord < 2) {\n                standing = (secondWord == 1) ? true : false;\n                // returndata is invalid\n            } else {\n                standing = !badStandings[_hatId][_wearer];\n            }\n        } else {\n            standing = !badStandings[_hatId][_wearer];\n        }\n    }\n\n    /// @notice Internal call to check whether an address is eligible for a given Hat\n    /// @dev Tries an external call to the Hat's eligibility module, defaulting to existing badStandings state if the call fails (ie if the eligibility module address does not conform to the IHatsEligibility interface)\n    /// @param _wearer The address of the Hat wearer\n    /// @param _hat The Hat object\n    /// @param _hatId The id of the Hat\n    /// @return eligible Whether the wearer is eligible for the Hat\n    function _isEligible(\n        address _wearer,\n        Hat storage _hat,\n        uint256 _hatId\n    ) internal view returns (bool eligible) {\n        (bool success, bytes memory returndata) = _hat.eligibility.staticcall(\n            abi.encodeWithSignature(\n                \"getWearerStatus(address,uint256)\",\n                _wearer,\n                _hatId\n            )\n        );\n\n        /*\n         * if function call succeeds with data of length == 64, then we know the contract exists\n         * and has the getWearerStatus function (which returns two words).\n         * But — since function selectors don't include return types — we still can't assume that the return data is two booleans,\n         * so we treat it as a uint so it will always safely decode without throwing.\n         */\n        if (success && returndata.length == 64) {\n            bool standing;\n            // check the returndata manually\n            (uint256 firstWord, uint256 secondWord) = abi.decode(\n                returndata,\n                (uint256, uint256)\n            );\n            // returndata is valid\n            if (firstWord < 2 && secondWord < 2) {\n                standing = (secondWord == 1) ? true : false;\n                // never eligible if in bad standing\n                eligible = (standing && firstWord == 1) ? true : false;\n            }\n            // returndata is invalid\n            else {\n                eligible = !badStandings[_hatId][_wearer];\n            }\n        } else {\n            eligible = !badStandings[_hatId][_wearer];\n        }\n    }\n\n    /// @notice Checks whether an address is eligible for a given Hat\n    /// @dev Public function for use when passing a Hat object is not possible or preferable\n    /// @param _hatId The id of the Hat\n    /// @param _wearer The address to check\n    /// @return eligible Whether the wearer is eligible for the Hat\n    function isEligible(\n        address _wearer,\n        uint256 _hatId\n    ) public view returns (bool eligible) {\n        eligible = _isEligible(_wearer, _hats[_hatId], _hatId);\n    }\n\n    /// @notice Gets the current supply of a Hat\n    /// @dev Only tracks explicit burns and mints, not dynamic revocations\n    /// @param _hatId The id of the Hat\n    /// @return supply The current supply of the Hat\n    function hatSupply(uint256 _hatId) external view returns (uint32 supply) {\n        supply = _hats[_hatId].supply;\n    }\n\n    /// @notice Gets the eligibility module for a hat\n    /// @param _hatId The hat whose eligibility module we're looking for\n    /// @return eligibility The eligibility module for this hat\n    function getHatEligibilityModule(\n        uint256 _hatId\n    ) external view returns (address eligibility) {\n        eligibility = _hats[_hatId].eligibility;\n    }\n\n    /// @notice Gets the toggle module for a hat\n    /// @param _hatId The hat whose toggle module we're looking for\n    /// @return toggle The toggle module for this hat\n    function getHatToggleModule(\n        uint256 _hatId\n    ) external view returns (address toggle) {\n        toggle = _hats[_hatId].toggle;\n    }\n\n    /// @notice Gets the max supply for a hat\n    /// @param _hatId The hat whose max supply we're looking for\n    /// @return maxSupply The maximum possible quantity of this hat that could be minted\n    function getHatMaxSupply(\n        uint256 _hatId\n    ) external view returns (uint32 maxSupply) {\n        maxSupply = _hats[_hatId].maxSupply;\n    }\n\n    /// @notice Gets the imageURI for a given hat\n    /// @dev If this hat does not have an imageURI set, recursively get the imageURI from\n    ///      its admin\n    /// @param _hatId The hat whose imageURI we're looking for\n    /// @return _uri The imageURI of this hat or, if empty, its admin\n    function getImageURIForHat(\n        uint256 _hatId\n    ) public view returns (string memory _uri) {\n        // check _hatId first to potentially avoid the `getHatLevel` call\n        Hat storage hat = _hats[_hatId];\n\n        string memory imageURI = hat.imageURI; // save 1 SLOAD\n\n        // if _hatId has an imageURI, we return it\n        if (bytes(imageURI).length > 0) {\n            return imageURI;\n        }\n\n        // otherwise, we check its branch of admins\n        uint256 level = getHatLevel(_hatId);\n\n        // but first we check if _hatId is a tophat, in which case we fall back to the global image uri\n        if (level == 0) return baseImageURI;\n\n        // otherwise, we check each of its admins for a valid imageURI\n        uint256 id;\n\n        // already checked at `level` above, so we start the loop at `level - 1`\n        for (uint256 i = level - 1; i > 0; ) {\n            id = getAdminAtLevel(_hatId, uint32(i));\n            hat = _hats[id];\n            imageURI = hat.imageURI;\n\n            if (bytes(imageURI).length > 0) {\n                return imageURI;\n            }\n            // should not underflow given stopping condition is > 0\n            unchecked {\n                --i;\n            }\n        }\n\n        id = getAdminAtLevel(_hatId, 0);\n        hat = _hats[id];\n        imageURI = hat.imageURI;\n\n        if (bytes(imageURI).length > 0) {\n            return imageURI;\n        }\n\n        // if none of _hatId's admins has an imageURI of its own, we again fall back to the global image uri\n        _uri = baseImageURI;\n    }\n\n    /// @notice Constructs the URI for a Hat, using data from the Hat struct\n    /// @param _hatId The id of the Hat\n    /// @return _uri An ERC1155-compatible JSON string\n    function _constructURI(\n        uint256 _hatId\n    ) internal view returns (string memory _uri) {\n        Hat storage hat = _hats[_hatId];\n\n        uint256 hatAdmin;\n\n        if (isTopHat(_hatId)) {\n            hatAdmin = _hatId;\n        } else {\n            hatAdmin = getAdminAtLevel(_hatId, getHatLevel(_hatId) - 1);\n        }\n\n        // split into two objects to avoid stack too deep error\n        string memory idProperties = string.concat(\n            '\"domain\": \"',\n            LibString.toString(getTopHatDomain(_hatId)),\n            '\", \"id\": \"',\n            LibString.toString(_hatId),\n            '\", \"pretty id\": \"',\n            LibString.toHexString(_hatId, 32),\n            '\",'\n        );\n\n        string memory otherProperties = string.concat(\n            '\"status\": \"',\n            (_isActive(hat, _hatId) ? \"active\" : \"inactive\"),\n            '\", \"current supply\": \"',\n            LibString.toString(hat.supply),\n            '\", \"supply cap\": \"',\n            LibString.toString(hat.maxSupply),\n            '\", \"admin (id)\": \"',\n            LibString.toString(hatAdmin),\n            '\", \"admin (pretty id)\": \"',\n            LibString.toHexString(hatAdmin, 32),\n            '\", \"eligibility module\": \"',\n            LibString.toHexString(hat.eligibility),\n            '\", \"toggle module\": \"',\n            LibString.toHexString(hat.toggle),\n            '\", \"mutable\": \"',\n            _isMutable(hat) ? \"true\" : \"false\",\n            '\"'\n        );\n\n        _uri = string(\n            abi.encodePacked(\n                \"data:application/json;base64,\",\n                Base64.encode(\n                    bytes(\n                        string.concat(\n                            '{\"name\": \"',\n                            \"Hat\",\n                            '\", \"description\": \"',\n                            hat.details,\n                            '\", \"image\": \"',\n                            getImageURIForHat(_hatId),\n                            '\",',\n                            '\"properties\": ',\n                            \"{\",\n                            idProperties,\n                            otherProperties,\n                            \"}\",\n                            \"}\"\n                        )\n                    )\n                )\n            )\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC1155 OVERRIDES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Gets the Hat token balance of a user for a given Hat\n    /// @dev Balance is dynamic based on the hat's status and wearer's eligibility, so off-chain balance data indexed from events may not be in sync\n    /// @param _wearer The address whose balance is being checked\n    /// @param _hatId The id of the Hat\n    /// @return balance The `wearer`'s balance of the Hat tokens. Can never be > 1.\n    function balanceOf(\n        address _wearer,\n        uint256 _hatId\n    ) public view override(ERC1155, IHats) returns (uint256 balance) {\n        Hat storage hat = _hats[_hatId];\n\n        balance = 0;\n\n        if (_isActive(hat, _hatId) && _isEligible(_wearer, hat, _hatId)) {\n            balance = super.balanceOf(_wearer, _hatId);\n        }\n    }\n\n    /// @notice Internal call to mint a Hat token to a wearer\n    /// @dev Unsafe if called when `_wearer` has a non-zero balance of `_hatId`\n    /// @param _wearer The wearer of the Hat and the recipient of the newly minted token\n    /// @param _hatId The id of the Hat to mint\n    function _mintHat(address _wearer, uint256 _hatId) internal {\n        unchecked {\n            // should not overflow since `mintHat` enforces max balance of 1\n            _balanceOf[_wearer][_hatId] = 1;\n\n            // increment Hat supply counter\n            // should not overflow given AllHatsWorn check in `mintHat`\n            ++_hats[_hatId].supply;\n        }\n\n        emit TransferSingle(msg.sender, address(0), _wearer, _hatId, 1);\n    }\n\n    /// @notice Internal call to burn a wearer's Hat token\n    /// @dev Unsafe if called when `_wearer` doesn't have a zero balance of `_hatId`\n    /// @param _wearer The wearer from which to burn the Hat token\n    /// @param _hatId The id of the Hat to burn\n    function _burnHat(address _wearer, uint256 _hatId) internal {\n        // neither should underflow since `_burnHat` is never called on non-positive balance\n        unchecked {\n            _balanceOf[_wearer][_hatId] = 0;\n\n            // decrement Hat supply counter\n            --_hats[_hatId].supply;\n        }\n\n        emit TransferSingle(msg.sender, _wearer, address(0), _hatId, 1);\n    }\n\n    /// @notice Approvals are not necessary for Hats since transfers are not handled by the wearer\n    /// @dev Admins should use `transferHat()` to transfer\n    function setApprovalForAll(address, bool) public pure override {\n        revert();\n    }\n\n    /// @notice Safe transfers are not necessary for Hats since transfers are not handled by the wearer\n    /// @dev Admins should use `transferHat()` to transfer\n    function safeTransferFrom(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) public pure override {\n        revert();\n    }\n\n    /// @notice Safe transfers are not necessary for Hats since transfers are not handled by the wearer\n    function safeBatchTransferFrom(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) public pure override {\n        revert();\n    }\n\n    /**\n     * @notice ERC165 interface detection\n     *  @dev While Hats Protocol conforms to the ERC1155 *interface*, it does not fully conform to the ERC1155 *specification*\n     *  since it does not implement the ERC1155Receiver functionality.\n     *  For this reason, this function overrides the ERC1155 implementation to return false for ERC1155.\n     *  @param interfaceId The interface identifier, as specified in ERC-165\n     *  @return bool True if the contract implements `interfaceId` and false otherwise\n     */\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public pure override returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            // interfaceId == 0xd9b67a26 || // ERC165 Interface ID for ERC1155\n            interfaceId == 0x0e89341c; // ERC165 Interface ID for ERC1155MetadataURI\n    }\n\n    /// @notice Batch retrieval for wearer balances\n    /// @dev Given the higher gas overhead of Hats balanceOf checks, large batches may be high cost or run into gas limits\n    /// @param _wearers Array of addresses to check balances for\n    /// @param _hatIds Array of Hat ids to check, using the same index as _wearers\n    function balanceOfBatch(\n        address[] calldata _wearers,\n        uint256[] calldata _hatIds\n    ) public view override(ERC1155, IHats) returns (uint256[] memory balances) {\n        if (_wearers.length != _hatIds.length)\n            revert BatchArrayLengthMismatch();\n\n        balances = new uint256[](_wearers.length);\n\n        // Unchecked because the only math done is incrementing\n        // the array index counter which cannot possibly overflow.\n        unchecked {\n            for (uint256 i; i < _wearers.length; ++i) {\n                balances[i] = balanceOf(_wearers[i], _hatIds[i]);\n            }\n        }\n    }\n\n    /// @notice View the uri for a Hat\n    /// @param id The id of the Hat\n    /// @return _uri An 1155-compatible JSON object\n    function uri(\n        uint256 id\n    ) public view override(ERC1155, IHats) returns (string memory _uri) {\n        _uri = _constructURI(id);\n    }\n}\n"
    },
    "contracts/Deps/hats-protocol/HatsIdUtilities.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n// Copyright (C) 2023 Haberdasher Labs\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity >=0.8.13;\n\nimport \"./Interfaces/IHatsIdUtilities.sol\";\n// import { console2 } from \"forge-std/Test.sol\"; //remove after testing\n\n/// @notice see HatsErrors.sol for description\nerror MaxLevelsReached();\n\n/// @title Hats Id Utilities\n/// @dev Functions for working with Hat Ids from Hats Protocol. Factored out of Hats.sol\n/// for easier use by other contracts.\n/// @author Haberdasher Labs\ncontract HatsIdUtilities is IHatsIdUtilities {\n    /// @notice Mapping of tophats requesting to link to admin hats in other trees\n    /// @dev Linkage only occurs if request is approved by the new admin\n    mapping(uint32 => uint256) public linkedTreeRequests; // topHatDomain => requested new admin\n\n    /// @notice Mapping of approved & linked tophats to admin hats in other trees, used for grafting one hats tree onto another\n    /// @dev Trees can only be linked to another tree via their tophat\n    mapping(uint32 => uint256) public linkedTreeAdmins; // topHatDomain => hatId\n\n    /**\n     * Hat Ids serve as addresses. A given Hat's Id represents its location in its\n     * hat tree: its level, its admin, its admin's admin (etc, all the way up to the\n     * tophat).\n     *\n     * The top level consists of 4 bytes and references all tophats.\n     *\n     * Each level below consists of 16 bits, and contains up to 65,536 child hats.\n     *\n     * A uint256 contains 4 bytes of space for tophat addresses, giving room for ((256 -\n     * 32) / 16) = 14 levels of delegation, with the admin at each level having space for\n     * 65,536 different child hats.\n     *\n     * A hat tree consists of a single tophat and has a max depth of 14 levels.\n     */\n\n    /// @dev Number of bits of address space for tophat ids, ie the tophat domain\n    uint256 internal constant TOPHAT_ADDRESS_SPACE = 32;\n\n    /// @dev Number of bits of address space for each level below the tophat\n    uint256 internal constant LOWER_LEVEL_ADDRESS_SPACE = 16;\n\n    /// @dev Maximum number of levels below the tophat, ie max tree depth\n    ///      (256 - TOPHAT_ADDRESS_SPACE) / LOWER_LEVEL_ADDRESS_SPACE;\n    uint256 internal constant MAX_LEVELS = 14;\n\n    /// @notice Constructs a valid hat id for a new hat underneath a given admin\n    /// @dev Reverts if the admin has already reached `MAX_LEVELS`\n    /// @param _admin the id of the admin for the new hat\n    /// @param _newHat the uint16 id of the new hat\n    /// @return id The constructed hat id\n    function buildHatId(uint256 _admin, uint16 _newHat) public pure returns (uint256 id) {\n        uint256 mask;\n        for (uint256 i = 0; i < MAX_LEVELS;) {\n            unchecked {\n                mask = uint256(\n                    type(uint256).max\n                    // should not overflow given known constants\n                    >> (TOPHAT_ADDRESS_SPACE + (LOWER_LEVEL_ADDRESS_SPACE * i))\n                );\n            }\n            if (_admin & mask == 0) {\n                unchecked {\n                    id = _admin\n                        | (\n                            uint256(_newHat)\n                            // should not overflow given known constants\n                            << (LOWER_LEVEL_ADDRESS_SPACE * (MAX_LEVELS - 1 - i))\n                        );\n                }\n                return id;\n            }\n\n            // should not overflow based on < MAX_LEVELS stopping condition\n            unchecked {\n                ++i;\n            }\n        }\n\n        // if _admin is already at MAX_LEVELS, child hats are not possible, so we revert\n        revert MaxLevelsReached();\n    }\n\n    /// @notice Identifies the level a given hat in its hat tree\n    /// @param _hatId the id of the hat in question\n    /// @return level (0 to type(uint32).max)\n    function getHatLevel(uint256 _hatId) public view returns (uint32 level) {\n        // uint256 mask;\n        // uint256 i;\n        level = getLocalHatLevel(_hatId);\n\n        uint256 treeAdmin = linkedTreeAdmins[getTopHatDomain(_hatId)];\n\n        if (treeAdmin != 0) {\n            level = 1 + level + getHatLevel(treeAdmin);\n        }\n    }\n\n    /// @notice Identifies the level a given hat in its local hat tree\n    /// @dev Similar to getHatLevel, but does not account for linked trees\n    /// @param _hatId the id of the hat in question\n    /// @return level The local level, from 0 to 14\n    function getLocalHatLevel(uint256 _hatId) public pure returns (uint32 level) {\n        if (_hatId & uint256(type(uint224).max) == 0) return 0;\n        if (_hatId & uint256(type(uint208).max) == 0) return 1;\n        if (_hatId & uint256(type(uint192).max) == 0) return 2;\n        if (_hatId & uint256(type(uint176).max) == 0) return 3;\n        if (_hatId & uint256(type(uint160).max) == 0) return 4;\n        if (_hatId & uint256(type(uint144).max) == 0) return 5;\n        if (_hatId & uint256(type(uint128).max) == 0) return 6;\n        if (_hatId & uint256(type(uint112).max) == 0) return 7;\n        if (_hatId & uint256(type(uint96).max) == 0) return 8;\n        if (_hatId & uint256(type(uint80).max) == 0) return 9;\n        if (_hatId & uint256(type(uint64).max) == 0) return 10;\n        if (_hatId & uint256(type(uint48).max) == 0) return 11;\n        if (_hatId & uint256(type(uint32).max) == 0) return 12;\n        if (_hatId & uint256(type(uint16).max) == 0) return 13;\n        return 14;\n    }\n\n    /// @notice Checks whether a hat is a topHat\n    /// @param _hatId The hat in question\n    /// @return _isTopHat Whether the hat is a topHat\n    function isTopHat(uint256 _hatId) public view returns (bool _isTopHat) {\n        _isTopHat = isLocalTopHat(_hatId) && linkedTreeAdmins[getTopHatDomain(_hatId)] == 0;\n    }\n\n    /// @notice Checks whether a hat is a topHat in its local hat tree\n    /// @dev Similar to isTopHat, but does not account for linked trees\n    /// @param _hatId The hat in question\n    /// @return _isLocalTopHat Whether the hat is a topHat for its local tree\n    function isLocalTopHat(uint256 _hatId) public pure returns (bool _isLocalTopHat) {\n        _isLocalTopHat = _hatId > 0 && uint224(_hatId) == 0;\n    }\n\n    function isValidHatId(uint256 _hatId) public pure returns (bool validHatId) {\n        // valid top hats are valid hats\n        if (isLocalTopHat(_hatId)) return true;\n\n        uint32 level = getLocalHatLevel(_hatId);\n        uint256 admin;\n        // for each subsequent level up the tree, check if the level is 0 and return false if so\n        for (uint256 i = level - 1; i > 0;) {\n            // truncate to find the (truncated) admin at this level\n            // we don't need to check _hatId's own level since getLocalHatLevel already ensures that its non-empty\n            admin = _hatId >> (LOWER_LEVEL_ADDRESS_SPACE * (MAX_LEVELS - i));\n            // if the lowest level of the truncated admin is empty, the hat id is invalid\n            if (uint16(admin) == 0) return false;\n\n            unchecked {\n                --i;\n            }\n        }\n        // if there are no empty levels, return true\n        return true;\n    }\n\n    /// @notice Gets the hat id of the admin at a given level of a given hat\n    /// @dev This function traverses trees by following the linkedTreeAdmin\n    ///       pointer to a hat located in a different tree\n    /// @param _hatId the id of the hat in question\n    /// @param _level the admin level of interest\n    /// @return admin The hat id of the resulting admin\n    function getAdminAtLevel(uint256 _hatId, uint32 _level) public view returns (uint256 admin) {\n        uint256 linkedTreeAdmin = linkedTreeAdmins[getTopHatDomain(_hatId)];\n        if (linkedTreeAdmin == 0) return admin = getAdminAtLocalLevel(_hatId, _level);\n\n        uint32 localTopHatLevel = getHatLevel(getAdminAtLocalLevel(_hatId, 0));\n\n        if (localTopHatLevel <= _level) return admin = getAdminAtLocalLevel(_hatId, _level - localTopHatLevel);\n\n        return admin = getAdminAtLevel(linkedTreeAdmin, _level);\n    }\n\n    /// @notice Gets the hat id of the admin at a given level of a given hat\n    ///         local to the tree containing the hat.\n    /// @param _hatId the id of the hat in question\n    /// @param _level the admin level of interest\n    /// @return admin The hat id of the resulting admin\n    function getAdminAtLocalLevel(uint256 _hatId, uint32 _level) public pure returns (uint256 admin) {\n        uint256 mask = type(uint256).max << (LOWER_LEVEL_ADDRESS_SPACE * (MAX_LEVELS - _level));\n\n        admin = _hatId & mask;\n    }\n\n    /// @notice Gets the tophat domain of a given hat\n    /// @dev A domain is the identifier for a given hat tree, stored in the first 4 bytes of a hat's id\n    /// @param _hatId the id of the hat in question\n    /// @return domain The domain of the hat's tophat\n    function getTopHatDomain(uint256 _hatId) public pure returns (uint32 domain) {\n        domain = uint32(_hatId >> (LOWER_LEVEL_ADDRESS_SPACE * MAX_LEVELS));\n    }\n\n    /// @notice Gets the domain of the highest parent tophat — the \"tippy tophat\"\n    /// @param _topHatDomain the 32 bit domain of a (likely linked) tophat\n    /// @return domain The tippy tophat domain\n    function getTippyTopHatDomain(uint32 _topHatDomain) public view returns (uint32 domain) {\n        uint256 linkedAdmin = linkedTreeAdmins[_topHatDomain];\n        if (linkedAdmin == 0) return domain = _topHatDomain;\n        return domain = getTippyTopHatDomain(getTopHatDomain(linkedAdmin));\n    }\n\n    /// @notice Checks For any circular linkage of trees\n    /// @param _topHatDomain the 32 bit domain of the tree to be linked\n    /// @param _linkedAdmin the hatId of the potential tree admin\n    /// @return notCircular circular link has not been found\n    function noCircularLinkage(uint32 _topHatDomain, uint256 _linkedAdmin) public view returns (bool notCircular) {\n        if (_linkedAdmin == 0) return true;\n        uint32 adminDomain = getTopHatDomain(_linkedAdmin);\n        if (_topHatDomain == adminDomain) return false;\n        uint256 parentAdmin = linkedTreeAdmins[adminDomain];\n        return noCircularLinkage(_topHatDomain, parentAdmin);\n    }\n\n    /// @notice Checks that a tophat domain and its potential linked admin are from the same tree, ie have the same tippy tophat domain\n    /// @param _topHatDomain The 32 bit domain of the tophat to be linked\n    /// @param _newAdminHat The new admin for the linked tree\n    /// @return sameDomain Whether the _topHatDomain and the domain of its potential linked _newAdminHat domains are the same\n    function sameTippyTopHatDomain(uint32 _topHatDomain, uint256 _newAdminHat) public view returns (bool sameDomain) {\n        // get highest parent domains for current and new tree root admins\n        uint32 currentTippyTophatDomain = getTippyTopHatDomain(_topHatDomain);\n        uint32 newAdminDomain = getTopHatDomain(_newAdminHat);\n        uint32 newHTippyTophatDomain = getTippyTopHatDomain(newAdminDomain);\n\n        // check that both domains are equal\n        sameDomain = (currentTippyTophatDomain == newHTippyTophatDomain);\n    }\n}\n"
    },
    "contracts/Deps/hats-protocol/Interfaces/HatsErrors.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n// Copyright (C) 2023 Haberdasher Labs\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity >=0.8.13;\n\ninterface HatsErrors {\n    /// @notice Emitted when `user` is attempting to perform an action on `hatId` but is not wearing one of `hatId`'s admin hats\n    /// @dev Can be equivalent to `NotHatWearer(buildHatId(hatId))`, such as when emitted by `approveLinkTopHatToTree` or `relinkTopHatToTree`\n    error NotAdmin(address user, uint256 hatId);\n\n    /// @notice Emitted when attempting to perform an action as or for an account that is not a wearer of a given hat\n    error NotHatWearer();\n\n    /// @notice Emitted when attempting to perform an action that requires being either an admin or wearer of a given hat\n    error NotAdminOrWearer();\n\n    /// @notice Emitted when attempting to mint `hatId` but `hatId`'s maxSupply has been reached\n    error AllHatsWorn(uint256 hatId);\n\n    /// @notice Emitted when attempting to create a hat with a level 14 hat as its admin\n    error MaxLevelsReached();\n\n    /// @notice Emitted when an attempted hat id has empty intermediate level(s)\n    error InvalidHatId();\n\n    /// @notice Emitted when attempting to mint `hatId` to a `wearer` who is already wearing the hat\n    error AlreadyWearingHat(address wearer, uint256 hatId);\n\n    /// @notice Emitted when attempting to mint a non-existant hat\n    error HatDoesNotExist(uint256 hatId);\n\n    /// @notice Emmitted when attempting to mint or transfer a hat that is not active\n    error HatNotActive();\n\n    /// @notice Emitted when attempting to mint or transfer a hat to an ineligible wearer\n    error NotEligible();\n\n    /// @notice Emitted when attempting to check or set a hat's status from an account that is not that hat's toggle module\n    error NotHatsToggle();\n\n    /// @notice Emitted when attempting to check or set a hat wearer's status from an account that is not that hat's eligibility module\n    error NotHatsEligibility();\n\n    /// @notice Emitted when array arguments to a batch function have mismatching lengths\n    error BatchArrayLengthMismatch();\n\n    /// @notice Emitted when attempting to mutate or transfer an immutable hat\n    error Immutable();\n\n    /// @notice Emitted when attempting to change a hat's maxSupply to a value lower than its current supply\n    error NewMaxSupplyTooLow();\n\n    /// @notice Emitted when attempting to link a tophat to a new admin for which the tophat serves as an admin\n    error CircularLinkage();\n\n    /// @notice Emitted when attempting to link or relink a tophat to a separate tree\n    error CrossTreeLinkage();\n\n    /// @notice Emitted when attempting to link a tophat without a request\n    error LinkageNotRequested();\n\n    /// @notice Emitted when attempting to unlink a tophat that does not have a wearer\n    /// @dev This ensures that unlinking never results in a bricked tophat\n    error InvalidUnlink();\n\n    /// @notice Emmited when attempting to change a hat's eligibility or toggle module to the zero address\n    error ZeroAddress();\n\n    /// @notice Emmitted when attempting to change a hat's details or imageURI to a string with over 7000 bytes (~characters)\n    /// @dev This protects against a DOS attack where an admin iteratively extend's a hat's details or imageURI\n    ///      to be so long that reading it exceeds the block gas limit, breaking `uri()` and `viewHat()`\n    error StringTooLong();\n}\n"
    },
    "contracts/Deps/hats-protocol/Interfaces/HatsEvents.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n// Copyright (C) 2023 Haberdasher Labs\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity >=0.8.13;\n\ninterface HatsEvents {\n    /// @notice Emitted when a new hat is created\n    /// @param id The id for the new hat\n    /// @param details A description of the Hat\n    /// @param maxSupply The total instances of the Hat that can be worn at once\n    /// @param eligibility The address that can report on the Hat wearer's status\n    /// @param toggle The address that can deactivate the Hat\n    /// @param mutable_ Whether the hat's properties are changeable after creation\n    /// @param imageURI The image uri for this hat and the fallback for its\n    event HatCreated(\n        uint256 id,\n        string details,\n        uint32 maxSupply,\n        address eligibility,\n        address toggle,\n        bool mutable_,\n        string imageURI\n    );\n\n    /// @notice Emitted when a hat wearer's standing is updated\n    /// @dev Eligibility is excluded since the source of truth for eligibility is the eligibility module and may change without a transaction\n    /// @param hatId The id of the wearer's hat\n    /// @param wearer The wearer's address\n    /// @param wearerStanding Whether the wearer is in good standing for the hat\n    event WearerStandingChanged(uint256 hatId, address wearer, bool wearerStanding);\n\n    /// @notice Emitted when a hat's status is updated\n    /// @param hatId The id of the hat\n    /// @param newStatus Whether the hat is active\n    event HatStatusChanged(uint256 hatId, bool newStatus);\n\n    /// @notice Emitted when a hat's details are updated\n    /// @param hatId The id of the hat\n    /// @param newDetails The updated details\n    event HatDetailsChanged(uint256 hatId, string newDetails);\n\n    /// @notice Emitted when a hat's eligibility module is updated\n    /// @param hatId The id of the hat\n    /// @param newEligibility The updated eligibiliy module\n    event HatEligibilityChanged(uint256 hatId, address newEligibility);\n\n    /// @notice Emitted when a hat's toggle module is updated\n    /// @param hatId The id of the hat\n    /// @param newToggle The updated toggle module\n    event HatToggleChanged(uint256 hatId, address newToggle);\n\n    /// @notice Emitted when a hat's mutability is updated\n    /// @param hatId The id of the hat\n    event HatMutabilityChanged(uint256 hatId);\n\n    /// @notice Emitted when a hat's maximum supply is updated\n    /// @param hatId The id of the hat\n    /// @param newMaxSupply The updated max supply\n    event HatMaxSupplyChanged(uint256 hatId, uint32 newMaxSupply);\n\n    /// @notice Emitted when a hat's image URI is updated\n    /// @param hatId The id of the hat\n    /// @param newImageURI The updated image URI\n    event HatImageURIChanged(uint256 hatId, string newImageURI);\n\n    /// @notice Emitted when a tophat linkage is requested by its admin\n    /// @param domain The domain of the tree tophat to link\n    /// @param newAdmin The tophat's would-be admin in the parent tree\n    event TopHatLinkRequested(uint32 domain, uint256 newAdmin);\n\n    /// @notice Emitted when a tophat is linked to a another tree\n    /// @param domain The domain of the newly-linked tophat\n    /// @param newAdmin The tophat's new admin in the parent tree\n    event TopHatLinked(uint32 domain, uint256 newAdmin);\n}\n"
    },
    "contracts/Deps/hats-protocol/Interfaces/IHats.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n// Copyright (C) 2023 Haberdasher Labs\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity >=0.8.13;\n\nimport \"./IHatsIdUtilities.sol\";\nimport \"./HatsErrors.sol\";\nimport \"./HatsEvents.sol\";\n\ninterface IHats is IHatsIdUtilities, HatsErrors, HatsEvents {\n    function mintTopHat(address _target, string memory _details, string memory _imageURI)\n        external\n        returns (uint256 topHatId);\n\n    function createHat(\n        uint256 _admin,\n        string calldata _details,\n        uint32 _maxSupply,\n        address _eligibility,\n        address _toggle,\n        bool _mutable,\n        string calldata _imageURI\n    ) external returns (uint256 newHatId);\n\n    function batchCreateHats(\n        uint256[] calldata _admins,\n        string[] calldata _details,\n        uint32[] calldata _maxSupplies,\n        address[] memory _eligibilityModules,\n        address[] memory _toggleModules,\n        bool[] calldata _mutables,\n        string[] calldata _imageURIs\n    ) external returns (bool success);\n\n    function getNextId(uint256 _admin) external view returns (uint256 nextId);\n\n    function mintHat(uint256 _hatId, address _wearer) external returns (bool success);\n\n    function batchMintHats(uint256[] calldata _hatIds, address[] calldata _wearers) external returns (bool success);\n\n    function setHatStatus(uint256 _hatId, bool _newStatus) external returns (bool toggled);\n\n    function checkHatStatus(uint256 _hatId) external returns (bool toggled);\n\n    function setHatWearerStatus(uint256 _hatId, address _wearer, bool _eligible, bool _standing)\n        external\n        returns (bool updated);\n\n    function checkHatWearerStatus(uint256 _hatId, address _wearer) external returns (bool updated);\n\n    function renounceHat(uint256 _hatId) external;\n\n    function transferHat(uint256 _hatId, address _from, address _to) external;\n\n    /*//////////////////////////////////////////////////////////////\n                              HATS ADMIN FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function makeHatImmutable(uint256 _hatId) external;\n\n    function changeHatDetails(uint256 _hatId, string memory _newDetails) external;\n\n    function changeHatEligibility(uint256 _hatId, address _newEligibility) external;\n\n    function changeHatToggle(uint256 _hatId, address _newToggle) external;\n\n    function changeHatImageURI(uint256 _hatId, string memory _newImageURI) external;\n\n    function changeHatMaxSupply(uint256 _hatId, uint32 _newMaxSupply) external;\n\n    function requestLinkTopHatToTree(uint32 _topHatId, uint256 _newAdminHat) external;\n\n    function approveLinkTopHatToTree(\n        uint32 _topHatId,\n        uint256 _newAdminHat,\n        address _eligibility,\n        address _toggle,\n        string calldata _details,\n        string calldata _imageURI\n    ) external;\n\n    function unlinkTopHatFromTree(uint32 _topHatId, address _wearer) external;\n\n    function relinkTopHatWithinTree(\n        uint32 _topHatDomain,\n        uint256 _newAdminHat,\n        address _eligibility,\n        address _toggle,\n        string calldata _details,\n        string calldata _imageURI\n    ) external;\n\n    /*//////////////////////////////////////////////////////////////\n                              VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function viewHat(uint256 _hatId)\n        external\n        view\n        returns (\n            string memory details,\n            uint32 maxSupply,\n            uint32 supply,\n            address eligibility,\n            address toggle,\n            string memory imageURI,\n            uint16 lastHatId,\n            bool mutable_,\n            bool active\n        );\n\n    function isWearerOfHat(address _user, uint256 _hatId) external view returns (bool isWearer);\n\n    function isAdminOfHat(address _user, uint256 _hatId) external view returns (bool isAdmin);\n\n    function isInGoodStanding(address _wearer, uint256 _hatId) external view returns (bool standing);\n\n    function isEligible(address _wearer, uint256 _hatId) external view returns (bool eligible);\n\n    function getHatEligibilityModule(uint256 _hatId) external view returns (address eligibility);\n\n    function getHatToggleModule(uint256 _hatId) external view returns (address toggle);\n\n    function getHatMaxSupply(uint256 _hatId) external view returns (uint32 maxSupply);\n\n    function hatSupply(uint256 _hatId) external view returns (uint32 supply);\n\n    function getImageURIForHat(uint256 _hatId) external view returns (string memory _uri);\n\n    function balanceOf(address wearer, uint256 hatId) external view returns (uint256 balance);\n\n    function balanceOfBatch(address[] calldata _wearers, uint256[] calldata _hatIds)\n        external\n        view\n        returns (uint256[] memory);\n\n    function uri(uint256 id) external view returns (string memory _uri);\n}\n"
    },
    "contracts/Deps/hats-protocol/Interfaces/IHatsEligibility.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n// Copyright (C) 2023 Haberdasher Labs\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity >=0.8.13;\n\ninterface IHatsEligibility {\n    /// @notice Returns the status of a wearer for a given hat\n    /// @dev If standing is false, eligibility MUST also be false\n    /// @param _wearer The address of the current or prospective Hat wearer\n    /// @param _hatId The id of the hat in question\n    /// @return eligible Whether the _wearer is eligible to wear the hat\n    /// @return standing Whether the _wearer is in goog standing\n    function getWearerStatus(address _wearer, uint256 _hatId) external view returns (bool eligible, bool standing);\n}\n"
    },
    "contracts/Deps/hats-protocol/Interfaces/IHatsIdUtilities.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n// Copyright (C) 2023 Haberdasher Labs\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity >=0.8.13;\n\ninterface IHatsIdUtilities {\n    function buildHatId(uint256 _admin, uint16 _newHat) external pure returns (uint256 id);\n\n    function getHatLevel(uint256 _hatId) external view returns (uint32 level);\n\n    function getLocalHatLevel(uint256 _hatId) external pure returns (uint32 level);\n\n    function isTopHat(uint256 _hatId) external view returns (bool _topHat);\n\n    function isLocalTopHat(uint256 _hatId) external pure returns (bool _localTopHat);\n\n    function isValidHatId(uint256 _hatId) external view returns (bool validHatId);\n\n    function getAdminAtLevel(uint256 _hatId, uint32 _level) external view returns (uint256 admin);\n\n    function getAdminAtLocalLevel(uint256 _hatId, uint32 _level) external pure returns (uint256 admin);\n\n    function getTopHatDomain(uint256 _hatId) external view returns (uint32 domain);\n\n    function getTippyTopHatDomain(uint32 _topHatDomain) external view returns (uint32 domain);\n\n    function noCircularLinkage(uint32 _topHatDomain, uint256 _linkedAdmin) external view returns (bool notCircular);\n\n    function sameTippyTopHatDomain(uint32 _topHatDomain, uint256 _newAdminHat)\n        external\n        view\n        returns (bool sameDomain);\n}\n"
    },
    "contracts/Deps/hats-protocol/Interfaces/IHatsToggle.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n// Copyright (C) 2023 Haberdasher Labs\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity >=0.8.13;\n\ninterface IHatsToggle {\n    function getHatStatus(uint256 _hatId) external view returns (bool);\n}\n"
    },
    "contracts/Deps/hats-protocol/lib/ERC1155/ERC1155.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Minimalist and gas efficient standard ERC1155 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC1155.sol)\nabstract contract ERC1155 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 amount\n    );\n\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] amounts\n    );\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    event URI(string value, uint256 indexed id);\n\n    /*//////////////////////////////////////////////////////////////\n                             ERC1155 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => mapping(uint256 => uint256)) internal _balanceOf;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*//////////////////////////////////////////////////////////////\n                             METADATA LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function uri(uint256 id) public view virtual returns (string memory);\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC1155 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual {\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \"NOT_AUTHORIZED\");\n\n        _balanceOf[from][id] -= amount;\n        _balanceOf[to][id] += amount;\n\n        emit TransferSingle(msg.sender, from, to, id, amount);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual {\n        require(ids.length == amounts.length, \"LENGTH_MISMATCH\");\n\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \"NOT_AUTHORIZED\");\n\n        // Storing these outside the loop saves ~15 gas per iteration.\n        uint256 id;\n        uint256 amount;\n\n        for (uint256 i = 0; i < ids.length; ) {\n            id = ids[i];\n            amount = amounts[i];\n\n            _balanceOf[from][id] -= amount;\n            _balanceOf[to][id] += amount;\n\n            // An array can't have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function balanceOf(address owner, uint256 id) public view virtual returns (uint256 balance) {\n        balance = _balanceOf[owner][id];\n    }\n\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\n        public\n        view\n        virtual\n        returns (uint256[] memory balances)\n    {\n        require(owners.length == ids.length, \"LENGTH_MISMATCH\");\n\n        balances = new uint256[](owners.length);\n\n        // Unchecked because the only math done is incrementing\n        // the array index counter which cannot possibly overflow.\n        unchecked {\n            for (uint256 i = 0; i < owners.length; ++i) {\n                balances[i] = _balanceOf[owners[i]][ids[i]];\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0xd9b67a26 || // ERC165 Interface ID for ERC1155\n            interfaceId == 0x0e89341c; // ERC165 Interface ID for ERC1155MetadataURI\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        _balanceOf[to][id] += amount;\n\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, address(0), id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _batchMint(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        uint256 idsLength = ids.length; // Saves MLOADs.\n\n        require(idsLength == amounts.length, \"LENGTH_MISMATCH\");\n\n        for (uint256 i = 0; i < idsLength; ) {\n            _balanceOf[to][ids[i]] += amounts[i];\n\n            // An array can't have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, address(0), ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _batchBurn(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        uint256 idsLength = ids.length; // Saves MLOADs.\n\n        require(idsLength == amounts.length, \"LENGTH_MISMATCH\");\n\n        for (uint256 i = 0; i < idsLength; ) {\n            _balanceOf[from][ids[i]] -= amounts[i];\n\n            // An array can't have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit TransferBatch(msg.sender, from, address(0), ids, amounts);\n    }\n\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        _balanceOf[from][id] -= amount;\n\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC1155 tokens.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC1155.sol)\nabstract contract ERC1155TokenReceiver {\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC1155TokenReceiver.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;\n    }\n}\n"
    },
    "contracts/Deps/hats-protocol/lib/solady/utils/Multicallable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Contract that enables a single call to call multiple methods on itself.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/Multicallable.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/Multicallable.sol)\nabstract contract Multicallable {\n    /// @dev Apply `DELEGATECALL` with the current contract to each calldata in `data`,\n    /// and store the `abi.encode` formatted results of each `DELEGATECALL` into `results`.\n    /// If any of the `DELEGATECALL`s reverts, the entire context is reverted,\n    /// and the error is bubbled up.\n    ///\n    /// This function is deliberately made non-payable to guard against double-spending.\n    /// (See: https://www.paradigm.xyz/2021/08/two-rights-might-make-a-wrong)\n    ///\n    /// For efficiency, this function will directly return the results, terminating the context.\n    /// If called internally, it must be called at the end of a function\n    /// that returns `(bytes[] memory)`.\n    function multicall(bytes[] calldata data) public virtual returns (bytes[] memory) {\n        assembly {\n            mstore(0x00, 0x20)\n            mstore(0x20, data.length) // Store `data.length` into `results`.\n            // Early return if no data.\n            if iszero(data.length) { return(0x00, 0x40) }\n\n            let results := 0x40\n            // `shl` 5 is equivalent to multiplying by 0x20.\n            let end := shl(5, data.length)\n            // Copy the offsets from calldata into memory.\n            calldatacopy(0x40, data.offset, end)\n            // Offset into `results`.\n            let resultsOffset := end\n            // Pointer to the end of `results`.\n            end := add(results, end)\n\n            for {} 1 {} {\n                // The offset of the current bytes in the calldata.\n                let o := add(data.offset, mload(results))\n                let memPtr := add(resultsOffset, 0x40)\n                // Copy the current bytes from calldata to the memory.\n                calldatacopy(\n                    memPtr,\n                    add(o, 0x20), // The offset of the current bytes' bytes.\n                    calldataload(o) // The length of the current bytes.\n                )\n                if iszero(delegatecall(gas(), address(), memPtr, calldataload(o), 0x00, 0x00)) {\n                    // Bubble up the revert if the delegatecall reverts.\n                    returndatacopy(0x00, 0x00, returndatasize())\n                    revert(0x00, returndatasize())\n                }\n                // Append the current `resultsOffset` into `results`.\n                mstore(results, resultsOffset)\n                results := add(results, 0x20)\n                // Append the `returndatasize()`, and the return data.\n                mstore(memPtr, returndatasize())\n                returndatacopy(add(memPtr, 0x20), 0x00, returndatasize())\n                // Advance the `resultsOffset` by `returndatasize() + 0x20`,\n                // rounded up to the next multiple of 32.\n                resultsOffset :=\n                    and(add(add(resultsOffset, returndatasize()), 0x3f), 0xffffffffffffffe0)\n                if iszero(lt(results, end)) { break }\n            }\n            return(0x00, add(resultsOffset, 0x40))\n        }\n    }\n}\n"
    },
    "contracts/Deps/hats-protocol/lib/solbase/utils/Base64.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library to encode and decode strings in Base64.\n/// @author SolDAO (https://github.com/Sol-DAO/solbase/blob/main/src/utils/Base64.sol)\n/// @author Modified from Solady (https://github.com/vectorized/solady/blob/main/src/utils/Base64.sol)\nlibrary Base64 {\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\n    /// See: https://datatracker.ietf.org/doc/html/rfc4648\n    /// @param fileSafe  Whether to replace '+' with '-' and '/' with '_'.\n    /// @param noPadding Whether to strip away the padding.\n    function encode(bytes memory data, bool fileSafe, bool noPadding) internal pure returns (string memory result) {\n        assembly {\n            let dataLength := mload(data)\n\n            if dataLength {\n                // Multiply by 4/3 rounded up.\n                // The `shl(2, ...)` is equivalent to multiplying by 4.\n                let encodedLength := shl(2, div(add(dataLength, 2), 3))\n\n                // Set `result` to point to the start of the free memory.\n                result := mload(0x40)\n\n                // Store the table into the scratch space.\n                // Offsetted by -1 byte so that the `mload` will load the character.\n                // We will rewrite the free memory pointer at `0x40` later with\n                // the allocated size.\n                // The magic constant 0x0230 will translate \"-_\" + \"+/\".\n                mstore(0x1f, \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef\")\n                mstore(0x3f, sub(\"ghijklmnopqrstuvwxyz0123456789-_\", mul(iszero(fileSafe), 0x0230)))\n\n                // Skip the first slot, which stores the length.\n                let ptr := add(result, 0x20)\n                let end := add(ptr, encodedLength)\n\n                // Run over the input, 3 bytes at a time.\n                // prettier-ignore\n                for {} 1 {} {\n                    data := add(data, 3) // Advance 3 bytes.\n                    let input := mload(data)\n\n                    // Write 4 bytes. Optimized for fewer stack operations.\n                    mstore8(    ptr    , mload(and(shr(18, input), 0x3F)))\n                    mstore8(add(ptr, 1), mload(and(shr(12, input), 0x3F)))\n                    mstore8(add(ptr, 2), mload(and(shr( 6, input), 0x3F)))\n                    mstore8(add(ptr, 3), mload(and(        input , 0x3F)))\n                    \n                    ptr := add(ptr, 4) // Advance 4 bytes.\n                    // prettier-ignore\n                    if iszero(lt(ptr, end)) { break }\n                }\n\n                let r := mod(dataLength, 3)\n\n                switch noPadding\n                case 0 {\n                    // Offset `ptr` and pad with '='. We can simply write over the end.\n                    mstore8(sub(ptr, iszero(iszero(r))), 0x3d) // Pad at `ptr - 1` if `r > 0`.\n                    mstore8(sub(ptr, shl(1, eq(r, 1))), 0x3d) // Pad at `ptr - 2` if `r == 1`.\n                    // Write the length of the string.\n                    mstore(result, encodedLength)\n                }\n                default {\n                    // Write the length of the string.\n                    mstore(result, sub(encodedLength, add(iszero(iszero(r)), eq(r, 1))))\n                }\n\n                // Allocate the memory for the string.\n                // Add 31 and mask with `not(31)` to round the\n                // free memory pointer up the next multiple of 32.\n                mstore(0x40, and(add(end, 31), not(31)))\n            }\n        }\n    }\n\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\n    /// Equivalent to `encode(data, false, false)`.\n    function encode(bytes memory data) internal pure returns (string memory result) {\n        result = encode(data, false, false);\n    }\n\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\n    /// Equivalent to `encode(data, fileSafe, false)`.\n    function encode(bytes memory data, bool fileSafe) internal pure returns (string memory result) {\n        result = encode(data, fileSafe, false);\n    }\n\n    /// @dev Decodes base64 encoded `data`.\n    ///\n    /// Supports:\n    /// - RFC 4648 (both standard and file-safe mode).\n    /// - RFC 3501 (63: ',').\n    ///\n    /// Does not support:\n    /// - Line breaks.\n    ///\n    /// Note: For performance reasons,\n    /// this function will NOT revert on invalid `data` inputs.\n    /// Outputs for invalid inputs will simply be undefined behaviour.\n    /// It is the user's responsibility to ensure that the `data`\n    /// is a valid base64 encoded string.\n    function decode(string memory data) internal pure returns (bytes memory result) {\n        assembly {\n            let dataLength := mload(data)\n\n            if dataLength {\n                let end := add(data, dataLength)\n                let decodedLength := mul(shr(2, dataLength), 3)\n\n                switch and(dataLength, 3)\n                case 0 {\n                    // If padded.\n                    decodedLength := sub(\n                        decodedLength,\n                        add(eq(and(mload(end), 0xFF), 0x3d), eq(and(mload(end), 0xFFFF), 0x3d3d))\n                    )\n                }\n                default {\n                    // If non-padded.\n                    decodedLength := add(decodedLength, sub(and(dataLength, 3), 1))\n                }\n\n                result := mload(0x40)\n\n                // Write the length of the string.\n                mstore(result, decodedLength)\n\n                // Skip the first slot, which stores the length.\n                let ptr := add(result, 0x20)\n\n                // Load the table into the scratch space.\n                // Constants are optimized for smaller bytecode with zero gas overhead.\n                // `m` also doubles as the mask of the upper 6 bits.\n                let m := 0xfc000000fc00686c7074787c8084888c9094989ca0a4a8acb0b4b8bcc0c4c8cc\n                mstore(0x5b, m)\n                mstore(0x3b, 0x04080c1014181c2024282c3034383c4044484c5054585c6064)\n                mstore(0x1a, 0xf8fcf800fcd0d4d8dce0e4e8ecf0f4)\n\n                // prettier-ignore\n                for {} 1 {} {\n                    // Read 4 bytes.\n                    data := add(data, 4)\n                    let input := mload(data)\n\n                    // Write 3 bytes.\n                    mstore(ptr, or(\n                        and(m, mload(byte(28, input))),\n                        shr(6, or(\n                            and(m, mload(byte(29, input))),\n                            shr(6, or(\n                                and(m, mload(byte(30, input))),\n                                shr(6, mload(byte(31, input)))\n                            ))\n                        ))\n                    ))\n\n                    ptr := add(ptr, 3)\n                    \n                    // prettier-ignore\n                    if iszero(lt(data, end)) { break }\n                }\n\n                // Allocate the memory for the string.\n                // Add 32 + 31 and mask with `not(31)` to round the\n                // free memory pointer up the next multiple of 32.\n                mstore(0x40, and(add(add(result, decodedLength), 63), not(31)))\n\n                // Restore the zero slot.\n                mstore(0x60, 0)\n            }\n        }\n    }\n}\n"
    },
    "contracts/Deps/hats-protocol/lib/solbase/utils/LibString.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for converting numbers into strings and other string operations.\n/// @author SolDAO (https://github.com/Sol-DAO/solbase/blob/main/src/utils/LibString.sol)\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibString.sol)\nlibrary LibString {\n    /// -----------------------------------------------------------------------\n    /// Custom Errors\n    /// -----------------------------------------------------------------------\n\n    /// @dev The `length` of the output is too small to contain all the hex digits.\n    error HexLengthInsufficient();\n\n    /// -----------------------------------------------------------------------\n    /// Constants\n    /// -----------------------------------------------------------------------\n\n    /// @dev The constant returned when the `search` is not found in the string.\n    uint256 internal constant NOT_FOUND = uint256(int256(-1));\n\n    /// -----------------------------------------------------------------------\n    /// Decimal Operations\n    /// -----------------------------------------------------------------------\n\n    /// @dev Returns the base 10 decimal representation of `value`.\n    function toString(uint256 value) internal pure returns (string memory str) {\n        assembly {\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\n            // and 3 words for a maximum of 78 digits. Total: 5 * 0x20 = 0xa0.\n            let m := add(mload(0x40), 0xa0)\n            // Update the free memory pointer to allocate.\n            mstore(0x40, m)\n            // Assign the `str` to the end.\n            str := sub(m, 0x20)\n            // Zeroize the slot after the string.\n            mstore(str, 0)\n\n            // Cache the end of the memory to calculate the length later.\n            let end := str\n\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            // prettier-ignore\n            for { let temp := value } 1 {} {\n                str := sub(str, 1)\n                // Write the character to the pointer.\n                // The ASCII index of the '0' character is 48.\n                mstore8(str, add(48, mod(temp, 10)))\n                // Keep dividing `temp` until zero.\n                temp := div(temp, 10)\n                // prettier-ignore\n                if iszero(temp) { break }\n            }\n\n            let length := sub(end, str)\n            // Move the pointer 32 bytes leftwards to make room for the length.\n            str := sub(str, 0x20)\n            // Store the length.\n            mstore(str, length)\n        }\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Hexadecimal Operations\n    /// -----------------------------------------------------------------------\n\n    /// @dev Returns the hexadecimal representation of `value`,\n    /// left-padded to an input length of `length` bytes.\n    /// The output is prefixed with \"0x\" encoded using 2 hexadecimal digits per byte,\n    /// giving a total length of `length * 2 + 2` bytes.\n    /// Reverts if `length` is too small for the output to contain all the digits.\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory str) {\n        assembly {\n            let start := mload(0x40)\n            // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes\n            // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.\n            // We add 0x20 to the total and round down to a multiple of 0x20.\n            // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.\n            let m := add(start, and(add(shl(1, length), 0x62), not(0x1f)))\n            // Allocate the memory.\n            mstore(0x40, m)\n            // Assign the `str` to the end.\n            str := sub(m, 0x20)\n            // Zeroize the slot after the string.\n            mstore(str, 0)\n\n            // Cache the end to calculate the length later.\n            let end := str\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            let temp := value\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            // prettier-ignore\n            for {} 1 {} {\n                str := sub(str, 2)\n                mstore8(add(str, 1), mload(and(temp, 15)))\n                mstore8(str, mload(and(shr(4, temp), 15)))\n                temp := shr(8, temp)\n                length := sub(length, 1)\n                // prettier-ignore\n                if iszero(length) { break }\n            }\n\n            if temp {\n                // Store the function selector of `HexLengthInsufficient()`.\n                mstore(0x00, 0x2194895a)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // Compute the string's length.\n            let strLength := add(sub(end, str), 2)\n            // Move the pointer and write the \"0x\" prefix.\n            str := sub(str, 0x20)\n            mstore(str, 0x3078)\n            // Move the pointer and write the length.\n            str := sub(str, 2)\n            mstore(str, strLength)\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\" and encoded using 2 hexadecimal digits per byte.\n    /// As address are 20 bytes long, the output will left-padded to have\n    /// a length of `20 * 2 + 2` bytes.\n    function toHexString(uint256 value) internal pure returns (string memory str) {\n        assembly {\n            let start := mload(0x40)\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\n            // 0x02 bytes for the prefix, and 0x40 bytes for the digits.\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.\n            let m := add(start, 0xa0)\n            // Allocate the memory.\n            mstore(0x40, m)\n            // Assign the `str` to the end.\n            str := sub(m, 0x20)\n            // Zeroize the slot after the string.\n            mstore(str, 0)\n\n            // Cache the end to calculate the length later.\n            let end := str\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            // prettier-ignore\n            for { let temp := value } 1 {} {\n                str := sub(str, 2)\n                mstore8(add(str, 1), mload(and(temp, 15)))\n                mstore8(str, mload(and(shr(4, temp), 15)))\n                temp := shr(8, temp)\n                // prettier-ignore\n                if iszero(temp) { break }\n            }\n\n            // Compute the string's length.\n            let strLength := add(sub(end, str), 2)\n            // Move the pointer and write the \"0x\" prefix.\n            str := sub(str, 0x20)\n            mstore(str, 0x3078)\n            // Move the pointer and write the length.\n            str := sub(str, 2)\n            mstore(str, strLength)\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\" and encoded using 2 hexadecimal digits per byte.\n    function toHexString(address value) internal pure returns (string memory str) {\n        assembly {\n            let start := mload(0x40)\n            // We need 0x20 bytes for the length, 0x02 bytes for the prefix,\n            // and 0x28 bytes for the digits.\n            // The next multiple of 0x20 above (0x20 + 0x02 + 0x28) is 0x60.\n            str := add(start, 0x60)\n\n            // Allocate the memory.\n            mstore(0x40, str)\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            let length := 20\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            // prettier-ignore\n            for { let temp := value } 1 {} {\n                str := sub(str, 2)\n                mstore8(add(str, 1), mload(and(temp, 15)))\n                mstore8(str, mload(and(shr(4, temp), 15)))\n                temp := shr(8, temp)\n                length := sub(length, 1)\n                // prettier-ignore\n                if iszero(length) { break }\n            }\n\n            // Move the pointer and write the \"0x\" prefix.\n            str := sub(str, 32)\n            mstore(str, 0x3078)\n            // Move the pointer and write the length.\n            str := sub(str, 2)\n            mstore(str, 42)\n        }\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Other String Operations\n    /// -----------------------------------------------------------------------\n\n    // For performance and bytecode compactness, all indices of the following operations\n    // are byte (ASCII) offsets, not UTF character offsets.\n\n    /// @dev Returns `subject` all occurances of `search` replaced with `replacement`.\n    function replace(\n        string memory subject,\n        string memory search,\n        string memory replacement\n    ) internal pure returns (string memory result) {\n        assembly {\n            let subjectLength := mload(subject)\n            let searchLength := mload(search)\n            let replacementLength := mload(replacement)\n\n            subject := add(subject, 0x20)\n            search := add(search, 0x20)\n            replacement := add(replacement, 0x20)\n            result := add(mload(0x40), 0x20)\n\n            let subjectEnd := add(subject, subjectLength)\n            if iszero(gt(searchLength, subjectLength)) {\n                let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)\n                let h := 0\n                if iszero(lt(searchLength, 32)) {\n                    h := keccak256(search, searchLength)\n                }\n                let m := shl(3, sub(32, and(searchLength, 31)))\n                let s := mload(search)\n                // prettier-ignore\n                for {} 1 {} {\n                    let t := mload(subject)\n                    // Whether the first `searchLength % 32` bytes of \n                    // `subject` and `search` matches.\n                    if iszero(shr(m, xor(t, s))) {\n                        if h {\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\n                                mstore(result, t)\n                                result := add(result, 1)\n                                subject := add(subject, 1)\n                                // prettier-ignore\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\n                                continue\n                            }\n                        }\n                        // Copy the `replacement` one word at a time.\n                        // prettier-ignore\n                        for { let o := 0 } 1 {} {\n                            mstore(add(result, o), mload(add(replacement, o)))\n                            o := add(o, 0x20)\n                            // prettier-ignore\n                            if iszero(lt(o, replacementLength)) { break }\n                        }\n                        result := add(result, replacementLength)\n                        subject := add(subject, searchLength)\n                        if searchLength {\n                            // prettier-ignore\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\n                            continue\n                        }\n                    }\n                    mstore(result, t)\n                    result := add(result, 1)\n                    subject := add(subject, 1)\n                    // prettier-ignore\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\n                }\n            }\n\n            let resultRemainder := result\n            result := add(mload(0x40), 0x20)\n            let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))\n            // Copy the rest of the string one word at a time.\n            // prettier-ignore\n            for {} lt(subject, subjectEnd) {} {\n                mstore(resultRemainder, mload(subject))\n                resultRemainder := add(resultRemainder, 0x20)\n                subject := add(subject, 0x20)\n            }\n            result := sub(result, 0x20)\n            // Zeroize the slot after the string.\n            let last := add(add(result, 0x20), k)\n            mstore(last, 0)\n            // Allocate memory for the length and the bytes,\n            // rounded up to a multiple of 32.\n            mstore(0x40, and(add(last, 31), not(31)))\n            // Store the length of the result.\n            mstore(result, k)\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from left to right, starting from `from`.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function indexOf(string memory subject, string memory search, uint256 from) internal pure returns (uint256 result) {\n        assembly {\n            // prettier-ignore\n            for { let subjectLength := mload(subject) } 1 {} {\n                if iszero(mload(search)) {\n                    // `result = min(from, subjectLength)`.\n                    result := xor(from, mul(xor(from, subjectLength), lt(subjectLength, from)))\n                    break\n                }\n                let searchLength := mload(search)\n                let subjectStart := add(subject, 0x20)    \n                \n                result := not(0) // Initialize to `NOT_FOUND`.\n\n                subject := add(subjectStart, from)\n                let subjectSearchEnd := add(sub(add(subjectStart, subjectLength), searchLength), 1)\n\n                let m := shl(3, sub(32, and(searchLength, 31)))\n                let s := mload(add(search, 0x20))\n\n                // prettier-ignore\n                if iszero(lt(subject, subjectSearchEnd)) { break }\n\n                if iszero(lt(searchLength, 32)) {\n                    // prettier-ignore\n                    for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\n                        if iszero(shr(m, xor(mload(subject), s))) {\n                            if eq(keccak256(subject, searchLength), h) {\n                                result := sub(subject, subjectStart)\n                                break\n                            }\n                        }\n                        subject := add(subject, 1)\n                        // prettier-ignore\n                        if iszero(lt(subject, subjectSearchEnd)) { break }\n                    }\n                    break\n                }\n                // prettier-ignore\n                for {} 1 {} {\n                    if iszero(shr(m, xor(mload(subject), s))) {\n                        result := sub(subject, subjectStart)\n                        break\n                    }\n                    subject := add(subject, 1)\n                    // prettier-ignore\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\n                }\n                break\n            }\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from left to right.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function indexOf(string memory subject, string memory search) internal pure returns (uint256 result) {\n        result = indexOf(subject, search, 0);\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from right to left, starting from `from`.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function lastIndexOf(\n        string memory subject,\n        string memory search,\n        uint256 from\n    ) internal pure returns (uint256 result) {\n        assembly {\n            // prettier-ignore\n            for {} 1 {} {\n                let searchLength := mload(search)\n                let fromMax := sub(mload(subject), searchLength)\n                if iszero(gt(fromMax, from)) {\n                    from := fromMax\n                }\n                if iszero(mload(search)) {\n                    result := from\n                    break\n                }\n                result := not(0) // Initialize to `NOT_FOUND`.\n\n                let subjectSearchEnd := sub(add(subject, 0x20), 1)\n\n                subject := add(add(subject, 0x20), from)\n                // prettier-ignore\n                if iszero(gt(subject, subjectSearchEnd)) { break }\n                // As this function is not too often used,\n                // we shall simply use keccak256 for smaller bytecode size.\n                // prettier-ignore\n                for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\n                    if eq(keccak256(subject, searchLength), h) {\n                        result := sub(subject, add(subjectSearchEnd, 1))\n                        break\n                    }\n                    subject := sub(subject, 1)\n                    // prettier-ignore\n                    if iszero(gt(subject, subjectSearchEnd)) { break }\n                }\n                break\n            }\n        }\n    }\n\n    /// @dev Returns the index of the first location of `search` in `subject`,\n    /// searching from right to left.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function lastIndexOf(string memory subject, string memory search) internal pure returns (uint256 result) {\n        result = lastIndexOf(subject, search, uint256(int256(-1)));\n    }\n\n    /// @dev Returns whether `subject` starts with `search`.\n    function startsWith(string memory subject, string memory search) internal pure returns (bool result) {\n        assembly {\n            let searchLength := mload(search)\n            // Just using keccak256 directly is actually cheaper.\n            result := and(\n                iszero(gt(searchLength, mload(subject))),\n                eq(keccak256(add(subject, 0x20), searchLength), keccak256(add(search, 0x20), searchLength))\n            )\n        }\n    }\n\n    /// @dev Returns whether `subject` ends with `search`.\n    function endsWith(string memory subject, string memory search) internal pure returns (bool result) {\n        assembly {\n            let searchLength := mload(search)\n            let subjectLength := mload(subject)\n            // Whether `search` is not longer than `subject`.\n            let withinRange := iszero(gt(searchLength, subjectLength))\n            // Just using keccak256 directly is actually cheaper.\n            result := and(\n                withinRange,\n                eq(\n                    keccak256(\n                        // `subject + 0x20 + max(subjectLength - searchLength, 0)`.\n                        add(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),\n                        searchLength\n                    ),\n                    keccak256(add(search, 0x20), searchLength)\n                )\n            )\n        }\n    }\n\n    /// @dev Returns `subject` repeated `times`.\n    function repeat(string memory subject, uint256 times) internal pure returns (string memory result) {\n        assembly {\n            let subjectLength := mload(subject)\n            if iszero(or(iszero(times), iszero(subjectLength))) {\n                subject := add(subject, 0x20)\n                result := mload(0x40)\n                let output := add(result, 0x20)\n                // prettier-ignore\n                for {} 1 {} {\n                    // Copy the `subject` one word at a time.\n                    // prettier-ignore\n                    for { let o := 0 } 1 {} {\n                        mstore(add(output, o), mload(add(subject, o)))\n                        o := add(o, 0x20)\n                        // prettier-ignore\n                        if iszero(lt(o, subjectLength)) { break }\n                    }\n                    output := add(output, subjectLength)\n                    times := sub(times, 1)\n                    // prettier-ignore\n                    if iszero(times) { break }\n                }\n                // Zeroize the slot after the string.\n                mstore(output, 0)\n                // Store the length.\n                let resultLength := sub(output, add(result, 0x20))\n                mstore(result, resultLength)\n                // Allocate memory for the length and the bytes,\n                // rounded up to a multiple of 32.\n                mstore(0x40, add(result, and(add(resultLength, 63), not(31))))\n            }\n        }\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\n    /// `start` and `end` are byte offsets.\n    function slice(string memory subject, uint256 start, uint256 end) internal pure returns (string memory result) {\n        assembly {\n            let subjectLength := mload(subject)\n            if iszero(gt(subjectLength, end)) {\n                end := subjectLength\n            }\n            if iszero(gt(subjectLength, start)) {\n                start := subjectLength\n            }\n            if lt(start, end) {\n                result := mload(0x40)\n                let resultLength := sub(end, start)\n                mstore(result, resultLength)\n                subject := add(subject, start)\n                // Copy the `subject` one word at a time, backwards.\n                // prettier-ignore\n                for { let o := and(add(resultLength, 31), not(31)) } 1 {} {\n                    mstore(add(result, o), mload(add(subject, o)))\n                    o := sub(o, 0x20)\n                    // prettier-ignore\n                    if iszero(o) { break }\n                }\n                // Zeroize the slot after the string.\n                mstore(add(add(result, 0x20), resultLength), 0)\n                // Allocate memory for the length and the bytes,\n                // rounded up to a multiple of 32.\n                mstore(0x40, add(result, and(add(resultLength, 63), not(31))))\n            }\n        }\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the string.\n    /// `start` is a byte offset.\n    function slice(string memory subject, uint256 start) internal pure returns (string memory result) {\n        result = slice(subject, start, uint256(int256(-1)));\n    }\n\n    /// @dev Returns all the indices of `search` in `subject`.\n    /// The indices are byte offsets.\n    function indicesOf(string memory subject, string memory search) internal pure returns (uint256[] memory result) {\n        assembly {\n            let subjectLength := mload(subject)\n            let searchLength := mload(search)\n\n            if iszero(gt(searchLength, subjectLength)) {\n                subject := add(subject, 0x20)\n                search := add(search, 0x20)\n                result := add(mload(0x40), 0x20)\n\n                let subjectStart := subject\n                let subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)\n                let h := 0\n                if iszero(lt(searchLength, 32)) {\n                    h := keccak256(search, searchLength)\n                }\n                let m := shl(3, sub(32, and(searchLength, 31)))\n                let s := mload(search)\n                // prettier-ignore\n                for {} 1 {} {\n                    let t := mload(subject)\n                    // Whether the first `searchLength % 32` bytes of \n                    // `subject` and `search` matches.\n                    if iszero(shr(m, xor(t, s))) {\n                        if h {\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\n                                subject := add(subject, 1)\n                                // prettier-ignore\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\n                                continue\n                            }\n                        }\n                        // Append to `result`.\n                        mstore(result, sub(subject, subjectStart))\n                        result := add(result, 0x20)\n                        // Advance `subject` by `searchLength`.\n                        subject := add(subject, searchLength)\n                        if searchLength {\n                            // prettier-ignore\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\n                            continue\n                        }\n                    }\n                    subject := add(subject, 1)\n                    // prettier-ignore\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\n                }\n                let resultEnd := result\n                // Assign `result` to the free memory pointer.\n                result := mload(0x40)\n                // Store the length of `result`.\n                mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))\n                // Allocate memory for result.\n                // We allocate one more word, so this array can be recycled for {split}.\n                mstore(0x40, add(resultEnd, 0x20))\n            }\n        }\n    }\n\n    /// @dev Returns a arrays of strings based on the `delimiter` inside of the `subject` string.\n    function split(string memory subject, string memory delimiter) internal pure returns (string[] memory result) {\n        uint256[] memory indices = indicesOf(subject, delimiter);\n        assembly {\n            if mload(indices) {\n                let indexPtr := add(indices, 0x20)\n                let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))\n                mstore(sub(indicesEnd, 0x20), mload(subject))\n                mstore(indices, add(mload(indices), 1))\n                let prevIndex := 0\n                // prettier-ignore\n                for {} 1 {} {\n                    let index := mload(indexPtr)\n                    mstore(indexPtr, 0x60)                        \n                    if iszero(eq(index, prevIndex)) {\n                        let element := mload(0x40)\n                        let elementLength := sub(index, prevIndex)\n                        mstore(element, elementLength)\n                        // Copy the `subject` one word at a time, backwards.\n                        // prettier-ignore\n                        for { let o := and(add(elementLength, 31), not(31)) } 1 {} {\n                            mstore(add(element, o), mload(add(add(subject, prevIndex), o)))\n                            o := sub(o, 0x20)\n                            // prettier-ignore\n                            if iszero(o) { break }\n                        }\n                        // Zeroize the slot after the string.\n                        mstore(add(add(element, 0x20), elementLength), 0)\n                        // Allocate memory for the length and the bytes,\n                        // rounded up to a multiple of 32.\n                        mstore(0x40, add(element, and(add(elementLength, 63), not(31))))\n                        // Store the `element` into the array.\n                        mstore(indexPtr, element)                        \n                    }\n                    prevIndex := add(index, mload(delimiter))\n                    indexPtr := add(indexPtr, 0x20)\n                    // prettier-ignore\n                    if iszero(lt(indexPtr, indicesEnd)) { break }\n                }\n                result := indices\n                if iszero(mload(delimiter)) {\n                    result := add(indices, 0x20)\n                    mstore(result, sub(mload(indices), 2))\n                }\n            }\n        }\n    }\n\n    /// @dev Returns a concatenated string of `a` and `b`.\n    /// Cheaper than `string.concat()` and does not de-align the free memory pointer.\n    function concat(string memory a, string memory b) internal pure returns (string memory result) {\n        assembly {\n            result := mload(0x40)\n            let aLength := mload(a)\n            // Copy `a` one word at a time, backwards.\n            // prettier-ignore\n            for { let o := and(add(mload(a), 32), not(31)) } 1 {} {\n                mstore(add(result, o), mload(add(a, o)))\n                o := sub(o, 0x20)\n                // prettier-ignore\n                if iszero(o) { break }\n            }\n            let bLength := mload(b)\n            let output := add(result, mload(a))\n            // Copy `b` one word at a time, backwards.\n            // prettier-ignore\n            for { let o := and(add(bLength, 32), not(31)) } 1 {} {\n                mstore(add(output, o), mload(add(b, o)))\n                o := sub(o, 0x20)\n                // prettier-ignore\n                if iszero(o) { break }\n            }\n            let totalLength := add(aLength, bLength)\n            let last := add(add(result, 0x20), totalLength)\n            // Zeroize the slot after the string.\n            mstore(last, 0)\n            // Stores the length.\n            mstore(result, totalLength)\n            // Allocate memory for the length and the bytes,\n            // rounded up to a multiple of 32.\n            mstore(0x40, and(add(last, 31), not(31)))\n        }\n    }\n\n    /// @dev Packs a single string with its length into a single word.\n    /// Returns `bytes32(0)` if the length is zero or greater than 31.\n    function packOne(string memory a) internal pure returns (bytes32 result) {\n        assembly {\n            // We don't need to zero right pad the string,\n            // since this is our own custom non-standard packing scheme.\n            result := mul(\n                // Load the length and the bytes.\n                mload(add(a, 0x1f)),\n                // `length != 0 && length < 32`. Abuses underflow.\n                // Assumes that the length is valid and within the block gas limit.\n                lt(sub(mload(a), 1), 0x1f)\n            )\n        }\n    }\n\n    /// @dev Unpacks a string packed using {packOne}.\n    /// Returns the empty string if `packed` is `bytes32(0)`.\n    /// If `packed` is not an output of {packOne}, the output behaviour is undefined.\n    function unpackOne(bytes32 packed) internal pure returns (string memory result) {\n        assembly {\n            // Grab the free memory pointer.\n            result := mload(0x40)\n            // Allocate 2 words (1 for the length, 1 for the bytes).\n            mstore(0x40, add(result, 0x40))\n            // Zeroize the length slot.\n            mstore(result, 0)\n            // Store the length and bytes.\n            mstore(add(result, 0x1f), packed)\n            // Right pad with zeroes.\n            mstore(add(add(result, 0x20), mload(result)), 0)\n        }\n    }\n\n    /// @dev Packs two strings with their lengths into a single word.\n    /// Returns `bytes32(0)` if combined length is zero or greater than 30.\n    function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {\n        assembly {\n            let aLength := mload(a)\n            // We don't need to zero right pad the strings,\n            // since this is our own custom non-standard packing scheme.\n            result := mul(\n                // Load the length and the bytes of `a` and `b`.\n                or(shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))), mload(sub(add(b, 0x1e), aLength))),\n                // `totalLength != 0 && totalLength < 31`. Abuses underflow.\n                // Assumes that the lengths are valid and within the block gas limit.\n                lt(sub(add(aLength, mload(b)), 1), 0x1e)\n            )\n        }\n    }\n\n    /// @dev Unpacks strings packed using {packTwo}.\n    /// Returns the empty strings if `packed` is `bytes32(0)`.\n    /// If `packed` is not an output of {packTwo}, the output behaviour is undefined.\n    function unpackTwo(bytes32 packed) internal pure returns (string memory resultA, string memory resultB) {\n        assembly {\n            // Grab the free memory pointer.\n            resultA := mload(0x40)\n            resultB := add(resultA, 0x40)\n            // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.\n            mstore(0x40, add(resultB, 0x40))\n            // Zeroize the length slots.\n            mstore(resultA, 0)\n            mstore(resultB, 0)\n            // Store the lengths and bytes.\n            mstore(add(resultA, 0x1f), packed)\n            mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))\n            // Right pad with zeroes.\n            mstore(add(add(resultA, 0x20), mload(resultA)), 0)\n            mstore(add(add(resultB, 0x20), mload(resultB)), 0)\n        }\n    }\n\n    /// @dev Directly returns `a` without copying.\n    function directReturn(string memory a) internal pure {\n        assembly {\n            // Right pad with zeroes. Just in case the string is produced\n            // by a method that doesn't zero right pad.\n            mstore(add(add(a, 0x20), mload(a)), 0)\n            // Store the return offset.\n            // Assumes that the string does not start from the scratch space.\n            mstore(sub(a, 0x20), 0x20)\n            // End the transaction, returning the string.\n            return(sub(a, 0x20), add(mload(a), 0x40))\n        }\n    }\n}\n"
    },
    "contracts/Deps/PreferredProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport {ERC1967Proxy} from \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\";\r\n\r\ncontract PreferredProxy is ERC1967Proxy {\r\n    constructor(\r\n        address _logic,\r\n        bytes memory _data\r\n    ) payable ERC1967Proxy(_logic, _data) {}\r\n}\r\n"
    },
    "contracts/Escrow.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\ncontract Escrow {\r\n    error AlreadyInitialized();\r\n    error NotOwner();\r\n\r\n    address private owner;\r\n\r\n    receive() external payable {}\r\n\r\n    fallback() external payable {}\r\n\r\n    /// @notice Initializes the Escrow with the sender of the transaction as owner.\r\n    /// @dev This should be called in the same transaction as deploying the escrow, to prevent front running.\r\n    function __Escrow_init() external payable {\r\n        if (owner != address(0)) {\r\n            revert AlreadyInitialized();\r\n        }\r\n\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /// @notice Transfers a certain amount of ERC20 token to a given address. Can only be called by the owner.\r\n    /// @param token The ERC20 contract address.\r\n    /// @param to The address to recieve the tokens.\r\n    /// @param amount The amount of ERC20 token to receive.\r\n    function transfer(IERC20 token, address to, uint256 amount) external {\r\n        if (msg.sender != owner) {\r\n            revert NotOwner();\r\n        }\r\n\r\n        token.transfer(to, amount);\r\n    }\r\n\r\n    /// @notice Transfers a certain amount of native currency to a given address. Can only be called by the owner.\r\n    /// @param to The address to recieve the currency.\r\n    /// @param amount The amount of native currency to receive.\r\n    function transferNative(address payable to, uint256 amount) external {\r\n        if (msg.sender != owner) {\r\n            revert NotOwner();\r\n        }\r\n\r\n        to.transfer(amount);\r\n    }\r\n}\r\n"
    },
    "contracts/mocks/MockERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\n\r\n/*\r\n  Obviously this is not a contract that will be used in the actual platform, only for testing purposes.\r\n*/\r\ncontract MockERC20 is ERC20 {\r\n    constructor(\r\n        string memory name_,\r\n        string memory symbol_\r\n    ) ERC20(name_, symbol_) {}\r\n\r\n    function increaseBalance(address account, uint256 amount) public {\r\n        _mint(account, amount);\r\n    }\r\n\r\n    function decreaseBalance(address account, uint256 amount) public {\r\n        _burn(account, amount);\r\n    }\r\n\r\n    function setBalance(address account, uint256 amount) external {\r\n        uint256 currentBalance = balanceOf(account);\r\n        if (amount > currentBalance) {\r\n            increaseBalance(account, amount - currentBalance);\r\n        } else if (amount < currentBalance) {\r\n            decreaseBalance(account, currentBalance - amount);\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/mocks/MockERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport {ERC721} from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\r\n\r\n/*\r\n  Obviously this is not a contract that will be used in the actual platform, only for testing purposes.\r\n*/\r\ncontract MockERC721 is ERC721 {\r\n    constructor(\r\n        string memory name_,\r\n        string memory symbol_\r\n    ) ERC721(name_, symbol_) {}\r\n\r\n    function grantToken(address account, uint256 tokenId) external {\r\n        _mint(account, tokenId);\r\n    }\r\n\r\n    function burnToken(uint256 tokenId) external {\r\n        _burn(tokenId);\r\n    }\r\n}\r\n"
    },
    "contracts/RFP/IRFPs.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport {Escrow} from \"../Escrow.sol\";\r\nimport {ITasks} from \"../Tasks/ITasks.sol\";\r\n\r\ninterface IRFPs {\r\n    error RFPDoesNotExist();\r\n    error RFPClosed();\r\n    error NotManager();\r\n    error ProjectDoesNotExist();\r\n    error ProjectAlreadyAccepted();\r\n    error RewardDoesntEndWithNextToken();\r\n\r\n    error Overflow();\r\n    error ERC1167FailedCreateClone();\r\n\r\n    event RFPCreated(\r\n        uint256 indexed rfpId,\r\n        string metadata,\r\n        uint64 deadline,\r\n        ITasks.ERC20Transfer[] budget,\r\n        uint96 nativeBudget,\r\n        address creator,\r\n        address tasksManager,\r\n        address manager\r\n    );\r\n    event ProjectSubmitted(\r\n        uint256 indexed rfpId,\r\n        uint16 projectId,\r\n        string metadata,\r\n        address representative,\r\n        uint64 deadline,\r\n        ITasks.Reward[] reward,\r\n        ITasks.NativeReward[] nativeReward\r\n    );\r\n    event ProjectAccepted(\r\n        uint256 indexed rfpId,\r\n        uint16 projectId,\r\n        uint256 taskId\r\n    );\r\n    event RFPEmptied(uint256 indexed rfpId);\r\n\r\n    /// @notice A container for a RFP project.\r\n    /// @param metadata Metadata of the project. (IPFS hash)\r\n    /// @param representative Who has submitted this project.\r\n    /// @param deadline The deadline after which the project should be completed.\r\n    /// @param accepted If the project has been accepted. To prevent 2 OpenR&D tasks from being created.\r\n    /// @param reward How much rewards the representative wants for completion.\r\n    /// @param nativeReward How much native currency the representative wants for completion.\r\n    struct Project {\r\n        string metadata;\r\n        address representative;\r\n        uint64 deadline;\r\n        bool accepted;\r\n        uint8 rewardCount;\r\n        uint8 nativeRewardCount;\r\n        mapping(uint8 => ITasks.Reward) reward;\r\n        mapping(uint8 => ITasks.NativeReward) nativeReward;\r\n    }\r\n\r\n    struct OffchainProject {\r\n        string metadata;\r\n        address representative;\r\n        uint64 deadline;\r\n        bool accepted;\r\n        ITasks.Reward[] reward;\r\n        ITasks.NativeReward[] nativeReward;\r\n    }\r\n\r\n    /// @notice A container for RFP-related information.\r\n    /// @param metadata Metadata of the RFP. (IPFS hash)\r\n    /// @param deadline Block timestamp at which the RFP closes.\r\n    /// @param budget The ERC20 contract that compose the budget.\r\n    /// @param nativeBudget Maximum native currency reward available for projects of the RFP.\r\n    /// @param creator Who has created the RFP.\r\n    /// @param tasksManager Who has the permission to manage the OpenR&D tasks.\r\n    /// @param manager Who has the permission to manage the RFP.\r\n    /// @param projects Projects that want to be funded by the RFP.\r\n    struct RFP {\r\n        string metadata;\r\n        // Storage block seperator\r\n        uint64 deadline;\r\n        Escrow escrow;\r\n        // Storage block seperator\r\n        uint96 nativeBudget;\r\n        address creator;\r\n        // Storage block seperator\r\n        address tasksManager;\r\n        // Storage block seperator\r\n        address manager;\r\n        uint8 budgetCount;\r\n        uint16 projectCount;\r\n        // Storage block seperator\r\n        mapping(uint8 => IERC20) budget;\r\n        mapping(uint16 => Project) projects;\r\n    }\r\n\r\n    struct OffChainRFP {\r\n        string metadata;\r\n        uint64 deadline;\r\n        Escrow escrow;\r\n        uint96 nativeBudget;\r\n        address creator;\r\n        address tasksManager;\r\n        address manager;\r\n        IERC20[] budget;\r\n        OffchainProject[] projects;\r\n    }\r\n\r\n    /// @notice Retrieves the current amount of created RFPs.\r\n    function rfpCount() external view returns (uint256);\r\n\r\n    /// @notice Retrieves all RFP information by id.\r\n    /// @param _rfpId Id of the RFP.\r\n    function getRFP(uint256 _rfpId) external view returns (OffChainRFP memory);\r\n\r\n    /// @notice Retrieves multiple RFPs.\r\n    /// @param _rfpIds Ids of the RFPs.\r\n    function getRFPs(\r\n        uint256[] calldata _rfpIds\r\n    ) external view returns (OffChainRFP[] memory);\r\n\r\n    /// @notice Create a new RFP.\r\n    /// @param _metadata Metadata of the RFP. (IPFS hash)\r\n    /// @param _deadline Block timestamp at which the RFP closes.\r\n    /// @param _budget Maximum ERC20 rewards avaliable for projects of the RFP.\r\n    /// @param _tasksManager Who will manage the project Tasks (become the OpenR&D manager).\r\n    /// @param _manager Who will manage the RFP (become the manager).\r\n    /// @return rfpId Id of the newly created RFP.\r\n    function createRFP(\r\n        string calldata _metadata,\r\n        uint64 _deadline,\r\n        ITasks.ERC20Transfer[] calldata _budget,\r\n        address _tasksManager,\r\n        address _manager\r\n    ) external payable returns (uint256 rfpId);\r\n\r\n    /// @notice Propose a project to be funded by an RFP.\r\n    /// @param _rfpId Id of the RFP.\r\n    /// @param _metadata Metadata of your project.\r\n    /// @param _deadline Before when the proposed project will be completed.\r\n    /// @param _reward Wanted rewards from the RFP for the project.\r\n    /// @param _nativeReward Wanted native currency from the RFP for the project.\r\n    function submitProject(\r\n        uint256 _rfpId,\r\n        string calldata _metadata,\r\n        uint64 _deadline,\r\n        ITasks.Reward[] calldata _reward,\r\n        ITasks.NativeReward[] calldata _nativeReward\r\n    ) external returns (uint16 projectId);\r\n\r\n    /// @notice Accept project to be funnded by the RFP.\r\n    /// @param _rfpId Id of the RFP.\r\n    /// @param _projectId Id of the project to accept.\r\n    function acceptProject(uint256 _rfpId, uint16 _projectId) external;\r\n\r\n    /// @notice Refunds any leftover budget to the creator.\r\n    /// @param _rfpId Id of the RFP.\r\n    function emptyRFP(uint256 _rfpId) external;\r\n}\r\n"
    },
    "contracts/RFP/RFPs.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport {IRFPs, IERC20, Escrow, ITasks} from \"./IRFPs.sol\";\r\n\r\ncontract RFPs is IRFPs {\r\n    /// @notice The Tasks deployment where accepted projects will be created.\r\n    ITasks private tasks;\r\n\r\n    /// @notice The incremental ID for RFPs.\r\n    uint256 private rfpCounter;\r\n\r\n    /// @notice A mapping between RFP IDs and RFP information.\r\n    mapping(uint256 => RFP) internal rfps;\r\n\r\n    /// @notice The base escrow contract that will be cloned for every RFP.\r\n    address public immutable escrowImplementation;\r\n\r\n    constructor(ITasks _tasks) {\r\n        tasks = _tasks;\r\n        escrowImplementation = address(new Escrow());\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    /// @inheritdoc IRFPs\r\n    function rfpCount() external view returns (uint256) {\r\n        return rfpCounter;\r\n    }\r\n\r\n    /// @inheritdoc IRFPs\r\n    function getRFP(\r\n        uint256 _rfpId\r\n    ) public view returns (OffChainRFP memory offchainRFP) {\r\n        RFP storage rfp = _getRFP(_rfpId);\r\n        offchainRFP = _toOffchainRFP(rfp);\r\n    }\r\n\r\n    /// @inheritdoc IRFPs\r\n    function getRFPs(\r\n        uint256[] memory _rfpIds\r\n    ) public view returns (OffChainRFP[] memory) {\r\n        OffChainRFP[] memory offchainRFPs = new OffChainRFP[](_rfpIds.length);\r\n        for (uint i; i < _rfpIds.length; ) {\r\n            offchainRFPs[i] = getRFP(_rfpIds[i]);\r\n\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n        return offchainRFPs;\r\n    }\r\n\r\n    /// @inheritdoc IRFPs\r\n    function createRFP(\r\n        string calldata _metadata,\r\n        uint64 _deadline,\r\n        ITasks.ERC20Transfer[] calldata _budget,\r\n        address _tasksManager,\r\n        address _manager\r\n    ) external payable returns (uint256 rfpId) {\r\n        rfpId = rfpCounter++;\r\n\r\n        RFP storage rfp = rfps[rfpId];\r\n        rfp.metadata = _metadata;\r\n        rfp.deadline = _deadline;\r\n        Escrow escrow = Escrow(payable(clone(escrowImplementation)));\r\n        escrow.__Escrow_init{value: msg.value}();\r\n        rfp.escrow = escrow;\r\n        // Gas optimization\r\n        if (msg.value != 0) {\r\n            rfp.nativeBudget = _toUint96(msg.value);\r\n        }\r\n        rfp.budgetCount = _toUint8(_budget.length);\r\n        for (uint8 i; i < uint8(_budget.length); ) {\r\n            _budget[i].tokenContract.transferFrom(\r\n                msg.sender,\r\n                address(escrow),\r\n                _budget[i].amount\r\n            );\r\n            // use balanceOf in case there is a fee asoosiated with the transfer\r\n            rfp.budget[i] = _budget[i].tokenContract;\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n\r\n        rfp.manager = _manager;\r\n        rfp.tasksManager = _tasksManager;\r\n        rfp.creator = msg.sender;\r\n\r\n        emit RFPCreated(\r\n            rfpId,\r\n            _metadata,\r\n            _deadline,\r\n            _budget,\r\n            _toUint96(msg.value),\r\n            msg.sender,\r\n            _tasksManager,\r\n            _manager\r\n        );\r\n    }\r\n\r\n    /// @inheritdoc IRFPs\r\n    function submitProject(\r\n        uint256 _rfpId,\r\n        string calldata _metadata,\r\n        uint64 _deadline,\r\n        ITasks.Reward[] calldata _reward,\r\n        ITasks.NativeReward[] calldata _nativeReward\r\n    ) external returns (uint16 projectId) {\r\n        RFP storage rfp = _getRFP(_rfpId);\r\n\r\n        // Ensure not past deadline\r\n        if (rfp.deadline <= uint64(block.timestamp)) {\r\n            revert RFPClosed();\r\n        }\r\n        // Ensure reward ends with next token\r\n        unchecked {\r\n            if (_reward.length != 0 && !_reward[_reward.length - 1].nextToken) {\r\n                revert RewardDoesntEndWithNextToken();\r\n            }\r\n        }\r\n\r\n        Project storage project = rfp.projects[rfp.projectCount];\r\n        project.metadata = _metadata;\r\n        project.deadline = _deadline;\r\n        project.representative = msg.sender;\r\n\r\n        // Gas optimization\r\n        if (_reward.length != 0) {\r\n            project.rewardCount = _toUint8(_reward.length);\r\n            for (uint8 i; i < uint8(_reward.length); ) {\r\n                project.reward[i] = _reward[i];\r\n                unchecked {\r\n                    ++i;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Gas optimization\r\n        if (_nativeReward.length != 0) {\r\n            project.nativeRewardCount = _toUint8(_nativeReward.length);\r\n            for (uint8 i; i < uint8(_nativeReward.length); ) {\r\n                project.nativeReward[i] = _nativeReward[i];\r\n                unchecked {\r\n                    ++i;\r\n                }\r\n            }\r\n        }\r\n\r\n        projectId = rfp.projectCount++;\r\n\r\n        emit ProjectSubmitted(\r\n            _rfpId,\r\n            projectId,\r\n            _metadata,\r\n            msg.sender,\r\n            _deadline,\r\n            _reward,\r\n            _nativeReward\r\n        );\r\n    }\r\n\r\n    /// @inheritdoc IRFPs\r\n    function acceptProject(uint256 _rfpId, uint16 _projectId) external {\r\n        RFP storage rfp = _getRFP(_rfpId);\r\n\r\n        // Ensure sender is manager\r\n        if (rfp.manager != msg.sender) {\r\n            revert NotManager();\r\n        }\r\n        // Ensure project exists\r\n        if (_projectId >= rfp.projectCount) {\r\n            revert ProjectDoesNotExist();\r\n        }\r\n\r\n        Project storage project = rfp.projects[_projectId];\r\n\r\n        // Ensure project not accepted\r\n        if (project.accepted) {\r\n            revert ProjectAlreadyAccepted();\r\n        }\r\n\r\n        ITasks.ERC20Transfer[] memory taskBudget = new ITasks.ERC20Transfer[](\r\n            rfp.budgetCount\r\n        );\r\n        ITasks.Reward[] memory taskReward = new ITasks.Reward[](\r\n            project.rewardCount\r\n        );\r\n        uint8 j;\r\n        for (uint8 i; i < taskBudget.length; ) {\r\n            IERC20 erc20 = rfp.budget[i];\r\n            uint96 projectBudget;\r\n            while (j < taskReward.length) {\r\n                taskReward[j] = project.reward[j];\r\n                projectBudget += taskReward[j].amount;\r\n\r\n                unchecked {\r\n                    ++j;\r\n                }\r\n\r\n                if (taskReward[j - 1].nextToken) {\r\n                    break;\r\n                }\r\n            }\r\n\r\n            taskBudget[i] = ITasks.ERC20Transfer(erc20, projectBudget);\r\n            rfp.escrow.transfer(erc20, address(this), projectBudget);\r\n            erc20.approve(address(tasks), projectBudget);\r\n\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n\r\n        uint96 taskNativeBudget;\r\n        ITasks.NativeReward[]\r\n            memory taskNativeReward = new ITasks.NativeReward[](\r\n                project.nativeRewardCount\r\n            );\r\n        for (uint8 i; i < taskNativeReward.length; ) {\r\n            taskNativeReward[i] = project.nativeReward[i];\r\n            taskNativeBudget += taskNativeReward[i].amount;\r\n\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n        rfp.escrow.transferNative(payable(address(this)), taskNativeBudget);\r\n\r\n        ITasks.PreapprovedApplication[]\r\n            memory preapproved = new ITasks.PreapprovedApplication[](1);\r\n        preapproved[0] = ITasks.PreapprovedApplication(\r\n            project.representative,\r\n            taskReward,\r\n            taskNativeReward\r\n        );\r\n\r\n        uint256 taskId = tasks.createTask{value: taskNativeBudget}(\r\n            project.metadata,\r\n            project.deadline,\r\n            taskBudget,\r\n            rfp.tasksManager,\r\n            preapproved\r\n        );\r\n        project.accepted = true;\r\n        emit ProjectAccepted(_rfpId, _projectId, taskId);\r\n    }\r\n\r\n    /// @inheritdoc IRFPs\r\n    function emptyRFP(uint256 _rfpId) external {\r\n        RFP storage rfp = _getRFP(_rfpId);\r\n\r\n        // Ensure sender is manager\r\n        if (rfp.manager != msg.sender) {\r\n            revert NotManager();\r\n        }\r\n\r\n        uint8 budgetCount = rfp.budgetCount;\r\n        for (uint8 i; i < budgetCount; ) {\r\n            IERC20 erc20 = rfp.budget[i];\r\n\r\n            rfp.escrow.transfer(\r\n                erc20,\r\n                rfp.creator,\r\n                erc20.balanceOf(address(rfp.escrow))\r\n            );\r\n\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n\r\n        rfp.escrow.transferNative(\r\n            payable(rfp.creator),\r\n            address(rfp.escrow).balance\r\n        );\r\n\r\n        emit RFPEmptied(_rfpId);\r\n    }\r\n\r\n    function _getRFP(uint256 _rfpId) internal view returns (RFP storage rfp) {\r\n        if (_rfpId >= rfpCounter) {\r\n            revert RFPDoesNotExist();\r\n        }\r\n\r\n        rfp = rfps[_rfpId];\r\n    }\r\n\r\n    function _toOffchainRFP(\r\n        RFP storage rfp\r\n    ) internal view returns (OffChainRFP memory offchainRFP) {\r\n        offchainRFP.metadata = rfp.metadata;\r\n        offchainRFP.deadline = rfp.deadline;\r\n        offchainRFP.creator = rfp.creator;\r\n        offchainRFP.tasksManager = rfp.tasksManager;\r\n        offchainRFP.manager = rfp.manager;\r\n        offchainRFP.escrow = rfp.escrow;\r\n        offchainRFP.nativeBudget = rfp.nativeBudget;\r\n\r\n        offchainRFP.budget = new IERC20[](rfp.budgetCount);\r\n        for (uint8 i; i < offchainRFP.budget.length; ) {\r\n            offchainRFP.budget[i] = rfp.budget[i];\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n\r\n        offchainRFP.projects = new OffchainProject[](rfp.projectCount);\r\n        for (uint8 i; i < offchainRFP.projects.length; ) {\r\n            Project storage project = rfp.projects[i];\r\n            offchainRFP.projects[i].metadata = project.metadata;\r\n            offchainRFP.projects[i].deadline = project.deadline;\r\n            offchainRFP.projects[i].representative = project.representative;\r\n            offchainRFP.projects[i].accepted = project.accepted;\r\n\r\n            offchainRFP.projects[i].reward = new ITasks.Reward[](\r\n                project.rewardCount\r\n            );\r\n            for (uint8 j; j < offchainRFP.projects[i].reward.length; ) {\r\n                offchainRFP.projects[i].reward[j] = project.reward[j];\r\n                unchecked {\r\n                    ++j;\r\n                }\r\n            }\r\n            offchainRFP.projects[i].nativeReward = new ITasks.NativeReward[](\r\n                project.nativeRewardCount\r\n            );\r\n\r\n            for (uint8 j; j < offchainRFP.projects[i].nativeReward.length; ) {\r\n                offchainRFP.projects[i].nativeReward[j] = project.nativeReward[\r\n                    j\r\n                ];\r\n                unchecked {\r\n                    ++j;\r\n                }\r\n            }\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n    }\r\n\r\n    // From: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/proxy/Clones.sol\r\n    function clone(address implementation) internal returns (address instance) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\r\n            // of the `implementation` address with the bytecode before the address.\r\n            mstore(\r\n                0x00,\r\n                or(\r\n                    shr(0xe8, shl(0x60, implementation)),\r\n                    0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000\r\n                )\r\n            )\r\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\r\n            mstore(\r\n                0x20,\r\n                or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3)\r\n            )\r\n            instance := create(0, 0x09, 0x37)\r\n        }\r\n        if (instance == address(0)) {\r\n            revert ERC1167FailedCreateClone();\r\n        }\r\n    }\r\n\r\n    function _toUint8(uint256 value) internal pure returns (uint8) {\r\n        if (value > type(uint8).max) {\r\n            revert Overflow();\r\n        }\r\n        return uint8(value);\r\n    }\r\n\r\n    function _toUint96(uint256 value) internal pure returns (uint96) {\r\n        if (value > type(uint96).max) {\r\n            revert Overflow();\r\n        }\r\n        return uint96(value);\r\n    }\r\n}\r\n"
    },
    "contracts/Tasks/ITasks.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport {Escrow} from \"../Escrow.sol\";\r\n\r\ninterface ITasks {\r\n    error InvalidTimestamp();\r\n    error InvalidAddress();\r\n    error PointlessOperation();\r\n\r\n    error TaskDoesNotExist();\r\n    error TaskNotOpen();\r\n    error TaskNotTaken();\r\n    error TaskNotClosed();\r\n    error TaskClosed();\r\n\r\n    error NotManager();\r\n    error NotExecutor();\r\n\r\n    error RewardAboveBudget();\r\n    error RewardDoesntEndWithNextToken();\r\n    error IncorrectAmountOfNativeCurrencyAttached();\r\n    error ApplicationDoesNotExist();\r\n    error NotYourApplication();\r\n    error ApplicationNotAccepted();\r\n    error SubmissionDoesNotExist();\r\n    error SubmissionAlreadyJudged();\r\n    error JudgementNone();\r\n\r\n    error RequestDoesNotExist();\r\n    error RequestAlreadyAccepted();\r\n    error RequestNotAccepted();\r\n    error RequestAlreadyExecuted();\r\n\r\n    error Overflow();\r\n    error ManualBudgetIncreaseNeeded();\r\n    error PartialRewardAboveFullReward();\r\n    error NativeTransferFailed();\r\n    error ERC1167FailedCreateClone();\r\n\r\n    event TaskCreated(\r\n        uint256 indexed taskId,\r\n        string metadata,\r\n        uint64 deadline,\r\n        ERC20Transfer[] budget,\r\n        uint96 nativeBudget,\r\n        address creator,\r\n        address manager\r\n    );\r\n    event ApplicationCreated(\r\n        uint256 indexed taskId,\r\n        uint16 applicationId,\r\n        string metadata,\r\n        Reward[] reward,\r\n        NativeReward[] nativeReward\r\n    );\r\n    event ApplicationAccepted(uint256 indexed taskId, uint16 applicationId);\r\n    event TaskTaken(uint256 indexed taskId, uint16 applicationId);\r\n    event SubmissionCreated(\r\n        uint256 indexed taskId,\r\n        uint8 submissionId,\r\n        string metadata\r\n    );\r\n    event SubmissionReviewed(\r\n        uint256 indexed taskId,\r\n        uint8 submissionId,\r\n        SubmissionJudgement judgement,\r\n        string feedback\r\n    );\r\n    event TaskCompleted(uint256 indexed taskId, TaskCompletion source);\r\n\r\n    event CancelTaskRequested(\r\n        uint256 indexed taskId,\r\n        uint8 requestId,\r\n        string explanation\r\n    );\r\n    event TaskCancelled(uint256 indexed taskId);\r\n    event RequestAccepted(\r\n        uint256 indexed taskId,\r\n        RequestType requestType,\r\n        uint8 requestId\r\n    );\r\n    event RequestExecuted(\r\n        uint256 indexed taskId,\r\n        RequestType requestType,\r\n        uint8 requestId,\r\n        address by\r\n    );\r\n\r\n    event DeadlineChanged(uint256 indexed taskId, uint64 newDeadline);\r\n    event BudgetChanged(uint256 indexed taskId); // Quite expensive to transfer budget into a datastructure to emit\r\n    event MetadataChanged(uint256 indexed taskId, string newMetadata);\r\n    event PartialPayment(\r\n        uint256 indexed taskId,\r\n        uint88[] partialReward,\r\n        uint96[] partialNativeReward\r\n    );\r\n    event NewManager(uint256 indexed taskId, address manager);\r\n\r\n    /// @notice A container for ERC20 transfer information.\r\n    /// @param tokenContract ERC20 token to transfer.\r\n    /// @param amount How much of this token should be transfered.\r\n    struct ERC20Transfer {\r\n        IERC20 tokenContract;\r\n        uint96 amount;\r\n    }\r\n\r\n    /// @notice A container for a reward payout.\r\n    /// @param nextToken If this reward is payed out in the next ERC20 token.\r\n    /// @dev IERC20 (address) is a lot of storage, rather just keep those only in budget.\r\n    /// @notice nextToken should always be true for the last entry\r\n    /// @param to Whom this token should be transfered to.\r\n    /// @param amount How much of this token should be transfered.\r\n    struct Reward {\r\n        bool nextToken;\r\n        address to;\r\n        uint88 amount;\r\n    }\r\n\r\n    /// @notice A container for a native reward payout.\r\n    /// @param to Whom the native reward should be transfered to.\r\n    /// @param amount How much native reward should be transfered.\r\n    struct NativeReward {\r\n        address to;\r\n        uint96 amount;\r\n    }\r\n\r\n    /// @notice A container for a task application.\r\n    /// @param metadata Metadata of the application. (IPFS hash)\r\n    /// @param applicant Who has submitted this application.\r\n    /// @param accepted If the application has been accepted by the manager.\r\n    /// @param reward How much rewards the applicant wants for completion.\r\n    /// @param nativeReward How much native currency the applicant wants for completion.\r\n    struct Application {\r\n        string metadata;\r\n        address applicant;\r\n        bool accepted;\r\n        uint8 rewardCount;\r\n        uint8 nativeRewardCount;\r\n        mapping(uint8 => Reward) reward;\r\n        mapping(uint8 => NativeReward) nativeReward;\r\n    }\r\n\r\n    struct OffChainApplication {\r\n        string metadata;\r\n        address applicant;\r\n        bool accepted;\r\n        Reward[] reward;\r\n        NativeReward[] nativeReward;\r\n    }\r\n\r\n    /// @notice For approving people on task creation (they are not required to make an application)\r\n    struct PreapprovedApplication {\r\n        address applicant;\r\n        Reward[] reward;\r\n        NativeReward[] nativeReward;\r\n    }\r\n\r\n    enum SubmissionJudgement {\r\n        None,\r\n        Accepted,\r\n        Rejected\r\n    }\r\n    /// @notice A container for a task submission.\r\n    /// @param metadata Metadata of the submission. (IPFS hash)\r\n    /// @param judgement Judgement cast on the submission.\r\n    /// @param feedback A response from the manager. (IPFS hash)\r\n    struct Submission {\r\n        string metadata;\r\n        string feedback;\r\n        SubmissionJudgement judgement;\r\n    }\r\n\r\n    enum RequestType {\r\n        CancelTask\r\n    }\r\n\r\n    /// @notice A container for shared request information.\r\n    /// @param accepted If the request was accepted.\r\n    /// @param executed If the request was executed.\r\n    struct Request {\r\n        bool accepted;\r\n        bool executed;\r\n    }\r\n\r\n    /// @notice A container for a request to cancel the task.\r\n    /// @param request Request information.\r\n    /// @param explanation Why the task should be cancelled.\r\n    struct CancelTaskRequest {\r\n        Request request;\r\n        string explanation;\r\n    }\r\n\r\n    enum TaskState {\r\n        Open,\r\n        Taken,\r\n        Closed\r\n    }\r\n    /// @notice A container for task-related information.\r\n    /// @param metadata Metadata of the task. (IPFS hash)\r\n    /// @param deadline Block timestamp at which the task expires if not completed.\r\n    /// @param budget Maximum ERC20 rewards that can be earned by completing the task.\r\n    /// @param nativeBudget Maximum native currency reward that can be earned by completing the task.\r\n    /// @param creator Who has created the task.\r\n    /// @param manager Who has the permission to manage the task.\r\n    /// @param state Current state the task is in.\r\n    /// @param applications Applications to take the job.\r\n    /// @param executorApplication Index of the application that will execture the task.\r\n    /// @param submissions Submission made to finish the task.\r\n    struct Task {\r\n        string metadata;\r\n        // Storage block seperator\r\n        uint64 deadline;\r\n        Escrow escrow;\r\n        // Storage block seperator\r\n        uint96 nativeBudget;\r\n        address creator;\r\n        // Storage block seperator\r\n        address manager;\r\n        TaskState state;\r\n        uint16 executorApplication;\r\n        uint8 budgetCount;\r\n        uint16 applicationCount;\r\n        uint8 submissionCount;\r\n        uint8 cancelTaskRequestCount;\r\n        // Storage block seperator\r\n        mapping(uint8 => ERC20Transfer) budget;\r\n        mapping(uint16 => Application) applications;\r\n        mapping(uint8 => Submission) submissions;\r\n        mapping(uint8 => CancelTaskRequest) cancelTaskRequests;\r\n    }\r\n\r\n    struct OffChainTask {\r\n        string metadata;\r\n        uint64 deadline;\r\n        uint16 executorApplication;\r\n        address creator;\r\n        address manager;\r\n        TaskState state;\r\n        Escrow escrow;\r\n        uint96 nativeBudget;\r\n        ERC20Transfer[] budget;\r\n        OffChainApplication[] applications;\r\n        Submission[] submissions;\r\n        CancelTaskRequest[] cancelTaskRequests;\r\n    }\r\n\r\n    enum TaskCompletion {\r\n        SubmissionAccepted,\r\n        Dispute\r\n    }\r\n\r\n    /// @notice Retrieves the current amount of created tasks.\r\n    function taskCount() external view returns (uint256);\r\n\r\n    /// @notice Retrieves all task information by id.\r\n    /// @param _taskId Id of the task.\r\n    function getTask(\r\n        uint256 _taskId\r\n    ) external view returns (OffChainTask memory);\r\n\r\n    /// @notice Retrieves multiple tasks.\r\n    /// @param _taskIds Ids of the tasks.\r\n    function getTasks(\r\n        uint256[] calldata _taskIds\r\n    ) external view returns (OffChainTask[] memory);\r\n\r\n    /// @notice Create a new task.\r\n    /// @param _metadata Metadata of the task. (IPFS hash)\r\n    /// @param _deadline Block timestamp at which the task expires if not completed.\r\n    /// @param _budget Maximum ERC20 rewards that can be earned by completing the task.\r\n    /// @param _manager Who will manage the task (become the manager).\r\n    /// @return taskId Id of the newly created task.\r\n    function createTask(\r\n        string calldata _metadata,\r\n        uint64 _deadline,\r\n        ERC20Transfer[] calldata _budget,\r\n        address _manager,\r\n        PreapprovedApplication[] calldata _preapprove\r\n    ) external payable returns (uint256 taskId);\r\n\r\n    /// @notice Apply to take the task.\r\n    /// @param _taskId Id of the task.\r\n    /// @param _metadata Metadata of your application.\r\n    /// @param _reward Wanted rewards for completing the task.\r\n    /// @param _nativeReward Wanted native currency for completing the task.\r\n    /// @return applicationId Id of the newly created application.\r\n    function applyForTask(\r\n        uint256 _taskId,\r\n        string calldata _metadata,\r\n        Reward[] calldata _reward,\r\n        NativeReward[] calldata _nativeReward\r\n    ) external returns (uint16 applicationId);\r\n\r\n    /// @notice Accept application to allow them to take the task.\r\n    /// @param _taskId Id of the task.\r\n    /// @param _applicationIds Indexes of the applications to accept.\r\n    function acceptApplications(\r\n        uint256 _taskId,\r\n        uint16[] calldata _applicationIds\r\n    ) external payable;\r\n\r\n    /// @notice Take the task after your application has been accepted.\r\n    /// @param _taskId Id of the task.\r\n    /// @param _applicationId Index of application you made that has been accepted.\r\n    function takeTask(uint256 _taskId, uint16 _applicationId) external;\r\n\r\n    /// @notice Create a submission.\r\n    /// @param _taskId Id of the task.\r\n    /// @param _metadata Metadata of the submission. (IPFS hash)\r\n    /// @return submissionId Id of the newly created submission.\r\n    function createSubmission(\r\n        uint256 _taskId,\r\n        string calldata _metadata\r\n    ) external returns (uint8 submissionId);\r\n\r\n    /// @notice Review a submission.\r\n    /// @param _taskId Id of the task.\r\n    /// @param _submissionId Index of the submission that is reviewed.\r\n    /// @param _judgement Outcome of the review.\r\n    /// @param _feedback Reasoning of the reviewer. (IPFS hash)\r\n    function reviewSubmission(\r\n        uint256 _taskId,\r\n        uint8 _submissionId,\r\n        SubmissionJudgement _judgement,\r\n        string calldata _feedback\r\n    ) external;\r\n\r\n    /// @notice Cancels a task. This can be used to close a task and receive back the budget.\r\n    /// @param _taskId Id of the task.\r\n    /// @param _explanation Why the task was cancelled. (IPFS hash)\r\n    /// @return cancelTaskRequestId Id of the newly created request for task cancellation.\r\n    function cancelTask(\r\n        uint256 _taskId,\r\n        string calldata _explanation\r\n    ) external returns (uint8 cancelTaskRequestId);\r\n\r\n    /// @notice Accepts a request, executing the proposed action.\r\n    /// @param _taskId Id of the task.\r\n    /// @param _requestType What kind of request it is.\r\n    /// @param _requestId Id of the request.\r\n    /// @param _execute If the request should also be executed in this transaction.\r\n    function acceptRequest(\r\n        uint256 _taskId,\r\n        RequestType _requestType,\r\n        uint8 _requestId,\r\n        bool _execute\r\n    ) external;\r\n\r\n    /// @notice Exectued an accepted request, allows anyone to pay for the gas costs of the execution.\r\n    /// @param _taskId Id of the task.\r\n    /// @param _requestType What kind of request it is.\r\n    /// @param _requestId Id of the request.\r\n    function executeRequest(\r\n        uint256 _taskId,\r\n        RequestType _requestType,\r\n        uint8 _requestId\r\n    ) external;\r\n\r\n    /// @notice Extend the deadline of a task.\r\n    /// @param _taskId Id of the task.\r\n    /// @param _extension How much to extend the deadline by.\r\n    function extendDeadline(uint256 _taskId, uint64 _extension) external;\r\n\r\n    /// @notice Increase the budget of the task.\r\n    /// @param _taskId Id of the task.\r\n    /// @param _increase How much to increase each tokens amount by.\r\n    /// @dev Any attached native reward will also be used to increase the budget.\r\n    function increaseBudget(\r\n        uint256 _taskId,\r\n        uint96[] calldata _increase\r\n    ) external payable;\r\n\r\n    /// @notice Edit the metadata of a task.\r\n    /// @param _taskId Id of the task.\r\n    /// @param _newMetadata New metadata of the task.\r\n    /// @dev This metadata update might change the task completely. Show a warning to people who applied before the change.\r\n    function editMetadata(\r\n        uint256 _taskId,\r\n        string calldata _newMetadata\r\n    ) external;\r\n\r\n    /// @notice Completes the task through dispute resolution.\r\n    /// @param _taskId Id of the task.\r\n    /// @param _partialReward How much of each ERC20 reward should be paid out.\r\n    /// @param _partialNativeReward How much of each native reward should be paid out.\r\n    function completeByDispute(\r\n        uint256 _taskId,\r\n        uint88[] calldata _partialReward,\r\n        uint96[] calldata _partialNativeReward\r\n    ) external;\r\n\r\n    /// @notice Allows the dispute manager to appoint a new dispute manager.\r\n    /// @param _newManager The new dispute manager.\r\n    function transferDisputeManagement(address _newManager) external;\r\n\r\n    /// @notice Releases a part of the reward to the executor without marking the task as complete.\r\n    /// @param _taskId Id of the task.\r\n    /// @param _partialReward How much of each ERC20 reward should be paid out.\r\n    /// @param _partialNativeReward How much of each native reward should be paid out.\r\n    /// @dev Will fetch balanceOf to set the budget afterwards, can be used in case funds where sent manually to increase the budget.\r\n    function partialPayment(\r\n        uint256 _taskId,\r\n        uint88[] calldata _partialReward,\r\n        uint96[] calldata _partialNativeReward\r\n    ) external;\r\n\r\n    /// @notice Transfers the manager role to a different address.\r\n    /// @param _taskId Id of the task.\r\n    /// @param _newManager What address should become the manager.\r\n    function transferManagement(uint256 _taskId, address _newManager) external;\r\n}\r\n"
    },
    "contracts/Tasks/Tasks.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport {ITasks, IERC20, Escrow} from \"./ITasks.sol\";\r\nimport {TasksUtils} from \"./TasksUtils.sol\";\r\n\r\ncontract Tasks is TasksUtils {\r\n    /// @notice The incremental ID for tasks.\r\n    uint256 private taskCounter;\r\n\r\n    /// @notice A mapping between task IDs and task information.\r\n    mapping(uint256 => Task) internal tasks;\r\n\r\n    /// @notice The base escrow contract that will be cloned for every task.\r\n    address public immutable escrowImplementation;\r\n\r\n    /// @notice This address has the power to disable the contract, in case an exploit is discovered.\r\n    address private disabler;\r\n    error Disabled();\r\n    error NotDisabled();\r\n    error NotDisabler();\r\n\r\n    /// @notice This address has the power to handle disputes. It can complete any taken task without permission of the manager.\r\n    /// @dev This should be a smart contract obviously.\r\n    address public disputeManager;\r\n    error NotDisputeManager();\r\n    event NewDisputeManager(address disputeManager);\r\n\r\n    constructor(address _disabler, address _disputeManager) {\r\n        escrowImplementation = address(new Escrow());\r\n        disabler = _disabler;\r\n        disputeManager = _disputeManager;\r\n        emit NewDisputeManager(_disputeManager);\r\n    }\r\n\r\n    /// @inheritdoc ITasks\r\n    function taskCount() external view returns (uint256) {\r\n        return taskCounter;\r\n    }\r\n\r\n    /// @inheritdoc ITasks\r\n    function getTask(\r\n        uint256 _taskId\r\n    ) public view returns (OffChainTask memory offchainTask) {\r\n        Task storage task = _getTask(_taskId);\r\n        offchainTask = _toOffchainTask(task);\r\n    }\r\n\r\n    /// @inheritdoc ITasks\r\n    function getTasks(\r\n        uint256[] memory _taskIds\r\n    ) public view returns (OffChainTask[] memory) {\r\n        OffChainTask[] memory offchainTasks = new OffChainTask[](\r\n            _taskIds.length\r\n        );\r\n        for (uint i; i < _taskIds.length; ) {\r\n            offchainTasks[i] = getTask(_taskIds[i]);\r\n\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n        return offchainTasks;\r\n    }\r\n\r\n    /// @inheritdoc ITasks\r\n    function createTask(\r\n        string calldata _metadata,\r\n        uint64 _deadline,\r\n        ERC20Transfer[] calldata _budget,\r\n        address _manager,\r\n        PreapprovedApplication[] calldata _preapprove\r\n    ) external payable returns (uint256 taskId) {\r\n        _ensureValidTimestamp(_deadline);\r\n        _ensureValidAddress(_manager);\r\n\r\n        _ensureNotDisabled();\r\n        taskId = taskCounter++;\r\n\r\n        Task storage task = tasks[taskId];\r\n        task.metadata = _metadata;\r\n        task.deadline = _deadline;\r\n        Escrow escrow = Escrow(payable(clone(escrowImplementation)));\r\n        escrow.__Escrow_init{value: msg.value}();\r\n        task.escrow = escrow;\r\n        // Gas optimization\r\n        if (msg.value != 0) {\r\n            task.nativeBudget = _toUint96(msg.value);\r\n        }\r\n        task.budgetCount = _toUint8(_budget.length);\r\n        for (uint8 i; i < uint8(_budget.length); ) {\r\n            _budget[i].tokenContract.transferFrom(\r\n                msg.sender,\r\n                address(escrow),\r\n                _budget[i].amount\r\n            );\r\n            // use balanceOf in case there is a fee asoosiated with the transfer\r\n            task.budget[i] = ERC20Transfer(\r\n                _budget[i].tokenContract,\r\n                _toUint96(_budget[i].tokenContract.balanceOf(address(escrow)))\r\n            );\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n\r\n        task.manager = _manager;\r\n        task.creator = msg.sender;\r\n\r\n        // Default values are already correct (save gas)\r\n        // task.state = TaskState.Open;\r\n\r\n        emit TaskCreated(\r\n            taskId,\r\n            _metadata,\r\n            _deadline,\r\n            _budget,\r\n            _toUint96(msg.value),\r\n            msg.sender,\r\n            _manager\r\n        );\r\n\r\n        // Gas optimization\r\n        if (_preapprove.length > 0) {\r\n            task.applicationCount = _toUint16(_preapprove.length);\r\n            for (uint16 i; i < uint16(_preapprove.length); ) {\r\n                Application storage application = task.applications[i];\r\n                application.applicant = _preapprove[i].applicant;\r\n                application.accepted = true;\r\n                _ensureRewardEndsWithNextToken(_preapprove[i].reward);\r\n                _setRewardBellowBudget(\r\n                    task,\r\n                    application,\r\n                    _preapprove[i].reward,\r\n                    _preapprove[i].nativeReward\r\n                );\r\n\r\n                emit ApplicationCreated(\r\n                    taskId,\r\n                    i,\r\n                    \"\",\r\n                    _preapprove[i].reward,\r\n                    _preapprove[i].nativeReward\r\n                );\r\n\r\n                emit ApplicationAccepted(taskId, i);\r\n\r\n                unchecked {\r\n                    ++i;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc ITasks\r\n    function applyForTask(\r\n        uint256 _taskId,\r\n        string calldata _metadata,\r\n        Reward[] calldata _reward,\r\n        NativeReward[] calldata _nativeReward\r\n    ) external returns (uint16 applicationId) {\r\n        _ensureNotDisabled();\r\n        Task storage task = _getTask(_taskId);\r\n        _ensureTaskIsOpen(task);\r\n        _ensureRewardEndsWithNextToken(_reward);\r\n\r\n        Application storage application = task.applications[\r\n            task.applicationCount\r\n        ];\r\n        application.metadata = _metadata;\r\n        application.applicant = msg.sender;\r\n\r\n        // Gas optimization\r\n        if (_reward.length != 0) {\r\n            application.rewardCount = _toUint8(_reward.length);\r\n            for (uint8 i; i < uint8(_reward.length); ) {\r\n                application.reward[i] = _reward[i];\r\n                unchecked {\r\n                    ++i;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Gas optimization\r\n        if (_nativeReward.length != 0) {\r\n            application.nativeRewardCount = _toUint8(_nativeReward.length);\r\n            for (uint8 i; i < uint8(_nativeReward.length); ) {\r\n                application.nativeReward[i] = _nativeReward[i];\r\n                unchecked {\r\n                    ++i;\r\n                }\r\n            }\r\n        }\r\n\r\n        applicationId = task.applicationCount++;\r\n\r\n        emit ApplicationCreated(\r\n            _taskId,\r\n            applicationId,\r\n            _metadata,\r\n            _reward,\r\n            _nativeReward\r\n        );\r\n    }\r\n\r\n    /// @inheritdoc ITasks\r\n    function acceptApplications(\r\n        uint256 _taskId,\r\n        uint16[] calldata _applicationIds\r\n    ) external payable {\r\n        _ensureNotDisabled();\r\n        Task storage task = _getTask(_taskId);\r\n        _ensureTaskIsOpen(task);\r\n        _ensureSenderIsManager(task);\r\n\r\n        for (uint i; i < _applicationIds.length; ) {\r\n            _ensureApplicationExists(task, _applicationIds[i]);\r\n\r\n            Application storage application = task.applications[\r\n                _applicationIds[i]\r\n            ];\r\n            application.accepted = true;\r\n            bool budgetIncreased = _increaseBudgetToReward(\r\n                task,\r\n                application.rewardCount,\r\n                application.reward,\r\n                application.nativeRewardCount,\r\n                application.nativeReward\r\n            );\r\n            if (budgetIncreased) {\r\n                emit BudgetChanged(_taskId);\r\n            }\r\n            emit ApplicationAccepted(_taskId, _applicationIds[i]);\r\n\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc ITasks\r\n    function takeTask(uint256 _taskId, uint16 _applicationId) external {\r\n        _ensureNotDisabled();\r\n        Task storage task = _getTask(_taskId);\r\n        _ensureTaskIsOpen(task);\r\n        _ensureApplicationExists(task, _applicationId);\r\n\r\n        Application storage application = task.applications[_applicationId];\r\n        _ensureSenderIsApplicant(application);\r\n        _ensureApplicationIsAccepted(application);\r\n\r\n        task.executorApplication = _applicationId;\r\n        task.state = TaskState.Taken;\r\n\r\n        emit TaskTaken(_taskId, _applicationId);\r\n    }\r\n\r\n    /// @inheritdoc ITasks\r\n    function createSubmission(\r\n        uint256 _taskId,\r\n        string calldata _metadata\r\n    ) external returns (uint8 submissionId) {\r\n        _ensureNotDisabled();\r\n        Task storage task = _getTask(_taskId);\r\n        _ensureTaskIsTaken(task);\r\n        _ensureSenderIsExecutor(task);\r\n\r\n        Submission storage submission = task.submissions[task.submissionCount];\r\n        submission.metadata = _metadata;\r\n        submissionId = task.submissionCount++;\r\n\r\n        emit SubmissionCreated(_taskId, submissionId, _metadata);\r\n    }\r\n\r\n    /// @inheritdoc ITasks\r\n    function reviewSubmission(\r\n        uint256 _taskId,\r\n        uint8 _submissionId,\r\n        SubmissionJudgement _judgement,\r\n        string calldata _feedback\r\n    ) external {\r\n        _ensureNotDisabled();\r\n        Task storage task = _getTask(_taskId);\r\n        _ensureTaskIsTaken(task);\r\n        _ensureSenderIsManager(task);\r\n        _ensureSubmissionExists(task, _submissionId);\r\n\r\n        Submission storage submission = task.submissions[_submissionId];\r\n        _ensureSubmissionNotJudged(submission);\r\n        _ensureJudgementNotNone(_judgement);\r\n        submission.judgement = _judgement;\r\n        submission.feedback = _feedback;\r\n\r\n        if (_judgement == SubmissionJudgement.Accepted) {\r\n            _payoutTask(task);\r\n            emit TaskCompleted(_taskId, TaskCompletion.SubmissionAccepted);\r\n        }\r\n\r\n        emit SubmissionReviewed(_taskId, _submissionId, _judgement, _feedback);\r\n    }\r\n\r\n    /// @inheritdoc ITasks\r\n    function cancelTask(\r\n        uint256 _taskId,\r\n        string calldata _explanation\r\n    ) external returns (uint8 cancelTaskRequestId) {\r\n        _ensureNotDisabled();\r\n        Task storage task = _getTask(_taskId);\r\n        _ensureSenderIsManager(task);\r\n\r\n        _ensureTaskNotClosed(task);\r\n\r\n        if (\r\n            task.state == TaskState.Open ||\r\n            task.deadline <= uint64(block.timestamp)\r\n        ) {\r\n            // Task is open or deadline past\r\n            _refundCreator(task);\r\n\r\n            emit TaskCancelled(_taskId);\r\n\r\n            // Max means no request\r\n            cancelTaskRequestId = type(uint8).max;\r\n        } else {\r\n            // Task is taken and deadline has not past\r\n            CancelTaskRequest storage request = task.cancelTaskRequests[\r\n                task.cancelTaskRequestCount\r\n            ];\r\n            request.explanation = _explanation;\r\n            cancelTaskRequestId = task.cancelTaskRequestCount++;\r\n\r\n            emit CancelTaskRequested(\r\n                _taskId,\r\n                cancelTaskRequestId,\r\n                _explanation\r\n            );\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc ITasks\r\n    function acceptRequest(\r\n        uint256 _taskId,\r\n        RequestType _requestType,\r\n        uint8 _requestId,\r\n        bool _execute\r\n    ) external {\r\n        _ensureNotDisabled();\r\n        Task storage task = _getTask(_taskId);\r\n        _ensureTaskIsTaken(task);\r\n        _ensureSenderIsExecutor(task);\r\n\r\n        //if (_requestType == RequestType.CancelTask) {\r\n        {\r\n            _ensureCancelTaskRequestExists(task, _requestId);\r\n\r\n            CancelTaskRequest storage cancelTaskRequest = task\r\n                .cancelTaskRequests[_requestId];\r\n            _ensureRequestNotAccepted(cancelTaskRequest.request);\r\n\r\n            if (_execute) {\r\n                // use executeRequest in the body instead? (more gas due to all the checks, but less code duplication)\r\n                _refundCreator(task);\r\n                emit TaskCancelled(_taskId);\r\n\r\n                cancelTaskRequest.request.executed = true;\r\n            }\r\n\r\n            cancelTaskRequest.request.accepted = true;\r\n        }\r\n\r\n        emit RequestAccepted(_taskId, _requestType, _requestId);\r\n    }\r\n\r\n    /// @inheritdoc ITasks\r\n    function executeRequest(\r\n        uint256 _taskId,\r\n        RequestType _requestType,\r\n        uint8 _requestId\r\n    ) external {\r\n        _ensureNotDisabled();\r\n        Task storage task = _getTask(_taskId);\r\n        _ensureTaskIsTaken(task);\r\n\r\n        //if (_requestType == RequestType.CancelTask) {\r\n        {\r\n            _ensureCancelTaskRequestExists(task, _requestId);\r\n\r\n            CancelTaskRequest storage cancelTaskRequest = task\r\n                .cancelTaskRequests[_requestId];\r\n            _ensureRequestAccepted(cancelTaskRequest.request);\r\n            _ensureRequestNotExecuted(cancelTaskRequest.request);\r\n\r\n            _refundCreator(task);\r\n\r\n            emit TaskCancelled(_taskId);\r\n            cancelTaskRequest.request.executed = true;\r\n        }\r\n\r\n        emit RequestExecuted(_taskId, _requestType, _requestId, msg.sender);\r\n    }\r\n\r\n    /// @inheritdoc ITasks\r\n    function extendDeadline(uint256 _taskId, uint64 _extension) external {\r\n        _ensureNotDisabled();\r\n        Task storage task = _getTask(_taskId);\r\n        _ensureSenderIsManager(task);\r\n\r\n        _ensureTaskNotClosed(task);\r\n\r\n        if (_extension == 0) {\r\n            revert PointlessOperation();\r\n        }\r\n        task.deadline += _extension;\r\n\r\n        emit DeadlineChanged(_taskId, task.deadline);\r\n    }\r\n\r\n    /// @inheritdoc ITasks\r\n    function increaseBudget(\r\n        uint256 _taskId,\r\n        uint96[] calldata _increase\r\n    ) external payable {\r\n        _ensureNotDisabled();\r\n        Task storage task = _getTask(_taskId);\r\n        _ensureSenderIsManager(task);\r\n\r\n        _ensureTaskIsOpen(task);\r\n\r\n        for (uint8 i; i < uint8(_increase.length); ) {\r\n            ERC20Transfer storage transfer = task.budget[i];\r\n            transfer.tokenContract.transferFrom(\r\n                msg.sender,\r\n                address(task.escrow),\r\n                _increase[i]\r\n            );\r\n            // Use balanceOf as there could be a fee in transferFrom\r\n\r\n            transfer.amount = _toUint96(\r\n                transfer.tokenContract.balanceOf(address(task.escrow))\r\n            );\r\n\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n\r\n        // Gas optimization\r\n        if (msg.value != 0) {\r\n            task.nativeBudget = _toUint96(task.nativeBudget + msg.value);\r\n        }\r\n\r\n        emit BudgetChanged(_taskId);\r\n    }\r\n\r\n    /// @inheritdoc ITasks\r\n    function editMetadata(\r\n        uint256 _taskId,\r\n        string calldata _newMetadata\r\n    ) external {\r\n        _ensureNotDisabled();\r\n        Task storage task = _getTask(_taskId);\r\n        _ensureSenderIsManager(task);\r\n\r\n        _ensureTaskIsOpen(task);\r\n\r\n        if (equal(task.metadata, _newMetadata)) {\r\n            revert PointlessOperation();\r\n        }\r\n        task.metadata = _newMetadata;\r\n        emit MetadataChanged(_taskId, _newMetadata);\r\n    }\r\n\r\n    /// @inheritdoc ITasks\r\n    function completeByDispute(\r\n        uint256 _taskId,\r\n        uint88[] calldata _partialReward,\r\n        uint96[] calldata _partialNativeReward\r\n    ) external {\r\n        _ensureNotDisabled();\r\n        Task storage task = _getTask(_taskId);\r\n        _ensureSenderIsDisputeManager();\r\n\r\n        _ensureTaskIsTaken(task);\r\n\r\n        _payoutTaskPartially(task, _partialReward, _partialNativeReward);\r\n        _refundCreator(task);\r\n\r\n        emit PartialPayment(_taskId, _partialReward, _partialNativeReward);\r\n        emit TaskCompleted(_taskId, TaskCompletion.Dispute);\r\n    }\r\n\r\n    /// @inheritdoc ITasks\r\n    function transferDisputeManagement(address _newManager) external {\r\n        _ensureSenderIsDisputeManager();\r\n        disputeManager = _newManager;\r\n        emit NewDisputeManager(_newManager);\r\n    }\r\n\r\n    /// @inheritdoc ITasks\r\n    function partialPayment(\r\n        uint256 _taskId,\r\n        uint88[] calldata _partialReward,\r\n        uint96[] calldata _partialNativeReward\r\n    ) external {\r\n        _ensureNotDisabled();\r\n        Task storage task = _getTask(_taskId);\r\n        _ensureSenderIsManager(task);\r\n\r\n        _ensureTaskIsTaken(task);\r\n\r\n        _payoutTaskPartially(task, _partialReward, _partialNativeReward);\r\n        emit BudgetChanged(_taskId);\r\n        emit PartialPayment(_taskId, _partialReward, _partialNativeReward);\r\n    }\r\n\r\n    /// @inheritdoc ITasks\r\n    function transferManagement(uint256 _taskId, address _newManager) external {\r\n        _ensureNotDisabled();\r\n        Task storage task = _getTask(_taskId);\r\n        _ensureSenderIsManager(task);\r\n\r\n        _ensureTaskNotClosed(task);\r\n\r\n        task.manager = _newManager;\r\n        emit NewManager(_taskId, _newManager);\r\n    }\r\n\r\n    function disable() external {\r\n        _ensureSenderIsDisabler();\r\n        disabler = address(0);\r\n    }\r\n\r\n    // Ideally you are able to transfer it to the new contract, but that requires addition to the escrow contract\r\n    // I prefer this, so the escrow contract keeps being basic (both for security and clone costs)\r\n    function refund(uint256 _taskId) external {\r\n        _ensureDisabled();\r\n        Task storage task = _getTask(_taskId);\r\n        _ensureTaskNotClosed(task);\r\n        _refundCreator(task);\r\n    }\r\n\r\n    function _getTask(\r\n        uint256 _taskId\r\n    ) internal view returns (Task storage task) {\r\n        if (_taskId >= taskCounter) {\r\n            revert TaskDoesNotExist();\r\n        }\r\n\r\n        task = tasks[_taskId];\r\n    }\r\n\r\n    function _ensureSenderIsDisputeManager() internal view {\r\n        if (msg.sender != disputeManager) {\r\n            revert NotDisputeManager();\r\n        }\r\n    }\r\n\r\n    function _ensureNotDisabled() internal view {\r\n        if (disabler == address(0)) {\r\n            revert Disabled();\r\n        }\r\n    }\r\n\r\n    function _ensureDisabled() internal view {\r\n        if (disabler != address(0)) {\r\n            revert NotDisabled();\r\n        }\r\n    }\r\n\r\n    function _ensureSenderIsDisabler() internal view {\r\n        if (msg.sender != disabler) {\r\n            revert NotDisabler();\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/Tasks/TasksEnsure.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport {ITasks, Escrow} from \"./ITasks.sol\";\r\n\r\n/*\r\n  Functions to ensure a certain precondition is met.\r\n*/\r\nabstract contract TasksEnsure is ITasks {\r\n    function _ensureTaskIsOpen(Task storage task) internal view {\r\n        if (task.state != TaskState.Open) {\r\n            revert TaskNotOpen();\r\n        }\r\n    }\r\n\r\n    function _ensureTaskIsTaken(Task storage task) internal view {\r\n        if (task.state != TaskState.Taken) {\r\n            revert TaskNotTaken();\r\n        }\r\n    }\r\n\r\n    function _ensureTaskNotClosed(Task storage task) internal view {\r\n        if (task.state == TaskState.Closed) {\r\n            revert TaskClosed();\r\n        }\r\n    }\r\n\r\n    function _ensureSenderIsManager(Task storage task) internal view {\r\n        if (task.manager != msg.sender) {\r\n            revert NotManager();\r\n        }\r\n    }\r\n\r\n    ///@dev Should only be called is the task is not open!\r\n    function _ensureSenderIsExecutor(Task storage task) internal view {\r\n        if (\r\n            task.applications[task.executorApplication].applicant != msg.sender\r\n        ) {\r\n            revert NotExecutor();\r\n        }\r\n    }\r\n\r\n    function _ensureRewardEndsWithNextToken(\r\n        Reward[] memory reward\r\n    ) internal pure {\r\n        unchecked {\r\n            if (reward.length != 0 && !reward[reward.length - 1].nextToken) {\r\n                revert RewardDoesntEndWithNextToken();\r\n            }\r\n        }\r\n    }\r\n\r\n    function _ensureApplicationExists(\r\n        Task storage task,\r\n        uint16 _applicationId\r\n    ) internal view {\r\n        if (_applicationId >= task.applicationCount) {\r\n            revert ApplicationDoesNotExist();\r\n        }\r\n    }\r\n\r\n    function _ensureSenderIsApplicant(\r\n        Application storage application\r\n    ) internal view {\r\n        if (application.applicant != msg.sender) {\r\n            revert NotYourApplication();\r\n        }\r\n    }\r\n\r\n    function _ensureApplicationIsAccepted(\r\n        Application storage application\r\n    ) internal view {\r\n        if (!application.accepted) {\r\n            revert ApplicationNotAccepted();\r\n        }\r\n    }\r\n\r\n    function _ensureSubmissionExists(\r\n        Task storage task,\r\n        uint8 _submissionId\r\n    ) internal view {\r\n        if (_submissionId >= task.submissionCount) {\r\n            revert SubmissionDoesNotExist();\r\n        }\r\n    }\r\n\r\n    function _ensureSubmissionNotJudged(\r\n        Submission storage submission\r\n    ) internal view {\r\n        if (submission.judgement != SubmissionJudgement.None) {\r\n            revert SubmissionAlreadyJudged();\r\n        }\r\n    }\r\n\r\n    function _ensureJudgementNotNone(\r\n        SubmissionJudgement judgement\r\n    ) internal pure {\r\n        if (judgement == SubmissionJudgement.None) {\r\n            revert JudgementNone();\r\n        }\r\n    }\r\n\r\n    function _ensureCancelTaskRequestExists(\r\n        Task storage task,\r\n        uint8 _requestId\r\n    ) internal view {\r\n        if (_requestId >= task.cancelTaskRequestCount) {\r\n            revert RequestDoesNotExist();\r\n        }\r\n    }\r\n\r\n    function _ensureRequestNotAccepted(Request storage request) internal view {\r\n        if (request.accepted) {\r\n            revert RequestAlreadyAccepted();\r\n        }\r\n    }\r\n\r\n    function _ensureRequestAccepted(Request storage request) internal view {\r\n        if (!request.accepted) {\r\n            revert RequestNotAccepted();\r\n        }\r\n    }\r\n\r\n    function _ensureRequestNotExecuted(Request storage request) internal view {\r\n        if (request.executed) {\r\n            revert RequestAlreadyExecuted();\r\n        }\r\n    }\r\n\r\n    function _ensureValidTimestamp(uint64 timestamp) internal pure {\r\n        if (timestamp == 0) {\r\n            revert InvalidTimestamp();\r\n        }\r\n    }\r\n\r\n    function _ensureValidAddress(address addr) internal pure {\r\n        if (addr == address(0)) {\r\n            revert InvalidAddress();\r\n        }\r\n    }\r\n\r\n    function _toUint8(uint256 value) internal pure returns (uint8) {\r\n        if (value > type(uint8).max) {\r\n            revert Overflow();\r\n        }\r\n        return uint8(value);\r\n    }\r\n\r\n    function _toUint16(uint256 value) internal pure returns (uint16) {\r\n        if (value > type(uint16).max) {\r\n            revert Overflow();\r\n        }\r\n        return uint16(value);\r\n    }\r\n\r\n    function _toUint96(uint256 value) internal pure returns (uint96) {\r\n        if (value > type(uint96).max) {\r\n            revert Overflow();\r\n        }\r\n        return uint96(value);\r\n    }\r\n}\r\n"
    },
    "contracts/Tasks/TasksUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport {Escrow, TasksEnsure} from \"./TasksEnsure.sol\";\r\n\r\n/*\r\n  Higher level functions to allow the Tasks file to be more readable.\r\n*/\r\nabstract contract TasksUtils is TasksEnsure {\r\n    function _toOffchainTask(\r\n        Task storage task\r\n    ) internal view returns (OffChainTask memory offchainTask) {\r\n        offchainTask.metadata = task.metadata;\r\n        offchainTask.deadline = task.deadline;\r\n        offchainTask.executorApplication = task.executorApplication;\r\n        offchainTask.creator = task.creator;\r\n        offchainTask.manager = task.manager;\r\n        offchainTask.state = task.state;\r\n        offchainTask.escrow = task.escrow;\r\n        offchainTask.nativeBudget = task.nativeBudget;\r\n\r\n        offchainTask.budget = new ERC20Transfer[](task.budgetCount);\r\n        for (uint8 i; i < offchainTask.budget.length; ) {\r\n            offchainTask.budget[i] = task.budget[i];\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n\r\n        offchainTask.applications = new OffChainApplication[](\r\n            task.applicationCount\r\n        );\r\n        for (uint8 i; i < offchainTask.applications.length; ) {\r\n            Application storage application = task.applications[i];\r\n            offchainTask.applications[i].metadata = application.metadata;\r\n            offchainTask.applications[i].applicant = application.applicant;\r\n            offchainTask.applications[i].accepted = application.accepted;\r\n\r\n            offchainTask.applications[i].reward = new Reward[](\r\n                application.rewardCount\r\n            );\r\n            for (uint8 j; j < offchainTask.applications[i].reward.length; ) {\r\n                offchainTask.applications[i].reward[j] = application.reward[j];\r\n                unchecked {\r\n                    ++j;\r\n                }\r\n            }\r\n            offchainTask.applications[i].nativeReward = new NativeReward[](\r\n                application.nativeRewardCount\r\n            );\r\n\r\n            for (\r\n                uint8 j;\r\n                j < offchainTask.applications[i].nativeReward.length;\r\n\r\n            ) {\r\n                offchainTask.applications[i].nativeReward[j] = application\r\n                    .nativeReward[j];\r\n                unchecked {\r\n                    ++j;\r\n                }\r\n            }\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n\r\n        offchainTask.submissions = new Submission[](task.submissionCount);\r\n        for (uint8 i; i < offchainTask.submissions.length; ) {\r\n            offchainTask.submissions[i] = task.submissions[i];\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n\r\n        offchainTask.cancelTaskRequests = new CancelTaskRequest[](\r\n            task.cancelTaskRequestCount\r\n        );\r\n        for (uint8 i; i < offchainTask.cancelTaskRequests.length; ) {\r\n            offchainTask.cancelTaskRequests[i] = task.cancelTaskRequests[i];\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _increaseBudgetToReward(\r\n        Task storage task,\r\n        uint8 _length,\r\n        mapping(uint8 => Reward) storage _reward,\r\n        uint8 _nativeLength,\r\n        mapping(uint8 => NativeReward) storage _nativeReward\r\n    ) internal returns (bool increasedBudget) {\r\n        // Gas optimzation\r\n        if (_length != 0) {\r\n            uint8 j;\r\n            ERC20Transfer memory erc20Transfer = task.budget[0];\r\n            uint256 needed;\r\n            for (uint8 i; i < _length; ) {\r\n                unchecked {\r\n                    needed += _reward[i].amount;\r\n                }\r\n\r\n                if (_reward[i].nextToken) {\r\n                    if (needed > erc20Transfer.amount) {\r\n                        // Existing budget in escrow doesnt cover the needed reward\r\n                        erc20Transfer.tokenContract.transferFrom(\r\n                            msg.sender,\r\n                            address(task.escrow),\r\n                            needed - erc20Transfer.amount\r\n                        );\r\n\r\n                        uint256 got = erc20Transfer.tokenContract.balanceOf(\r\n                            address(task.escrow)\r\n                        );\r\n\r\n                        if (got < needed) {\r\n                            // Apparently there is a tax / fee on the token transfer\r\n                            revert ManualBudgetIncreaseNeeded();\r\n                        }\r\n\r\n                        task.budget[j].amount = _toUint96(got);\r\n                        increasedBudget = true;\r\n                    }\r\n\r\n                    needed = 0;\r\n                    unchecked {\r\n                        erc20Transfer = task.budget[++j];\r\n                    }\r\n                }\r\n\r\n                unchecked {\r\n                    ++i;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (_nativeLength != 0) {\r\n            uint256 nativeNeeded;\r\n            for (uint8 i; i < _nativeLength; ) {\r\n                nativeNeeded += _nativeReward[i].amount;\r\n                unchecked {\r\n                    ++i;\r\n                }\r\n            }\r\n\r\n            if (nativeNeeded > task.nativeBudget) {\r\n                unchecked {\r\n                    if (msg.value != nativeNeeded - task.nativeBudget) {\r\n                        revert IncorrectAmountOfNativeCurrencyAttached();\r\n                    }\r\n                }\r\n\r\n                (bool success, ) = address(task.escrow).call{value: msg.value}(\r\n                    \"\"\r\n                );\r\n                if (!success) {\r\n                    revert NativeTransferFailed();\r\n                }\r\n\r\n                task.nativeBudget = _toUint96(nativeNeeded);\r\n                increasedBudget = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _setRewardBellowBudget(\r\n        Task storage task,\r\n        Application storage application,\r\n        Reward[] calldata _reward,\r\n        NativeReward[] calldata _nativeReward\r\n    ) internal {\r\n        // Gas optimzation\r\n        if (_reward.length != 0) {\r\n            application.rewardCount = _toUint8(_reward.length);\r\n\r\n            uint8 j;\r\n            ERC20Transfer memory erc20Transfer = task.budget[0];\r\n            uint256 alreadyReserved;\r\n            for (uint8 i; i < uint8(_reward.length); ) {\r\n                unchecked {\r\n                    alreadyReserved += _reward[i].amount;\r\n                }\r\n\r\n                application.reward[i] = _reward[i];\r\n\r\n                if (_reward[i].nextToken) {\r\n                    if (alreadyReserved > erc20Transfer.amount) {\r\n                        revert RewardAboveBudget();\r\n                    }\r\n                    alreadyReserved = 0;\r\n                    unchecked {\r\n                        erc20Transfer = task.budget[++j];\r\n                    }\r\n                }\r\n\r\n                unchecked {\r\n                    ++i;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Gas optimzation\r\n        if (_nativeReward.length != 0) {\r\n            application.nativeRewardCount = _toUint8(_nativeReward.length);\r\n            uint256 nativeReserved;\r\n            for (uint8 i; i < uint8(_nativeReward.length); ) {\r\n                unchecked {\r\n                    nativeReserved += _nativeReward[i].amount;\r\n                }\r\n\r\n                application.nativeReward[i] = _nativeReward[i];\r\n\r\n                unchecked {\r\n                    ++i;\r\n                }\r\n            }\r\n\r\n            if (nativeReserved > task.nativeBudget) {\r\n                revert RewardAboveBudget();\r\n            }\r\n        }\r\n    }\r\n\r\n    function _payoutTask(Task storage task) internal {\r\n        Application storage executor = task.applications[\r\n            task.executorApplication\r\n        ];\r\n        address creator = task.creator;\r\n        Escrow escrow = task.escrow;\r\n\r\n        // Gas optimzation\r\n        uint8 rewardCount = executor.rewardCount;\r\n        if (rewardCount != 0) {\r\n            uint8 j;\r\n            uint8 budgetCount = task.budgetCount;\r\n            for (uint8 i; i < budgetCount; ) {\r\n                ERC20Transfer memory erc20Transfer = task.budget[i];\r\n                while (j < rewardCount) {\r\n                    Reward memory reward = executor.reward[j];\r\n                    escrow.transfer(\r\n                        erc20Transfer.tokenContract,\r\n                        reward.to,\r\n                        reward.amount\r\n                    );\r\n\r\n                    unchecked {\r\n                        erc20Transfer.amount -= reward.amount;\r\n                        ++j;\r\n                    }\r\n\r\n                    if (reward.nextToken) {\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                // Gas optimization\r\n                if (erc20Transfer.amount != 0) {\r\n                    escrow.transfer(\r\n                        erc20Transfer.tokenContract,\r\n                        creator,\r\n                        erc20Transfer.amount\r\n                    );\r\n                }\r\n\r\n                unchecked {\r\n                    ++i;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Gas optimzation\r\n        uint8 nativeRewardCount = executor.nativeRewardCount;\r\n        if (nativeRewardCount != 0) {\r\n            uint96 paidOut;\r\n            for (uint8 i; i < nativeRewardCount; ) {\r\n                escrow.transferNative(\r\n                    payable(executor.nativeReward[i].to),\r\n                    executor.nativeReward[i].amount\r\n                );\r\n                unchecked {\r\n                    paidOut += executor.nativeReward[i].amount;\r\n                }\r\n\r\n                unchecked {\r\n                    ++i;\r\n                }\r\n            }\r\n\r\n            // Gas optimzation\r\n            if (paidOut < task.nativeBudget) {\r\n                unchecked {\r\n                    escrow.transferNative(\r\n                        payable(task.creator),\r\n                        task.nativeBudget - paidOut\r\n                    );\r\n                }\r\n            }\r\n        }\r\n\r\n        task.state = TaskState.Closed;\r\n    }\r\n\r\n    function _refundCreator(Task storage task) internal {\r\n        Escrow escrow = task.escrow;\r\n        address creator = task.creator;\r\n\r\n        uint8 budgetCount = task.budgetCount;\r\n        if (budgetCount != 0) {\r\n            for (uint8 i; i < budgetCount; ) {\r\n                ERC20Transfer memory erc20Transfer = task.budget[i];\r\n                escrow.transfer(\r\n                    erc20Transfer.tokenContract,\r\n                    creator,\r\n                    erc20Transfer.amount\r\n                );\r\n\r\n                unchecked {\r\n                    ++i;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Gas optimzation\r\n        if (task.nativeBudget != 0) {\r\n            escrow.transferNative(payable(creator), task.nativeBudget);\r\n        }\r\n\r\n        task.state = TaskState.Closed;\r\n    }\r\n\r\n    function _payoutTaskPartially(\r\n        Task storage task,\r\n        uint88[] calldata _partialReward,\r\n        uint96[] calldata _partialNativeReward\r\n    ) internal {\r\n        Application storage executor = task.applications[\r\n            task.executorApplication\r\n        ];\r\n        Escrow escrow = task.escrow;\r\n\r\n        // Gas optimzation\r\n        uint8 rewardCount = executor.rewardCount;\r\n        if (rewardCount != 0) {\r\n            uint8 j;\r\n            uint8 budgetCount = task.budgetCount;\r\n            for (uint8 i; i < budgetCount; ) {\r\n                ERC20Transfer memory erc20Transfer = task.budget[i];\r\n                while (j < rewardCount) {\r\n                    Reward memory reward = executor.reward[j];\r\n                    if (_partialReward[j] > reward.amount) {\r\n                        revert PartialRewardAboveFullReward();\r\n                    }\r\n\r\n                    escrow.transfer(\r\n                        erc20Transfer.tokenContract,\r\n                        reward.to,\r\n                        _partialReward[j]\r\n                    );\r\n\r\n                    unchecked {\r\n                        executor.reward[j].amount =\r\n                            reward.amount -\r\n                            _partialReward[j];\r\n\r\n                        ++j;\r\n                    }\r\n\r\n                    if (reward.nextToken) {\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                task.budget[i].amount = _toUint96(\r\n                    erc20Transfer.tokenContract.balanceOf(address(escrow))\r\n                );\r\n\r\n                unchecked {\r\n                    ++i;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Gas optimzation\r\n        uint8 nativeRewardCount = executor.nativeRewardCount;\r\n        if (nativeRewardCount != 0) {\r\n            for (uint8 i; i < nativeRewardCount; ) {\r\n                if (_partialNativeReward[i] > executor.nativeReward[i].amount) {\r\n                    revert PartialRewardAboveFullReward();\r\n                }\r\n\r\n                escrow.transferNative(\r\n                    payable(executor.nativeReward[i].to),\r\n                    _partialNativeReward[i]\r\n                );\r\n\r\n                unchecked {\r\n                    executor.nativeReward[i].amount -= _partialNativeReward[i];\r\n                    ++i;\r\n                }\r\n            }\r\n\r\n            unchecked {\r\n                task.nativeBudget = _toUint96(address(escrow).balance);\r\n            }\r\n        }\r\n    }\r\n\r\n    // From: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/proxy/Clones.sol\r\n    function clone(address implementation) internal returns (address instance) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\r\n            // of the `implementation` address with the bytecode before the address.\r\n            mstore(\r\n                0x00,\r\n                or(\r\n                    shr(0xe8, shl(0x60, implementation)),\r\n                    0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000\r\n                )\r\n            )\r\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\r\n            mstore(\r\n                0x20,\r\n                or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3)\r\n            )\r\n            instance := create(0, 0x09, 0x37)\r\n        }\r\n        if (instance == address(0)) {\r\n            revert ERC1167FailedCreateClone();\r\n        }\r\n    }\r\n\r\n    // From: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Strings.sol\r\n    function equal(\r\n        string memory a,\r\n        string memory b\r\n    ) internal pure returns (bool) {\r\n        return keccak256(bytes(a)) == keccak256(bytes(b));\r\n    }\r\n}\r\n"
    },
    "contracts/Token/OwnableERC20Votes.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol\";\r\nimport {ERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\r\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\ncontract OwnableERC20Votes is ERC20Votes, ERC165, Ownable {\r\n    constructor(\r\n        string memory name_,\r\n        string memory symbol_\r\n    ) ERC20(name_, symbol_) ERC20Permit(name_) {}\r\n\r\n    /// @notice Checks if this or the parent contract supports an interface by its ID.\r\n    /// @param _interfaceId The ID of the interface.\r\n    /// @return Returns `true` if the interface is supported.\r\n    function supportsInterface(\r\n        bytes4 _interfaceId\r\n    ) public view virtual override returns (bool) {\r\n        return\r\n            _interfaceId == type(IERC20).interfaceId ||\r\n            _interfaceId == type(IERC20Metadata).interfaceId ||\r\n            _interfaceId == type(IERC20Permit).interfaceId ||\r\n            _interfaceId == type(IVotes).interfaceId ||\r\n            super.supportsInterface(_interfaceId);\r\n    }\r\n\r\n    /// @notice Mints tokens to an address.\r\n    /// @param to The address receiving the tokens.\r\n    /// @param amount The amount of tokens to be minted.\r\n    function mint(address to, uint256 amount) external virtual onlyOwner {\r\n        _mint(to, amount);\r\n    }\r\n\r\n    // https://forum.openzeppelin.com/t/self-delegation-in-erc20votes/17501/12?u=novaknole\r\n    /// @inheritdoc ERC20Votes\r\n    function _afterTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal override {\r\n        super._afterTokenTransfer(from, to, amount);\r\n\r\n        // Automatically turn on delegation on mint/transfer but only for the first time.\r\n        if (\r\n            to != address(0) &&\r\n            numCheckpoints(to) == 0 &&\r\n            delegates(to) == address(0)\r\n        ) {\r\n            _delegate(to, to);\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/Token/OwnableERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport {ERC721Enumerable, ERC721} from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\r\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\ncontract OwnableERC721Enumerable is ERC721Enumerable, Ownable {\r\n    constructor(\r\n        string memory name_,\r\n        string memory symbol_\r\n    ) ERC721(name_, symbol_) {}\r\n\r\n    /// @notice Mints a token to an address.\r\n    /// @param to The address receiving the token.\r\n    /// @param tokenId The id of the token to be minted.\r\n    function mint(address to, uint256 tokenId) external virtual onlyOwner {\r\n        _mint(to, tokenId);\r\n    }\r\n\r\n    /// @notice Burns a token.\r\n    /// @param tokenId The id of the token to be burned.\r\n    function burn(uint256 tokenId) external virtual onlyOwner {\r\n        _burn(tokenId);\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}